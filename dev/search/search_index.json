{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Agent2Agent (A2A) Protocol"},{"location":"#what-is-a2a-protocol","title":"What is A2A Protocol?","text":"<p>Welcome to the official documentation for the Agent2Agent (A2A) Protocol, an open standard designed to enable seamless communication and collaboration between AI agents.</p> <p>Originally developed by Google and now donated to the Linux Foundation, A2A provides the definitive common language for agent interoperability in a world where agents are built using diverse frameworks and by different vendors.</p> <p>Build with  ADK (or any framework), equip with  MCP (or any tool), and communicate with  A2A, to remote agents, local agents, and humans.</p>"},{"location":"#get-started-with-a2a","title":"Get started with A2A","text":"<ul> <li> <p> Video Intro in &lt;8 min</p> <p></p> </li> <li> <p> Read the Introduction</p> <p>Understand the core ideas behind A2A.</p> <p> What is A2A?</p> <p> Key Concepts</p> </li> <li> <p> Dive into the Specification</p> <p>Explore the detailed technical definition of the A2A protocol.</p> <p> Protocol Specification</p> </li> <li> <p> Follow the Tutorials</p> <p>Build your first A2A-compliant agent with our step-by-step Python quickstart.</p> <p> Python Tutorial</p> </li> <li> <p> Explore Code Samples</p> <p>See A2A in action with sample clients, servers, and agent framework integrations.</p> <p> GitHub Samples</p> </li> <li> <p> Download the Official SDKs</p> <p> Python</p> <p> JavaScript</p> <p> Java</p> <p> C#/.NET</p> <p> Golang</p> </li> </ul>"},{"location":"#why-use-the-a2a-protocol","title":"Why use the A2A Protocol","text":"<pre><code>graph LR\n    User(\ud83e\uddd1\u200d\ud83d\udcbb User) &lt;--&gt; ClientAgent(\ud83e\udd16 Client Agent)\n    ClientAgent --&gt; A2A1(**\u2194\ufe0f A2A**) --&gt; RemoteAgent1(\ud83e\udd16 Remote Agent 1)\n    ClientAgent --&gt; A2A2(**\u2194\ufe0f A2A**) --&gt; RemoteAgent2(\ud83e\udd16 Remote Agent 2)\n\n    style User fill:#fdebd0,stroke:#e67e22,stroke-width:2px\n    style ClientAgent fill:#d6eaf8,stroke:#3498db,stroke-width:2px\n    style RemoteAgent1 fill:#d6eaf8,stroke:#3498db,stroke-width:2px\n    style RemoteAgent2 fill:#d6eaf8,stroke:#3498db,stroke-width:2px\n    style A2A1 fill:#ebedef,stroke:#909497,stroke-width:2px\n    style A2A2 fill:#ebedef,stroke:#909497,stroke-width:2px</code></pre> <ul> <li> <p> Interoperability</p> <p>Connect agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions) to create powerful, composite AI systems.</p> </li> <li> <p> Complex Workflows</p> <p>Enable agents to delegate sub-tasks, exchange information, and coordinate actions to solve complex problems that a single agent cannot.</p> </li> <li> <p> Secure &amp; Opaque</p> <p>Agents interact without needing to share internal memory, tools, or proprietary logic, ensuring security and preserving intellectual property.</p> </li> </ul>"},{"location":"#how-does-a2a-work-with-mcp","title":"How does A2A work with MCP?","text":"<p>A2A and Model Context Protocol (MCP) are complementary standards for building robust agentic applications:</p> <ul> <li>Model Context Protocol (MCP): Provides agent-to-tool communication. It's a complementary standard that standardizes how an agent connects to its tools, APIs, and resources to get information.</li> <li>IBM ACP: Incorporated into the A2A Protocol</li> <li>Cisco agntcy: A framework that provides components to the Internet of Agents with discovery, group communication, identity and observability and leverages A2A and MCP for agent communication and tool calling.</li> <li>A2A: Provides agent-to-agent communication. As a universal, decentralized standard, A2A acts as the public internet that allows ai agents\u2014including those using MCP, or built with frameworks like agntcy\u2014to interoperate, collaborate, and share their findings.</li> </ul>"},{"location":"community/","title":"A2A Community Hub","text":"<p>Welcome to the official community hub for the Agent2Agent (A2A) protocol! A2A is an open, standardized protocol that enables seamless interoperability and collaboration between AI agents across all frameworks and vendors.</p>"},{"location":"community/#recent-news-blog-posts","title":"Recent News &amp; Blog Posts","text":"<p>Stay up-to-date with the latest announcements, tutorials, and insights from the A2A team and our community.</p> <ul> <li>Announcing Agent Payments Protocol (AP2) - September 16</li> <li>A2A Extensions Empowering Custom Agent Functionality - September 9</li> <li>A2A protocol: Demystifying Tasks vs Messages - August 18</li> <li>End-to-end evaluation of multi-agent systems on Vertex AI - August 7</li> <li>Agent2Agent (A2A) protocol is getting an upgrade - July 26</li> </ul>"},{"location":"community/#use-case-highlights","title":"Use Case Highlights","text":"<p>A2A unlocks powerful new ways for AI agents to collaborate and solve complex problems. Here are a few examples of what's possible:</p> <ul> <li>Multi-Agent Workflows: Chain specialized agents together to automate complex processes, like candidate sourcing for hiring or streamlining supply chain logistics.</li> <li>Agent Marketplaces: Create platforms where agents can discover and utilize the capabilities of other agents from different providers.</li> <li>Cross-Platform Integration: Connect agents built on different frameworks\u2014like LangGraph, BeeAI, and more\u2014to work together seamlessly.</li> <li>Evaluating Multi-Agent Systems: Use frameworks like Vertex AI to assess the performance and success of collaborative agent trajectories.</li> </ul>"},{"location":"community/#community-spotlight","title":"Community Spotlight","text":""},{"location":"community/#featured-contributions","title":"Featured Contributions","text":"<p>A2A is an open-source protocol, and we thrive on community contributions. A huge thank you to everyone who has helped build and improve A2A! Here are some recent highlights:</p> <ul> <li>Python Quickstart Tutorial (PR#202)</li> <li>LlamaIndex sample implementation (PR#179)</li> <li>Autogen sample server (PR#232)</li> <li>AG2 + MCP example (PR#230)</li> <li>PydanticAI example (PR#127)</li> </ul>"},{"location":"community/#the-word-on-the-street","title":"The Word on the Street","text":"<p>The launch of A2A has sparked lively discussions and positive reactions across various social and video platforms.</p> <ul> <li>Microsoft's Semantic Kernel: Asha Sharma, Head of AI Platform Product at Microsoft, announced on LinkedIn that \"Semantic Kernel now speaks A2A,\" enabling instant, secure interoperability.</li> <li>Matt Pocock's Diagramming: Well-known developer educator Matt Pocock shared diagrams on X explaining the A2A protocol, which were liked and reposted hundreds of times.</li> <li>Craig McLuckie's \"Hot Take\": Craig McLuckie shared his thoughts on LinkedIn, highlighting A2A's focus on interactions between agentic systems as a sensible approach.</li> <li>Zachary Huang's Deep Dive: In his YouTube video, Zachary explains how A2A complements MCP, with A2A handling communication between agents and MCP connecting agents to tools.</li> </ul>"},{"location":"community/#a2a-integrations","title":"A2A Integrations","text":"<p>These agentic frameworks have built-in A2A integration, making it easy to get started:</p> <ul> <li>Agent Development Kit (ADK)</li> <li>Agno</li> <li>AG2</li> <li>BeeAI Framework</li> <li>CrewAI</li> <li>Hector</li> <li>LangGraph</li> <li>LiteLLM</li> <li>Microsoft Agent Framework</li> <li>Pydantic AI</li> <li>Slide (Tyler)</li> <li>Strands Agents</li> </ul>"},{"location":"community/#the-future-is-interoperable","title":"The Future is Interoperable","text":"<p>The excitement surrounding Google's A2A protocol clearly indicates a strong belief in its potential to revolutionize multi-agent AI systems. By providing a standardized way for AI agents to communicate and collaborate, A2A is poised to unlock new levels of automation and innovation. As enterprises increasingly adopt AI agents, A2A represents a crucial step towards realizing the full power of interconnected AI ecosystems.</p> <p>Join the growing community building the future of AI interoperability with A2A!</p>"},{"location":"definitions/","title":"A2A Definition/Schema","text":"ProtobufJSON <p>Protobuf The normative A2A protocol definition in Protocol Buffers (proto3 syntax). This is the source of truth for the A2A protocol specification.</p> <p>Download</p> <p>You can download the proto file directly: <code>a2a.proto</code></p> <p>Definition</p> <pre><code>// Older protoc compilers don't understand edition yet.\nsyntax = \"proto3\";\npackage a2a.v1;\n\nimport \"google/api/annotations.proto\";\nimport \"google/api/client.proto\";\nimport \"google/api/field_behavior.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"google/protobuf/timestamp.proto\";\n\noption csharp_namespace = \"A2a.V1\";\noption go_package = \"google.golang.org/a2a/v1\";\noption java_multiple_files = true;\noption java_outer_classname = \"A2A\";\noption java_package = \"com.google.a2a.v1\";\n\n// A2AService defines the operations of the A2A protocol.\nservice A2AService {\n  // Send a message to the agent.\n  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse) {\n    option (google.api.http) = {\n      post: \"/message:send\"\n      body: \"*\"\n      additional_bindings: {\n        post: \"/{tenant}/message:send\"\n        body: \"*\"\n      }\n    };\n  }\n  // SendStreamingMessage is a streaming version of SendMessage.\n  rpc SendStreamingMessage(SendMessageRequest) returns (stream StreamResponse) {\n    option (google.api.http) = {\n      post: \"/message:stream\"\n      body: \"*\"\n      additional_bindings: {\n        post: \"/{tenant}/message:stream\"\n        body: \"*\"\n      }\n    };\n  }\n\n  // Get the current state of a task from the agent.\n  rpc GetTask(GetTaskRequest) returns (Task) {\n    option (google.api.http) = {\n      get: \"/{name=tasks/*}\"\n      additional_bindings: {\n        get: \"/{tenant}/{name=tasks/*}\"\n      }\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n  // List tasks with optional filtering and pagination.\n  rpc ListTasks(ListTasksRequest) returns (ListTasksResponse) {\n    option (google.api.http) = {\n      get: \"/tasks\"\n      additional_bindings: {\n        get: \"/{tenant}/tasks\"\n      }\n    };\n  }\n  // Cancel a task.\n  rpc CancelTask(CancelTaskRequest) returns (Task) {\n    option (google.api.http) = {\n      post: \"/{name=tasks/*}:cancel\"\n      body: \"*\"\n      additional_bindings: {\n        post: \"/{tenant}/{name=tasks/*}:cancel\"\n        body: \"*\"\n      }\n    };\n  }\n  // SubscribeToTask allows subscribing to task updates for tasks not in terminal state.\n  // Returns UnsupportedOperationError if task is in terminal state (completed, failed, canceled, rejected).\n  rpc SubscribeToTask(SubscribeToTaskRequest) returns (stream StreamResponse) {\n    option (google.api.http) = {\n      get: \"/{name=tasks/*}:subscribe\"\n      additional_bindings: {\n        get: \"/{tenant}/{name=tasks/*}:subscribe\"\n      }\n    };\n  }\n\n  // Create a push notification config for a task.\n  rpc CreateTaskPushNotificationConfig(CreateTaskPushNotificationConfigRequest) returns (TaskPushNotificationConfig) {\n    option (google.api.http) = {\n      post: \"/{parent=tasks/*/pushNotificationConfigs}\"\n      body: \"config\"\n      additional_bindings: {\n        post: \"/{tenant}/{parent=tasks/*/pushNotificationConfigs}\"\n        body: \"config\"\n      }\n    };\n    option (google.api.method_signature) = \"parent,config\";\n  }\n  // Get a push notification config for a task.\n  rpc GetTaskPushNotificationConfig(GetTaskPushNotificationConfigRequest) returns (TaskPushNotificationConfig) {\n    option (google.api.http) = {\n      get: \"/{name=tasks/*/pushNotificationConfigs/*}\"\n      additional_bindings: {\n        get: \"/{tenant}/{name=tasks/*/pushNotificationConfigs/*}\"\n      }\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n  // Get a list of push notifications configured for a task.\n  rpc ListTaskPushNotificationConfig(ListTaskPushNotificationConfigRequest) returns (ListTaskPushNotificationConfigResponse) {\n    option (google.api.http) = {\n      get: \"/{parent=tasks/*}/pushNotificationConfigs\"\n      additional_bindings: {\n        get: \"/{tenant}/{parent=tasks/*}/pushNotificationConfigs\"\n      }\n    };\n    option (google.api.method_signature) = \"parent\";\n  }\n  // GetExtendedAgentCard returns the extended agent card for authenticated agents.\n  rpc GetExtendedAgentCard(GetExtendedAgentCardRequest) returns (AgentCard) {\n    option (google.api.http) = {\n      get: \"/extendedAgentCard\"\n      additional_bindings: {\n        get: \"/{tenant}/extendedAgentCard\"\n      }\n    };\n  }\n  // Delete a push notification config for a task.\n  rpc DeleteTaskPushNotificationConfig(DeleteTaskPushNotificationConfigRequest) returns (google.protobuf.Empty) {\n    option (google.api.http) = {\n      delete: \"/{name=tasks/*/pushNotificationConfigs/*}\"\n      additional_bindings: {\n        delete: \"/{tenant}/{name=tasks/*/pushNotificationConfigs/*}\"\n      }\n    };\n    option (google.api.method_signature) = \"name\";\n  }\n}\n\n///////// Data Model ////////////\n\n// Configuration of a send message request.\nmessage SendMessageConfiguration {\n  // A list of media types the client is prepared to accept for response parts. Agents SHOULD use this to tailor their output.\n  repeated string accepted_output_modes = 1;\n  // Configuration for the agent to send push notifications for task updates.\n  PushNotificationConfig push_notification_config = 2;\n  // The maximum number of most recent messages from the task's history to retrieve in\n  // the response. An unset value means the client does not impose any limit. A\n  // value of zero is a request to not include any messages. The server MUST NOT\n  // return more messages than the provided value, but MAY apply a lower limit.\n  optional int32 history_length = 3;\n  // If true, the operation waits until the task reaches a terminal or interrupted state before returning. Default is false.\n  bool blocking = 4;\n}\n\n// Task is the core unit of action for A2A. It has a current status\n// and when results are created for the task they are stored in the\n// artifact. If there are multiple turns for a task, these are stored in\n// history.\nmessage Task {\n  // Unique identifier (e.g. UUID) for the task, generated by the server for a\n  // new task.\n  string id = 1 [(google.api.field_behavior) = REQUIRED];\n  // Unique identifier (e.g. UUID) for the contextual collection of interactions\n  // (tasks and messages). Created by the A2A server.\n  string context_id = 2 [(google.api.field_behavior) = REQUIRED];\n  // The current status of a Task, including state and a message.\n  TaskStatus status = 3 [(google.api.field_behavior) = REQUIRED];\n  // A set of output artifacts for a Task.\n  repeated Artifact artifacts = 4;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // The history of interactions from a task.\n  repeated Message history = 5;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n  // A key/value object to store custom metadata about a task.\n  google.protobuf.Struct metadata = 6;\n}\n\n// Defines the possible lifecycle states of a Task.\nenum TaskState {\n  // The task is in an unknown or indeterminate state.\n  TASK_STATE_UNSPECIFIED = 0;\n  // Represents the status that acknowledges a task is created.\n  TASK_STATE_SUBMITTED = 1;\n  // Represents the status that a task is actively being processed.\n  TASK_STATE_WORKING = 2;\n  // Represents the status a task is finished. This is a terminal state.\n  TASK_STATE_COMPLETED = 3;\n  // Represents the status a task is done but failed. This is a terminal state.\n  TASK_STATE_FAILED = 4;\n  // Represents the status a task was canceled before it finished.\n  // This is a terminal state.\n  TASK_STATE_CANCELED = 5;\n  // Represents the status that the task requires information to complete.\n  // This is an interrupted state.\n  TASK_STATE_INPUT_REQUIRED = 6;\n  // Represents the status that the agent has decided to not perform the task.\n  // This may be done during initial task creation or later once an agent\n  // has determined it can't or won't proceed. This is a terminal state.\n  TASK_STATE_REJECTED = 7;\n  // Represents the state that some authentication is needed from the upstream\n  // client. This is an interrupted state. Authentication is expected to come out-of-band.\n  TASK_STATE_AUTH_REQUIRED = 8;\n}\n\n// A container for the status of a task\nmessage TaskStatus {\n  // The current state of this task.\n  TaskState state = 1 [(google.api.field_behavior) = REQUIRED];\n  // A message associated with the status.\n  Message message = 2;\n  // ISO 8601 Timestamp when the status was recorded.\n  // Example: \"2023-10-27T10:00:00Z\"\n  google.protobuf.Timestamp timestamp = 3;\n}\n\n// Part represents a container for a section of communication content.\n// Parts can be purely textual, some sort of file (image, video, etc) or\n// a structured data blob (i.e. JSON).\nmessage Part {\n  oneof content {\n    // The string content of the text part.\n    string text = 1;\n    // The raw byte content of a file. In JSON serialization, this is encoded as a base64 string.\n    bytes raw = 2;\n    // A URL pointing to the file's content.\n    string url = 3;\n    // Arbitrary structured data as a JSON value (object, array, string, number, boolean, or null).\n    google.protobuf.Value data = 4;\n  }\n  // Optional metadata associated with this part.\n  google.protobuf.Struct metadata = 5;\n  // An optional name for the file (e.g., \"document.pdf\").\n  string filename = 6;\n  // The media type (MIME type) of the part content (e.g., \"text/plain\", \"application/json\", \"image/png\").\n  // This field is available for all part types.\n  string media_type = 7;\n}\n\n// Defines the sender of a message in A2A protocol communication.\nenum Role {\n  ROLE_UNSPECIFIED = 0;\n  // USER role refers to communication from the client to the server.\n  ROLE_USER = 1;\n  // AGENT role refers to communication from the server to the client.\n  ROLE_AGENT = 2;\n}\n\n// Message is one unit of communication between client and server. It can be\n// associated with a context and/or a task. For server messages, context_id must\n// be provided, and task_id only if a task was created. For client messages, both\n// fields are optional, with the caveat that if both are provided, they have to\n// match (the context_id has to be the one that is set on the task). If only\n// task_id is provided, the server will infer context_id from it.\nmessage Message {\n  // The unique identifier (e.g. UUID) of the message. This is required and\n  // created by the message creator.\n  string message_id = 1 [(google.api.field_behavior) = REQUIRED];\n  // The context id of the message. This is optional and if set, the message\n  // will be associated with the given context.\n  string context_id = 2;\n  // The task id of the message. This is optional and if set, the message\n  // will be associated with the given task.\n  string task_id = 3;\n  // Identifies the sender of the message.\n  Role role = 4 [(google.api.field_behavior) = REQUIRED];\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // Parts is the container of the message content.\n  repeated Part parts = 5 [(google.api.field_behavior) = REQUIRED];\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n  // Any optional metadata to provide along with the message.\n  google.protobuf.Struct metadata = 6;\n  // The URIs of extensions that are present or contributed to this Message.\n  repeated string extensions = 7;\n  // A list of task IDs that this message references for additional context.\n  repeated string reference_task_ids = 8;\n}\n\n// Artifacts represent task outputs.\nmessage Artifact {\n  // Unique identifier (e.g. UUID) for the artifact. It must be at least unique\n  // within a task.\n  string artifact_id = 1 [(google.api.field_behavior) = REQUIRED];\n  // A human readable name for the artifact.\n  string name = 3;\n  // A human readable description of the artifact, optional.\n  string description = 4;\n  // The content of the artifact. Must contain at least one part.\n  repeated Part parts = 5 [(google.api.field_behavior) = REQUIRED];\n  // Optional metadata included with the artifact.\n  google.protobuf.Struct metadata = 6;\n  // The URIs of extensions that are present or contributed to this Artifact.\n  repeated string extensions = 7;\n}\n\n// An event sent by the agent to notify the client of a change in a task's\n// status.\nmessage TaskStatusUpdateEvent {\n  // The id of the task that is changed\n  string task_id = 1 [(google.api.field_behavior) = REQUIRED];\n  // The id of the context that the task belongs to\n  string context_id = 2 [(google.api.field_behavior) = REQUIRED];\n  // The new status of the task.\n  TaskStatus status = 3 [(google.api.field_behavior) = REQUIRED];\n  reserved 4;\n  // Optional metadata to associate with the task update.\n  google.protobuf.Struct metadata = 5;\n}\n\n// TaskArtifactUpdateEvent represents a task delta where an artifact has\n// been generated.\nmessage TaskArtifactUpdateEvent {\n  // The id of the task for this artifact.\n  string task_id = 1 [(google.api.field_behavior) = REQUIRED];\n  // The id of the context that this task belongs to.\n  string context_id = 2 [(google.api.field_behavior) = REQUIRED];\n  // The artifact that was generated or updated.\n  Artifact artifact = 3 [(google.api.field_behavior) = REQUIRED];\n  // If true, the content of this artifact should be appended to a previously\n  // sent artifact with the same ID.\n  bool append = 4;\n  // If true, this is the final chunk of the artifact.\n  bool last_chunk = 5;\n  // Optional metadata associated with the artifact update.\n  google.protobuf.Struct metadata = 6;\n}\n\n// Configuration for setting up push notifications for task updates.\nmessage PushNotificationConfig {\n  // A unique identifier (e.g. UUID) for this push notification.\n  string id = 1;\n  // Url to send the notification too\n  string url = 2 [(google.api.field_behavior) = REQUIRED];\n  // Token unique for this task/session\n  string token = 3;\n  // Authentication information required to send the notification\n  AuthenticationInfo authentication = 4;\n}\n\n// Defines authentication details, used for push notifications.\nmessage AuthenticationInfo {\n  // HTTP Authentication Scheme from the [IANA registry](https://www.iana.org/assignments/http-authschemes/).\n  // Common values: `Bearer`, `Basic`, `Digest`. Scheme names are case-insensitive per [RFC 9110 Section 11.1](https://www.rfc-editor.org/rfc/rfc9110#section-11.1).\n  string scheme = 1 [(google.api.field_behavior) = REQUIRED];\n  // Push Notification credentials. Format depends on the scheme (e.g., token for Bearer).\n  string credentials = 2;\n}\n\n// Declares a combination of a target URL and a transport protocol for interacting with the agent.\n// This allows agents to expose the same functionality over multiple protocol binding mechanisms.\nmessage AgentInterface {\n  // The URL where this interface is available. Must be a valid absolute HTTPS URL in production.\n  // Example: \"https://api.example.com/a2a/v1\", \"https://grpc.example.com/a2a\"\n  string url = 1 [(google.api.field_behavior) = REQUIRED];\n  // The protocol binding supported at this URL. This is an open form string, to be\n  // easily extended for other protocol bindings. The core ones officially\n  // supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.\n  string protocol_binding = 2 [(google.api.field_behavior) = REQUIRED];\n  // Tenant to be set in the request when calling the agent.\n  string tenant = 3;\n}\n\n// AgentCard is a self-describing manifest for an agent. It provides essential\n// metadata including the agent's identity, capabilities, skills, supported\n// communication methods, and security requirements.\n// Next ID: 20\nmessage AgentCard {\n  // The versions of the A2A protocol this agent supports.\n  // For stable versions (1.x+), list only the latest supported minor version per major version.\n  // For legacy experimental versions (0.x), explicitly list each supported version.\n  // Default: [\"1.0\"]\n  repeated string protocol_versions = 16 [(google.api.field_behavior) = REQUIRED];\n  // Reserve these field numbers as they were previously used by removed\n  // fields.\n  reserved 3, 14, 15;\n  // A human readable name for the agent.\n  // Example: \"Recipe Agent\"\n  string name = 1 [(google.api.field_behavior) = REQUIRED];\n  // A human-readable description of the agent, assisting users and other agents\n  // in understanding its purpose.\n  // Example: \"Agent that helps users with recipes and cooking.\"\n  string description = 2 [(google.api.field_behavior) = REQUIRED];\n  // Ordered list of supported interfaces. First entry is preferred.\n  repeated AgentInterface supported_interfaces = 19 [(google.api.field_behavior) = REQUIRED];\n  // The service provider of the agent.\n  AgentProvider provider = 4;\n  // The version of the agent.\n  // Example: \"1.0.0\"\n  string version = 5 [(google.api.field_behavior) = REQUIRED];\n  // A url to provide additional documentation about the agent.\n  optional string documentation_url = 6;\n  // A2A Capability set supported by the agent.\n  AgentCapabilities capabilities = 7 [(google.api.field_behavior) = REQUIRED];\n  // The security scheme details used for authenticating with this agent.\n  map&lt;string, SecurityScheme&gt; security_schemes = 8;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // Security requirements for contacting the agent.\n  repeated Security security = 9;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n  // The set of interaction modes that the agent supports across all skills.\n  // This can be overridden per skill. Defined as media types.\n  repeated string default_input_modes = 10 [(google.api.field_behavior) = REQUIRED];\n  // The media types supported as outputs from this agent.\n  repeated string default_output_modes = 11 [(google.api.field_behavior) = REQUIRED];\n  // Skills represent an ability of an agent. It is largely\n  // a descriptive concept but represents a more focused set of behaviors that the\n  // agent is likely to succeed at.\n  repeated AgentSkill skills = 12 [(google.api.field_behavior) = REQUIRED];\n  // JSON Web Signatures computed for this AgentCard.\n  repeated AgentCardSignature signatures = 17;\n  // An optional URL to an icon for the agent.\n  optional string icon_url = 18;\n}\n\n// Represents the service provider of an agent.\nmessage AgentProvider {\n  // A URL for the agent provider's website or relevant documentation.\n  // Example: \"https://ai.google.dev\"\n  string url = 1 [(google.api.field_behavior) = REQUIRED];\n  // The name of the agent provider's organization.\n  // Example: \"Google\"\n  string organization = 2 [(google.api.field_behavior) = REQUIRED];\n}\n\n// Defines optional capabilities supported by an agent.\nmessage AgentCapabilities {\n  // Indicates if the agent supports streaming responses.\n  optional bool streaming = 1;\n  // Indicates if the agent supports sending push notifications for asynchronous task updates.\n  optional bool push_notifications = 2;\n  // A list of protocol extensions supported by the agent.\n  repeated AgentExtension extensions = 3;\n  // Field 4 was previously used by state_transition_history capability.\n  reserved 4;\n  // Indicates if the agent supports providing an extended agent card when authenticated.\n  optional bool extended_agent_card = 5;\n}\n\n// A declaration of a protocol extension supported by an Agent.\nmessage AgentExtension {\n  // The unique URI identifying the extension.\n  string uri = 1;\n  // A human-readable description of how this agent uses the extension.\n  string description = 2;\n  // If true, the client must understand and comply with the extension's requirements.\n  bool required = 3;\n  // Optional, extension-specific configuration parameters.\n  google.protobuf.Struct params = 4;\n}\n\n// Represents a distinct capability or function that an agent can perform.\nmessage AgentSkill {\n  // A unique identifier for the agent's skill.\n  string id = 1 [(google.api.field_behavior) = REQUIRED];\n  // A human-readable name for the skill.\n  string name = 2 [(google.api.field_behavior) = REQUIRED];\n  // A detailed description of the skill.\n  string description = 3 [(google.api.field_behavior) = REQUIRED];\n  // A set of keywords describing the skill's capabilities.\n  repeated string tags = 4 [(google.api.field_behavior) = REQUIRED];\n  // Example prompts or scenarios that this skill can handle.\n  repeated string examples = 5;\n  // The set of supported input media types for this skill, overriding the agent's defaults.\n  repeated string input_modes = 6;\n  // The set of supported output media types for this skill, overriding the agent's defaults.\n  repeated string output_modes = 7;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // Security schemes necessary for this skill.\n  repeated Security security = 8;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n}\n\n// AgentCardSignature represents a JWS signature of an AgentCard.\n// This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).\nmessage AgentCardSignature {\n  // The protected JWS header for the signature. This is always a\n  // base64url-encoded JSON object. Required.\n  string protected = 1 [(google.api.field_behavior) = REQUIRED];\n  // The computed signature, base64url-encoded. Required.\n  string signature = 2 [(google.api.field_behavior) = REQUIRED];\n  // The unprotected JWS header values.\n  google.protobuf.Struct header = 3;\n}\n\n// A container associating a push notification configuration with a specific\n// task.\nmessage TaskPushNotificationConfig {\n  // The resource name of the config.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1 [(google.api.field_behavior) = REQUIRED];\n  // The push notification configuration details.\n  PushNotificationConfig push_notification_config = 2 [(google.api.field_behavior) = REQUIRED];\n}\n\n// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\nmessage StringList {\n  repeated string list = 1;\n}\n// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n\nmessage Security {\n  map&lt;string, StringList&gt; schemes = 1;\n}\n\n// Defines a security scheme that can be used to secure an agent's endpoints.\n// This is a discriminated union type based on the OpenAPI 3.2 Security Scheme Object.\n// See: https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object\nmessage SecurityScheme {\n  oneof scheme {\n    // API key-based authentication.\n    APIKeySecurityScheme api_key_security_scheme = 1;\n    // HTTP authentication (Basic, Bearer, etc.).\n    HTTPAuthSecurityScheme http_auth_security_scheme = 2;\n    // OAuth 2.0 authentication.\n    OAuth2SecurityScheme oauth2_security_scheme = 3;\n    // OpenID Connect authentication.\n    OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4;\n    // Mutual TLS authentication.\n    MutualTlsSecurityScheme mtls_security_scheme = 5;\n  }\n}\n\n// Defines a security scheme using an API key.\nmessage APIKeySecurityScheme {\n  // An optional description for the security scheme.\n  string description = 1;\n  // The location of the API key. Valid values are \"query\", \"header\", or \"cookie\".\n  string location = 2 [(google.api.field_behavior) = REQUIRED];\n  // The name of the header, query, or cookie parameter to be used.\n  string name = 3 [(google.api.field_behavior) = REQUIRED];\n}\n\n// Defines a security scheme using HTTP authentication.\nmessage HTTPAuthSecurityScheme {\n  // An optional description for the security scheme.\n  string description = 1;\n  // The name of the HTTP Authentication scheme to be used in the Authorization header,\n  // as defined in RFC7235 (e.g., \"Bearer\").\n  // This value should be registered in the IANA Authentication Scheme registry.\n  string scheme = 2 [(google.api.field_behavior) = REQUIRED];\n  // A hint to the client to identify how the bearer token is formatted (e.g., \"JWT\").\n  // This is primarily for documentation purposes.\n  string bearer_format = 3;\n}\n\n// Defines a security scheme using OAuth 2.0.\nmessage OAuth2SecurityScheme {\n  // An optional description for the security scheme.\n  string description = 1;\n  // An object containing configuration information for the supported OAuth 2.0 flows.\n  OAuthFlows flows = 2 [(google.api.field_behavior) = REQUIRED];\n  // URL to the oauth2 authorization server metadata\n  // RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.\n  string oauth2_metadata_url = 3;\n}\n\n// Defines a security scheme using OpenID Connect.\nmessage OpenIdConnectSecurityScheme {\n  // An optional description for the security scheme.\n  string description = 1;\n  // The OpenID Connect Discovery URL for the OIDC provider's metadata.\n  // See: https://openid.net/specs/openid-connect-discovery-1_0.html\n  string open_id_connect_url = 2 [(google.api.field_behavior) = REQUIRED];\n}\n\n// Defines a security scheme using mTLS authentication.\nmessage MutualTlsSecurityScheme {\n  // An optional description for the security scheme.\n  string description = 1;\n}\n\n// Defines the configuration for the supported OAuth 2.0 flows.\nmessage OAuthFlows {\n  // Tags 3 and 4 were previously used by deprecated OAuth flows.\n  reserved 3, 4;\n  oneof flow {\n    // Configuration for the OAuth Authorization Code flow.\n    AuthorizationCodeOAuthFlow authorization_code = 1;\n    // Configuration for the OAuth Client Credentials flow.\n    ClientCredentialsOAuthFlow client_credentials = 2;\n    // Configuration for the OAuth Device Code flow.\n    DeviceCodeOAuthFlow device_code = 5;\n  }\n}\n\n// Defines configuration details for the OAuth 2.0 Authorization Code flow.\nmessage AuthorizationCodeOAuthFlow {\n  // The authorization URL to be used for this flow.\n  string authorization_url = 1 [(google.api.field_behavior) = REQUIRED];\n  // The token URL to be used for this flow.\n  string token_url = 2 [(google.api.field_behavior) = REQUIRED];\n  // The URL to be used for obtaining refresh tokens.\n  string refresh_url = 3;\n  // The available scopes for the OAuth2 security scheme.\n  map&lt;string, string&gt; scopes = 4 [(google.api.field_behavior) = REQUIRED];\n  // Indicates if PKCE (RFC 7636) is required for this flow.\n  // PKCE should always be used for public clients and is recommended for all clients.\n  bool pkce_required = 5;\n}\n\n// Defines configuration details for the OAuth 2.0 Client Credentials flow.\nmessage ClientCredentialsOAuthFlow {\n  // The token URL to be used for this flow.\n  string token_url = 1 [(google.api.field_behavior) = REQUIRED];\n  // The URL to be used for obtaining refresh tokens.\n  string refresh_url = 2;\n  // The available scopes for the OAuth2 security scheme.\n  map&lt;string, string&gt; scopes = 3 [(google.api.field_behavior) = REQUIRED];\n}\n\n// Defines configuration details for the OAuth 2.0 Device Code flow (RFC 8628).\n// This flow is designed for input-constrained devices such as IoT devices,\n// and CLI tools where the user authenticates on a separate device.\nmessage DeviceCodeOAuthFlow {\n  // The device authorization endpoint URL.\n  string device_authorization_url = 1 [(google.api.field_behavior) = REQUIRED];\n  // The token URL to be used for this flow.\n  string token_url = 2 [(google.api.field_behavior) = REQUIRED];\n  // The URL to be used for obtaining refresh tokens.\n  string refresh_url = 3;\n  // The available scopes for the OAuth2 security scheme.\n  map&lt;string, string&gt; scopes = 4 [(google.api.field_behavior) = REQUIRED];\n}\n\n///////////// Request Messages ///////////\n// Represents a request for the `SendMessage` method.\nmessage SendMessageRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The message to send to the agent.\n  Message message = 1 [(google.api.field_behavior) = REQUIRED];\n  // Configuration for the send request.\n  SendMessageConfiguration configuration = 2;\n  // A flexible key-value map for passing additional context or parameters.\n  google.protobuf.Struct metadata = 3;\n}\n\n// Represents a request for the `GetTask` method.\nmessage GetTaskRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 3;\n  // The resource name of the task.\n  // Format: tasks/{task_id}\n  string name = 1 [(google.api.field_behavior) = REQUIRED];\n  // The maximum number of most recent messages from the task's history to retrieve. An\n  // unset value means the client does not impose any limit. A value of zero is\n  // a request to not include any messages. The server MUST NOT return more\n  // messages than the provided value, but MAY apply a lower limit.\n  optional int32 history_length = 2;\n}\n\n// Parameters for listing tasks with optional filtering criteria.\nmessage ListTasksRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 9;\n  // Filter tasks by context ID to get tasks from a specific conversation or session.\n  string context_id = 1;\n  // Filter tasks by their current status state.\n  TaskState status = 2;\n  // Maximum number of tasks to return. Must be between 1 and 100.\n  // Defaults to 50 if not specified.\n  optional int32 page_size = 3;\n  // Token for pagination. Use the next_page_token from a previous ListTasksResponse.\n  string page_token = 4;\n  // The maximum number of messages to include in each task's history.\n  optional int32 history_length = 5;\n  // Filter tasks which have a status updated after the provided timestamp in ISO 8601 format (e.g., \"2023-10-27T10:00:00Z\").\n  // Only tasks with a status timestamp time greater than or equal to this value will be returned.\n  google.protobuf.Timestamp status_timestamp_after = 6;\n  // Whether to include artifacts in the returned tasks.\n  // Defaults to false to reduce payload size.\n  optional bool include_artifacts = 7;\n}\n\n// Result object for tasks/list method containing an array of tasks and pagination information.\nmessage ListTasksResponse {\n  // Array of tasks matching the specified criteria.\n  repeated Task tasks = 1 [(google.api.field_behavior) = REQUIRED];\n  // Token for retrieving the next page. Empty string if no more results.\n  string next_page_token = 2 [(google.api.field_behavior) = REQUIRED];\n  // The size of page requested.\n  int32 page_size = 3 [(google.api.field_behavior) = REQUIRED];\n  // Total number of tasks available (before pagination).\n  int32 total_size = 4 [(google.api.field_behavior) = REQUIRED];\n}\n\n// Represents a request for the `CancelTask` method.\nmessage CancelTaskRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the task to cancel.\n  // Format: tasks/{task_id}\n  string name = 1;\n}\n\nmessage GetTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the config to retrieve.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1;\n}\n\n// Represents a request for the `DeleteTaskPushNotificationConfig` method.\nmessage DeleteTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the config to delete.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1;\n}\n\n// Represents a request for the `CreateTaskPushNotificationConfig` method.\nmessage CreateTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The parent task resource for this config.\n  // Format: tasks/{task_id}\n  string parent = 1 [(google.api.field_behavior) = REQUIRED];\n  // The ID for the new config.\n  string config_id = 2 [(google.api.field_behavior) = REQUIRED];\n  // The configuration to create.\n  TaskPushNotificationConfig config = 3 [(google.api.field_behavior) = REQUIRED];\n}\n\nmessage SubscribeToTaskRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the task to subscribe to.\n  // Format: tasks/{task_id}\n  string name = 1;\n}\n\nmessage ListTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The parent task resource.\n  // Format: tasks/{task_id}\n  string parent = 1;\n  // The maximum number of configurations to return.\n  int32 page_size = 2;\n\n  // A page token received from a previous ListTaskPushNotificationConfigRequest call.\n  string page_token = 3;\n}\n\nmessage GetExtendedAgentCardRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 1;\n}\n\n//////// Response Messages ///////////\nmessage SendMessageResponse {\n  oneof payload {\n    Task task = 1;\n    Message message = 2;\n  }\n}\n\n// A wrapper object used in streaming operations to encapsulate different types of response data.\nmessage StreamResponse {\n  oneof payload {\n    // A Task object containing the current state of the task.\n    Task task = 1;\n    // A Message object containing a message from the agent.\n    Message message = 2;\n    // An event indicating a task status update.\n    TaskStatusUpdateEvent status_update = 3;\n    // An event indicating a task artifact update.\n    TaskArtifactUpdateEvent artifact_update = 4;\n  }\n}\n\n// Represents a successful response for the `ListTaskPushNotificationConfig`\n// method.\nmessage ListTaskPushNotificationConfigResponse {\n  // The list of push notification configurations.\n  repeated TaskPushNotificationConfig configs = 1;\n  // A token, which can be sent as `page_token` to retrieve the next page.\n  // If this field is omitted, there are no subsequent pages.\n  string next_page_token = 2;\n}\n</code></pre> <p>JSON The A2A protocol JSON Schema definition (JSON Schema 2020-12 compliant). This schema is automatically generated from the protocol buffer definitions and bundled into a single file with all message definitions.</p> <p>Download</p> <p>You can download the schema file directly: <code>a2a.json</code></p> <p>Definition</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"A2A Protocol Schemas\",\n  \"description\": \"Non-normative JSON Schema bundle extracted from proto definitions.\",\n  \"version\": \"v1\",\n  \"definitions\": {\n    \"API Key Security Scheme\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines a security scheme using an API key.\",\n      \"properties\": {\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"An optional description for the security scheme.\",\n          \"type\": \"string\"\n        },\n        \"location\": {\n          \"default\": \"\",\n          \"description\": \"The location of the API key. Valid values are \\\"query\\\", \\\"header\\\", or \\\"cookie\\\".\",\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The name of the header, query, or cookie parameter to be used.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"API Key Security Scheme\",\n      \"type\": \"object\"\n    },\n    \"Agent Capabilities\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines optional capabilities supported by an agent.\",\n      \"patternProperties\": {\n        \"^(extended_agent_card)$\": {\n          \"description\": \"Indicates if the agent supports providing an extended agent card when authenticated.\",\n          \"type\": \"boolean\"\n        },\n        \"^(push_notifications)$\": {\n          \"description\": \"Indicates if the agent supports sending push notifications for asynchronous task updates.\",\n          \"type\": \"boolean\"\n        }\n      },\n      \"properties\": {\n        \"extendedAgentCard\": {\n          \"description\": \"Indicates if the agent supports providing an extended agent card when authenticated.\",\n          \"type\": \"boolean\"\n        },\n        \"extensions\": {\n          \"description\": \"A list of protocol extensions supported by the agent.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.AgentExtension.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"pushNotifications\": {\n          \"description\": \"Indicates if the agent supports sending push notifications for asynchronous task updates.\",\n          \"type\": \"boolean\"\n        },\n        \"streaming\": {\n          \"description\": \"Indicates if the agent supports streaming responses.\",\n          \"type\": \"boolean\"\n        }\n      },\n      \"title\": \"Agent Capabilities\",\n      \"type\": \"object\"\n    },\n    \"Agent Card\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"AgentCard is a self-describing manifest for an agent. It provides essential\\n metadata including the agent's identity, capabilities, skills, supported\\n communication methods, and security requirements.\\n Next ID: 20\",\n      \"patternProperties\": {\n        \"^(default_input_modes)$\": {\n          \"description\": \"The set of interaction modes that the agent supports across all skills.\\n This can be overridden per skill. Defined as media types.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"^(default_output_modes)$\": {\n          \"description\": \"The media types supported as outputs from this agent.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"^(documentation_url)$\": {\n          \"description\": \"A url to provide additional documentation about the agent.\",\n          \"type\": \"string\"\n        },\n        \"^(icon_url)$\": {\n          \"description\": \"An optional URL to an icon for the agent.\",\n          \"type\": \"string\"\n        },\n        \"^(protocol_versions)$\": {\n          \"description\": \"The versions of the A2A protocol this agent supports.\\n For stable versions (1.x+), list only the latest supported minor version per major version.\\n For legacy experimental versions (0.x), explicitly list each supported version.\\n Default: [\\\"1.0\\\"]\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"^(security_schemes)$\": {\n          \"additionalProperties\": {\n            \"$ref\": \"a2a.v1.SecurityScheme.jsonschema.json\"\n          },\n          \"description\": \"The security scheme details used for authenticating with this agent.\",\n          \"propertyNames\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        },\n        \"^(supported_interfaces)$\": {\n          \"description\": \"Ordered list of supported interfaces. First entry is preferred.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.AgentInterface.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"properties\": {\n        \"capabilities\": {\n          \"$ref\": \"a2a.v1.AgentCapabilities.jsonschema.json\",\n          \"description\": \"A2A Capability set supported by the agent.\"\n        },\n        \"defaultInputModes\": {\n          \"description\": \"The set of interaction modes that the agent supports across all skills.\\n This can be overridden per skill. Defined as media types.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"defaultOutputModes\": {\n          \"description\": \"The media types supported as outputs from this agent.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"A human-readable description of the agent, assisting users and other agents\\n in understanding its purpose.\\n Example: \\\"Agent that helps users with recipes and cooking.\\\"\",\n          \"type\": \"string\"\n        },\n        \"documentationUrl\": {\n          \"description\": \"A url to provide additional documentation about the agent.\",\n          \"type\": \"string\"\n        },\n        \"iconUrl\": {\n          \"description\": \"An optional URL to an icon for the agent.\",\n          \"type\": \"string\"\n        },\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"A human readable name for the agent.\\n Example: \\\"Recipe Agent\\\"\",\n          \"type\": \"string\"\n        },\n        \"protocolVersions\": {\n          \"description\": \"The versions of the A2A protocol this agent supports.\\n For stable versions (1.x+), list only the latest supported minor version per major version.\\n For legacy experimental versions (0.x), explicitly list each supported version.\\n Default: [\\\"1.0\\\"]\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"provider\": {\n          \"$ref\": \"a2a.v1.AgentProvider.jsonschema.json\",\n          \"description\": \"The service provider of the agent.\"\n        },\n        \"security\": {\n          \"description\": \"Security requirements for contacting the agent.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Security.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"securitySchemes\": {\n          \"additionalProperties\": {\n            \"$ref\": \"a2a.v1.SecurityScheme.jsonschema.json\"\n          },\n          \"description\": \"The security scheme details used for authenticating with this agent.\",\n          \"propertyNames\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        },\n        \"signatures\": {\n          \"description\": \"JSON Web Signatures computed for this AgentCard.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.AgentCardSignature.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"skills\": {\n          \"description\": \"Skills represent an ability of an agent. It is largely\\n a descriptive concept but represents a more focused set of behaviors that the\\n agent is likely to succeed at.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.AgentSkill.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"supportedInterfaces\": {\n          \"description\": \"Ordered list of supported interfaces. First entry is preferred.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.AgentInterface.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"version\": {\n          \"default\": \"\",\n          \"description\": \"The version of the agent.\\n Example: \\\"1.0.0\\\"\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Agent Card\",\n      \"type\": \"object\"\n    },\n    \"Agent Card Signature\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"AgentCardSignature represents a JWS signature of an AgentCard.\\n This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).\",\n      \"properties\": {\n        \"header\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"The unprotected JWS header values.\"\n        },\n        \"protected\": {\n          \"default\": \"\",\n          \"description\": \"The protected JWS header for the signature. This is always a\\n base64url-encoded JSON object. Required.\",\n          \"type\": \"string\"\n        },\n        \"signature\": {\n          \"default\": \"\",\n          \"description\": \"The computed signature, base64url-encoded. Required.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Agent Card Signature\",\n      \"type\": \"object\"\n    },\n    \"Agent Extension\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"A declaration of a protocol extension supported by an Agent.\",\n      \"properties\": {\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"A human-readable description of how this agent uses the extension.\",\n          \"type\": \"string\"\n        },\n        \"params\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"Optional, extension-specific configuration parameters.\"\n        },\n        \"required\": {\n          \"default\": false,\n          \"description\": \"If true, the client must understand and comply with the extension's requirements.\",\n          \"type\": \"boolean\"\n        },\n        \"uri\": {\n          \"default\": \"\",\n          \"description\": \"The unique URI identifying the extension.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Agent Extension\",\n      \"type\": \"object\"\n    },\n    \"Agent Interface\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Declares a combination of a target URL and a transport protocol for interacting with the agent.\\n This allows agents to expose the same functionality over multiple protocol binding mechanisms.\",\n      \"patternProperties\": {\n        \"^(protocol_binding)$\": {\n          \"default\": \"\",\n          \"description\": \"The protocol binding supported at this URL. This is an open form string, to be\\n easily extended for other protocol bindings. The core ones officially\\n supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"protocolBinding\": {\n          \"default\": \"\",\n          \"description\": \"The protocol binding supported at this URL. This is an open form string, to be\\n easily extended for other protocol bindings. The core ones officially\\n supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Tenant to be set in the request when calling the agent.\",\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"default\": \"\",\n          \"description\": \"The URL where this interface is available. Must be a valid absolute HTTPS URL in production.\\n Example: \\\"https://api.example.com/a2a/v1\\\", \\\"https://grpc.example.com/a2a\\\"\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Agent Interface\",\n      \"type\": \"object\"\n    },\n    \"Agent Provider\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents the service provider of an agent.\",\n      \"properties\": {\n        \"organization\": {\n          \"default\": \"\",\n          \"description\": \"The name of the agent provider's organization.\\n Example: \\\"Google\\\"\",\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"default\": \"\",\n          \"description\": \"A URL for the agent provider's website or relevant documentation.\\n Example: \\\"https://ai.google.dev\\\"\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Agent Provider\",\n      \"type\": \"object\"\n    },\n    \"Agent Skill\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents a distinct capability or function that an agent can perform.\",\n      \"patternProperties\": {\n        \"^(input_modes)$\": {\n          \"description\": \"The set of supported input media types for this skill, overriding the agent's defaults.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"^(output_modes)$\": {\n          \"description\": \"The set of supported output media types for this skill, overriding the agent's defaults.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"properties\": {\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"A detailed description of the skill.\",\n          \"type\": \"string\"\n        },\n        \"examples\": {\n          \"description\": \"Example prompts or scenarios that this skill can handle.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"id\": {\n          \"default\": \"\",\n          \"description\": \"A unique identifier for the agent's skill.\",\n          \"type\": \"string\"\n        },\n        \"inputModes\": {\n          \"description\": \"The set of supported input media types for this skill, overriding the agent's defaults.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"A human-readable name for the skill.\",\n          \"type\": \"string\"\n        },\n        \"outputModes\": {\n          \"description\": \"The set of supported output media types for this skill, overriding the agent's defaults.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"security\": {\n          \"description\": \"Security schemes necessary for this skill.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Security.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"tags\": {\n          \"description\": \"A set of keywords describing the skill's capabilities.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"title\": \"Agent Skill\",\n      \"type\": \"object\"\n    },\n    \"Artifact\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Artifacts represent task outputs.\",\n      \"patternProperties\": {\n        \"^(artifact_id)$\": {\n          \"default\": \"\",\n          \"description\": \"Unique identifier (e.g. UUID) for the artifact. It must be at least unique\\n within a task.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"artifactId\": {\n          \"default\": \"\",\n          \"description\": \"Unique identifier (e.g. UUID) for the artifact. It must be at least unique\\n within a task.\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"A human readable description of the artifact, optional.\",\n          \"type\": \"string\"\n        },\n        \"extensions\": {\n          \"description\": \"The URIs of extensions that are present or contributed to this Artifact.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"Optional metadata included with the artifact.\"\n        },\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"A human readable name for the artifact.\",\n          \"type\": \"string\"\n        },\n        \"parts\": {\n          \"description\": \"The content of the artifact. Must contain at least one part.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Part.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"title\": \"Artifact\",\n      \"type\": \"object\"\n    },\n    \"Authentication Info\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines authentication details, used for push notifications.\",\n      \"properties\": {\n        \"credentials\": {\n          \"default\": \"\",\n          \"description\": \"Push Notification credentials. Format depends on the scheme (e.g., token for Bearer).\",\n          \"type\": \"string\"\n        },\n        \"scheme\": {\n          \"default\": \"\",\n          \"description\": \"HTTP Authentication Scheme from the [IANA registry](https://www.iana.org/assignments/http-authschemes/).\\n Common values: `Bearer`, `Basic`, `Digest`. Scheme names are case-insensitive per [RFC 9110 Section 11.1](https://www.rfc-editor.org/rfc/rfc9110#section-11.1).\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Authentication Info\",\n      \"type\": \"object\"\n    },\n    \"Authorization CodeO Auth Flow\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines configuration details for the OAuth 2.0 Authorization Code flow.\",\n      \"patternProperties\": {\n        \"^(authorization_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The authorization URL to be used for this flow.\",\n          \"type\": \"string\"\n        },\n        \"^(pkce_required)$\": {\n          \"default\": false,\n          \"description\": \"Indicates if PKCE (RFC 7636) is required for this flow.\\n PKCE should always be used for public clients and is recommended for all clients.\",\n          \"type\": \"boolean\"\n        },\n        \"^(refresh_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The URL to be used for obtaining refresh tokens.\",\n          \"type\": \"string\"\n        },\n        \"^(token_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The token URL to be used for this flow.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"authorizationUrl\": {\n          \"default\": \"\",\n          \"description\": \"The authorization URL to be used for this flow.\",\n          \"type\": \"string\"\n        },\n        \"pkceRequired\": {\n          \"default\": false,\n          \"description\": \"Indicates if PKCE (RFC 7636) is required for this flow.\\n PKCE should always be used for public clients and is recommended for all clients.\",\n          \"type\": \"boolean\"\n        },\n        \"refreshUrl\": {\n          \"default\": \"\",\n          \"description\": \"The URL to be used for obtaining refresh tokens.\",\n          \"type\": \"string\"\n        },\n        \"scopes\": {\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"description\": \"The available scopes for the OAuth2 security scheme.\",\n          \"propertyNames\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        },\n        \"tokenUrl\": {\n          \"default\": \"\",\n          \"description\": \"The token URL to be used for this flow.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Authorization CodeO Auth Flow\",\n      \"type\": \"object\"\n    },\n    \"Cancel Task Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents a request for the `CancelTask` method.\",\n      \"properties\": {\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The resource name of the task to cancel.\\n Format: tasks/{task_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Cancel Task Request\",\n      \"type\": \"object\"\n    },\n    \"Client CredentialsO Auth Flow\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines configuration details for the OAuth 2.0 Client Credentials flow.\",\n      \"patternProperties\": {\n        \"^(refresh_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The URL to be used for obtaining refresh tokens.\",\n          \"type\": \"string\"\n        },\n        \"^(token_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The token URL to be used for this flow.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"refreshUrl\": {\n          \"default\": \"\",\n          \"description\": \"The URL to be used for obtaining refresh tokens.\",\n          \"type\": \"string\"\n        },\n        \"scopes\": {\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"description\": \"The available scopes for the OAuth2 security scheme.\",\n          \"propertyNames\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        },\n        \"tokenUrl\": {\n          \"default\": \"\",\n          \"description\": \"The token URL to be used for this flow.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Client CredentialsO Auth Flow\",\n      \"type\": \"object\"\n    },\n    \"Create Task Push Notification Config Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents a request for the `CreateTaskPushNotificationConfig` method.\",\n      \"patternProperties\": {\n        \"^(config_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The ID for the new config.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"config\": {\n          \"$ref\": \"a2a.v1.TaskPushNotificationConfig.jsonschema.json\",\n          \"description\": \"The configuration to create.\"\n        },\n        \"configId\": {\n          \"default\": \"\",\n          \"description\": \"The ID for the new config.\",\n          \"type\": \"string\"\n        },\n        \"parent\": {\n          \"default\": \"\",\n          \"description\": \"The parent task resource for this config.\\n Format: tasks/{task_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Create Task Push Notification Config Request\",\n      \"type\": \"object\"\n    },\n    \"Delete Task Push Notification Config Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents a request for the `DeleteTaskPushNotificationConfig` method.\",\n      \"properties\": {\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The resource name of the config to delete.\\n Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Delete Task Push Notification Config Request\",\n      \"type\": \"object\"\n    },\n    \"Device CodeO Auth Flow\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines configuration details for the OAuth 2.0 Device Code flow (RFC 8628).\\n This flow is designed for input-constrained devices such as IoT devices,\\n and CLI tools where the user authenticates on a separate device.\",\n      \"patternProperties\": {\n        \"^(device_authorization_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The device authorization endpoint URL.\",\n          \"type\": \"string\"\n        },\n        \"^(refresh_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The URL to be used for obtaining refresh tokens.\",\n          \"type\": \"string\"\n        },\n        \"^(token_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The token URL to be used for this flow.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"deviceAuthorizationUrl\": {\n          \"default\": \"\",\n          \"description\": \"The device authorization endpoint URL.\",\n          \"type\": \"string\"\n        },\n        \"refreshUrl\": {\n          \"default\": \"\",\n          \"description\": \"The URL to be used for obtaining refresh tokens.\",\n          \"type\": \"string\"\n        },\n        \"scopes\": {\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"description\": \"The available scopes for the OAuth2 security scheme.\",\n          \"propertyNames\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        },\n        \"tokenUrl\": {\n          \"default\": \"\",\n          \"description\": \"The token URL to be used for this flow.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Device CodeO Auth Flow\",\n      \"type\": \"object\"\n    },\n    \"Get Extended Agent Card Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Get Extended Agent Card Request\",\n      \"type\": \"object\"\n    },\n    \"Get Task Push Notification Config Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The resource name of the config to retrieve.\\n Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Get Task Push Notification Config Request\",\n      \"type\": \"object\"\n    },\n    \"Get Task Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents a request for the `GetTask` method.\",\n      \"patternProperties\": {\n        \"^(history_length)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"The maximum number of most recent messages from the task's history to retrieve. An\\n unset value means the client does not impose any limit. A value of zero is\\n a request to not include any messages. The server MUST NOT return more\\n messages than the provided value, but MAY apply a lower limit.\"\n        }\n      },\n      \"properties\": {\n        \"historyLength\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"The maximum number of most recent messages from the task's history to retrieve. An\\n unset value means the client does not impose any limit. A value of zero is\\n a request to not include any messages. The server MUST NOT return more\\n messages than the provided value, but MAY apply a lower limit.\"\n        },\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The resource name of the task.\\n Format: tasks/{task_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Get Task Request\",\n      \"type\": \"object\"\n    },\n    \"HTTP Auth Security Scheme\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines a security scheme using HTTP authentication.\",\n      \"patternProperties\": {\n        \"^(bearer_format)$\": {\n          \"default\": \"\",\n          \"description\": \"A hint to the client to identify how the bearer token is formatted (e.g., \\\"JWT\\\").\\n This is primarily for documentation purposes.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"bearerFormat\": {\n          \"default\": \"\",\n          \"description\": \"A hint to the client to identify how the bearer token is formatted (e.g., \\\"JWT\\\").\\n This is primarily for documentation purposes.\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"An optional description for the security scheme.\",\n          \"type\": \"string\"\n        },\n        \"scheme\": {\n          \"default\": \"\",\n          \"description\": \"The name of the HTTP Authentication scheme to be used in the Authorization header,\\n as defined in RFC7235 (e.g., \\\"Bearer\\\").\\n This value should be registered in the IANA Authentication Scheme registry.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"HTTP Auth Security Scheme\",\n      \"type\": \"object\"\n    },\n    \"List Task Push Notification Config Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"patternProperties\": {\n        \"^(page_size)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"The maximum number of configurations to return.\"\n        },\n        \"^(page_token)$\": {\n          \"default\": \"\",\n          \"description\": \"A page token received from a previous ListTaskPushNotificationConfigRequest call.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"pageSize\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"The maximum number of configurations to return.\"\n        },\n        \"pageToken\": {\n          \"default\": \"\",\n          \"description\": \"A page token received from a previous ListTaskPushNotificationConfigRequest call.\",\n          \"type\": \"string\"\n        },\n        \"parent\": {\n          \"default\": \"\",\n          \"description\": \"The parent task resource.\\n Format: tasks/{task_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"List Task Push Notification Config Request\",\n      \"type\": \"object\"\n    },\n    \"List Task Push Notification Config Response\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Represents a successful response for the `ListTaskPushNotificationConfig`\\n method.\",\n      \"patternProperties\": {\n        \"^(next_page_token)$\": {\n          \"default\": \"\",\n          \"description\": \"A token, which can be sent as `page_token` to retrieve the next page.\\n If this field is omitted, there are no subsequent pages.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"configs\": {\n          \"description\": \"The list of push notification configurations.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.TaskPushNotificationConfig.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"nextPageToken\": {\n          \"default\": \"\",\n          \"description\": \"A token, which can be sent as `page_token` to retrieve the next page.\\n If this field is omitted, there are no subsequent pages.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"List Task Push Notification Config Response\",\n      \"type\": \"object\"\n    },\n    \"List Tasks Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Parameters for listing tasks with optional filtering criteria.\",\n      \"patternProperties\": {\n        \"^(context_id)$\": {\n          \"default\": \"\",\n          \"description\": \"Filter tasks by context ID to get tasks from a specific conversation or session.\",\n          \"type\": \"string\"\n        },\n        \"^(history_length)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"The maximum number of messages to include in each task's history.\"\n        },\n        \"^(include_artifacts)$\": {\n          \"description\": \"Whether to include artifacts in the returned tasks.\\n Defaults to false to reduce payload size.\",\n          \"type\": \"boolean\"\n        },\n        \"^(page_size)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"Maximum number of tasks to return. Must be between 1 and 100.\\n Defaults to 50 if not specified.\"\n        },\n        \"^(page_token)$\": {\n          \"default\": \"\",\n          \"description\": \"Token for pagination. Use the next_page_token from a previous ListTasksResponse.\",\n          \"type\": \"string\"\n        },\n        \"^(status_timestamp_after)$\": {\n          \"$ref\": \"google.protobuf.Timestamp.jsonschema.json\",\n          \"description\": \"Filter tasks which have a status updated after the provided timestamp in ISO 8601 format (e.g., \\\"2023-10-27T10:00:00Z\\\").\\n Only tasks with a status timestamp time greater than or equal to this value will be returned.\"\n        }\n      },\n      \"properties\": {\n        \"contextId\": {\n          \"default\": \"\",\n          \"description\": \"Filter tasks by context ID to get tasks from a specific conversation or session.\",\n          \"type\": \"string\"\n        },\n        \"historyLength\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"The maximum number of messages to include in each task's history.\"\n        },\n        \"includeArtifacts\": {\n          \"description\": \"Whether to include artifacts in the returned tasks.\\n Defaults to false to reduce payload size.\",\n          \"type\": \"boolean\"\n        },\n        \"pageSize\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"Maximum number of tasks to return. Must be between 1 and 100.\\n Defaults to 50 if not specified.\"\n        },\n        \"pageToken\": {\n          \"default\": \"\",\n          \"description\": \"Token for pagination. Use the next_page_token from a previous ListTasksResponse.\",\n          \"type\": \"string\"\n        },\n        \"status\": {\n          \"anyOf\": [\n            {\n              \"pattern\": \"^TASK_STATE_UNSPECIFIED$\",\n              \"type\": \"string\"\n            },\n            {\n              \"enum\": [\n                \"TASK_STATE_SUBMITTED\",\n                \"TASK_STATE_WORKING\",\n                \"TASK_STATE_COMPLETED\",\n                \"TASK_STATE_FAILED\",\n                \"TASK_STATE_CANCELED\",\n                \"TASK_STATE_INPUT_REQUIRED\",\n                \"TASK_STATE_REJECTED\",\n                \"TASK_STATE_AUTH_REQUIRED\"\n              ],\n              \"type\": \"string\"\n            },\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"Filter tasks by their current status state.\",\n          \"title\": \"Task State\"\n        },\n        \"statusTimestampAfter\": {\n          \"$ref\": \"google.protobuf.Timestamp.jsonschema.json\",\n          \"description\": \"Filter tasks which have a status updated after the provided timestamp in ISO 8601 format (e.g., \\\"2023-10-27T10:00:00Z\\\").\\n Only tasks with a status timestamp time greater than or equal to this value will be returned.\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"List Tasks Request\",\n      \"type\": \"object\"\n    },\n    \"List Tasks Response\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Result object for tasks/list method containing an array of tasks and pagination information.\",\n      \"patternProperties\": {\n        \"^(next_page_token)$\": {\n          \"default\": \"\",\n          \"description\": \"Token for retrieving the next page. Empty string if no more results.\",\n          \"type\": \"string\"\n        },\n        \"^(page_size)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"The size of page requested.\"\n        },\n        \"^(total_size)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"Total number of tasks available (before pagination).\"\n        }\n      },\n      \"properties\": {\n        \"nextPageToken\": {\n          \"default\": \"\",\n          \"description\": \"Token for retrieving the next page. Empty string if no more results.\",\n          \"type\": \"string\"\n        },\n        \"pageSize\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"The size of page requested.\"\n        },\n        \"tasks\": {\n          \"description\": \"Array of tasks matching the specified criteria.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Task.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"totalSize\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"Total number of tasks available (before pagination).\"\n        }\n      },\n      \"title\": \"List Tasks Response\",\n      \"type\": \"object\"\n    },\n    \"Message\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Message is one unit of communication between client and server. It can be\\n associated with a context and/or a task. For server messages, context_id must\\n be provided, and task_id only if a task was created. For client messages, both\\n fields are optional, with the caveat that if both are provided, they have to\\n match (the context_id has to be the one that is set on the task). If only\\n task_id is provided, the server will infer context_id from it.\",\n      \"patternProperties\": {\n        \"^(context_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The context id of the message. This is optional and if set, the message\\n will be associated with the given context.\",\n          \"type\": \"string\"\n        },\n        \"^(message_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The unique identifier (e.g. UUID) of the message. This is required and\\n created by the message creator.\",\n          \"type\": \"string\"\n        },\n        \"^(reference_task_ids)$\": {\n          \"description\": \"A list of task IDs that this message references for additional context.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"^(task_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The task id of the message. This is optional and if set, the message\\n will be associated with the given task.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"contextId\": {\n          \"default\": \"\",\n          \"description\": \"The context id of the message. This is optional and if set, the message\\n will be associated with the given context.\",\n          \"type\": \"string\"\n        },\n        \"extensions\": {\n          \"description\": \"The URIs of extensions that are present or contributed to this Message.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"messageId\": {\n          \"default\": \"\",\n          \"description\": \"The unique identifier (e.g. UUID) of the message. This is required and\\n created by the message creator.\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"Any optional metadata to provide along with the message.\"\n        },\n        \"parts\": {\n          \"description\": \"Parts is the container of the message content.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Part.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"referenceTaskIds\": {\n          \"description\": \"A list of task IDs that this message references for additional context.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"role\": {\n          \"anyOf\": [\n            {\n              \"pattern\": \"^ROLE_UNSPECIFIED$\",\n              \"type\": \"string\"\n            },\n            {\n              \"enum\": [\n                \"ROLE_USER\",\n                \"ROLE_AGENT\"\n              ],\n              \"type\": \"string\"\n            },\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"Identifies the sender of the message.\",\n          \"title\": \"Role\"\n        },\n        \"taskId\": {\n          \"default\": \"\",\n          \"description\": \"The task id of the message. This is optional and if set, the message\\n will be associated with the given task.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Message\",\n      \"type\": \"object\"\n    },\n    \"Mutual Tls Security Scheme\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines a security scheme using mTLS authentication.\",\n      \"properties\": {\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"An optional description for the security scheme.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Mutual Tls Security Scheme\",\n      \"type\": \"object\"\n    },\n    \"O Auth2 Security Scheme\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines a security scheme using OAuth 2.0.\",\n      \"patternProperties\": {\n        \"^(oauth2_metadata_url)$\": {\n          \"default\": \"\",\n          \"description\": \"URL to the oauth2 authorization server metadata\\n RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"An optional description for the security scheme.\",\n          \"type\": \"string\"\n        },\n        \"flows\": {\n          \"$ref\": \"a2a.v1.OAuthFlows.jsonschema.json\",\n          \"description\": \"An object containing configuration information for the supported OAuth 2.0 flows.\"\n        },\n        \"oauth2MetadataUrl\": {\n          \"default\": \"\",\n          \"description\": \"URL to the oauth2 authorization server metadata\\n RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"O Auth2 Security Scheme\",\n      \"type\": \"object\"\n    },\n    \"O Auth Flows\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines the configuration for the supported OAuth 2.0 flows.\",\n      \"patternProperties\": {\n        \"^(authorization_code)$\": {\n          \"$ref\": \"a2a.v1.AuthorizationCodeOAuthFlow.jsonschema.json\",\n          \"description\": \"Configuration for the OAuth Authorization Code flow.\"\n        },\n        \"^(client_credentials)$\": {\n          \"$ref\": \"a2a.v1.ClientCredentialsOAuthFlow.jsonschema.json\",\n          \"description\": \"Configuration for the OAuth Client Credentials flow.\"\n        },\n        \"^(device_code)$\": {\n          \"$ref\": \"a2a.v1.DeviceCodeOAuthFlow.jsonschema.json\",\n          \"description\": \"Configuration for the OAuth Device Code flow.\"\n        }\n      },\n      \"properties\": {\n        \"authorizationCode\": {\n          \"$ref\": \"a2a.v1.AuthorizationCodeOAuthFlow.jsonschema.json\",\n          \"description\": \"Configuration for the OAuth Authorization Code flow.\"\n        },\n        \"clientCredentials\": {\n          \"$ref\": \"a2a.v1.ClientCredentialsOAuthFlow.jsonschema.json\",\n          \"description\": \"Configuration for the OAuth Client Credentials flow.\"\n        },\n        \"deviceCode\": {\n          \"$ref\": \"a2a.v1.DeviceCodeOAuthFlow.jsonschema.json\",\n          \"description\": \"Configuration for the OAuth Device Code flow.\"\n        }\n      },\n      \"title\": \"O Auth Flows\",\n      \"type\": \"object\"\n    },\n    \"Open Id Connect Security Scheme\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines a security scheme using OpenID Connect.\",\n      \"patternProperties\": {\n        \"^(open_id_connect_url)$\": {\n          \"default\": \"\",\n          \"description\": \"The OpenID Connect Discovery URL for the OIDC provider's metadata.\\n See: https://openid.net/specs/openid-connect-discovery-1_0.html\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"description\": {\n          \"default\": \"\",\n          \"description\": \"An optional description for the security scheme.\",\n          \"type\": \"string\"\n        },\n        \"openIdConnectUrl\": {\n          \"default\": \"\",\n          \"description\": \"The OpenID Connect Discovery URL for the OIDC provider's metadata.\\n See: https://openid.net/specs/openid-connect-discovery-1_0.html\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Open Id Connect Security Scheme\",\n      \"type\": \"object\"\n    },\n    \"Part\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Part represents a container for a section of communication content.\\n Parts can be purely textual, some sort of file (image, video, etc) or\\n a structured data blob (i.e. JSON).\",\n      \"patternProperties\": {\n        \"^(media_type)$\": {\n          \"default\": \"\",\n          \"description\": \"The media type (MIME type) of the part content (e.g., \\\"text/plain\\\", \\\"application/json\\\", \\\"image/png\\\").\\n This field is available for all part types.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"data\": {\n          \"$ref\": \"google.protobuf.Value.jsonschema.json\",\n          \"description\": \"Arbitrary structured data as a JSON value (object, array, string, number, boolean, or null).\"\n        },\n        \"filename\": {\n          \"default\": \"\",\n          \"description\": \"An optional name for the file (e.g., \\\"document.pdf\\\").\",\n          \"type\": \"string\"\n        },\n        \"mediaType\": {\n          \"default\": \"\",\n          \"description\": \"The media type (MIME type) of the part content (e.g., \\\"text/plain\\\", \\\"application/json\\\", \\\"image/png\\\").\\n This field is available for all part types.\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"Optional metadata associated with this part.\"\n        },\n        \"raw\": {\n          \"description\": \"The raw byte content of a file. In JSON serialization, this is encoded as a base64 string.\",\n          \"pattern\": \"^[A-Za-z0-9+/]*={0,2}$\",\n          \"type\": \"string\"\n        },\n        \"text\": {\n          \"description\": \"The string content of the text part.\",\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"description\": \"A URL pointing to the file's content.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Part\",\n      \"type\": \"object\"\n    },\n    \"Push Notification Config\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Configuration for setting up push notifications for task updates.\",\n      \"properties\": {\n        \"authentication\": {\n          \"$ref\": \"a2a.v1.AuthenticationInfo.jsonschema.json\",\n          \"description\": \"Authentication information required to send the notification\"\n        },\n        \"id\": {\n          \"default\": \"\",\n          \"description\": \"A unique identifier (e.g. UUID) for this push notification.\",\n          \"type\": \"string\"\n        },\n        \"token\": {\n          \"default\": \"\",\n          \"description\": \"Token unique for this task/session\",\n          \"type\": \"string\"\n        },\n        \"url\": {\n          \"default\": \"\",\n          \"description\": \"Url to send the notification too\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Push Notification Config\",\n      \"type\": \"object\"\n    },\n    \"Security\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"schemes\": {\n          \"additionalProperties\": {\n            \"$ref\": \"a2a.v1.StringList.jsonschema.json\"\n          },\n          \"propertyNames\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        }\n      },\n      \"title\": \"Security\",\n      \"type\": \"object\"\n    },\n    \"Security Scheme\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Defines a security scheme that can be used to secure an agent's endpoints.\\n This is a discriminated union type based on the OpenAPI 3.2 Security Scheme Object.\\n See: https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object\",\n      \"patternProperties\": {\n        \"^(api_key_security_scheme)$\": {\n          \"$ref\": \"a2a.v1.APIKeySecurityScheme.jsonschema.json\",\n          \"description\": \"API key-based authentication.\"\n        },\n        \"^(http_auth_security_scheme)$\": {\n          \"$ref\": \"a2a.v1.HTTPAuthSecurityScheme.jsonschema.json\",\n          \"description\": \"HTTP authentication (Basic, Bearer, etc.).\"\n        },\n        \"^(mtls_security_scheme)$\": {\n          \"$ref\": \"a2a.v1.MutualTlsSecurityScheme.jsonschema.json\",\n          \"description\": \"Mutual TLS authentication.\"\n        },\n        \"^(oauth2_security_scheme)$\": {\n          \"$ref\": \"a2a.v1.OAuth2SecurityScheme.jsonschema.json\",\n          \"description\": \"OAuth 2.0 authentication.\"\n        },\n        \"^(open_id_connect_security_scheme)$\": {\n          \"$ref\": \"a2a.v1.OpenIdConnectSecurityScheme.jsonschema.json\",\n          \"description\": \"OpenID Connect authentication.\"\n        }\n      },\n      \"properties\": {\n        \"apiKeySecurityScheme\": {\n          \"$ref\": \"a2a.v1.APIKeySecurityScheme.jsonschema.json\",\n          \"description\": \"API key-based authentication.\"\n        },\n        \"httpAuthSecurityScheme\": {\n          \"$ref\": \"a2a.v1.HTTPAuthSecurityScheme.jsonschema.json\",\n          \"description\": \"HTTP authentication (Basic, Bearer, etc.).\"\n        },\n        \"mtlsSecurityScheme\": {\n          \"$ref\": \"a2a.v1.MutualTlsSecurityScheme.jsonschema.json\",\n          \"description\": \"Mutual TLS authentication.\"\n        },\n        \"oauth2SecurityScheme\": {\n          \"$ref\": \"a2a.v1.OAuth2SecurityScheme.jsonschema.json\",\n          \"description\": \"OAuth 2.0 authentication.\"\n        },\n        \"openIdConnectSecurityScheme\": {\n          \"$ref\": \"a2a.v1.OpenIdConnectSecurityScheme.jsonschema.json\",\n          \"description\": \"OpenID Connect authentication.\"\n        }\n      },\n      \"title\": \"Security Scheme\",\n      \"type\": \"object\"\n    },\n    \"Send Message Configuration\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Configuration of a send message request.\",\n      \"patternProperties\": {\n        \"^(accepted_output_modes)$\": {\n          \"description\": \"A list of media types the client is prepared to accept for response parts. Agents SHOULD use this to tailor their output.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"^(history_length)$\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"The maximum number of most recent messages from the task's history to retrieve in\\n the response. An unset value means the client does not impose any limit. A\\n value of zero is a request to not include any messages. The server MUST NOT\\n return more messages than the provided value, but MAY apply a lower limit.\"\n        },\n        \"^(push_notification_config)$\": {\n          \"$ref\": \"a2a.v1.PushNotificationConfig.jsonschema.json\",\n          \"description\": \"Configuration for the agent to send push notifications for task updates.\"\n        }\n      },\n      \"properties\": {\n        \"acceptedOutputModes\": {\n          \"description\": \"A list of media types the client is prepared to accept for response parts. Agents SHOULD use this to tailor their output.\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"blocking\": {\n          \"default\": false,\n          \"description\": \"If true, the operation waits until the task reaches a terminal or interrupted state before returning. Default is false.\",\n          \"type\": \"boolean\"\n        },\n        \"historyLength\": {\n          \"anyOf\": [\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            },\n            {\n              \"pattern\": \"^-?[0-9]+$\",\n              \"type\": \"string\"\n            }\n          ],\n          \"description\": \"The maximum number of most recent messages from the task's history to retrieve in\\n the response. An unset value means the client does not impose any limit. A\\n value of zero is a request to not include any messages. The server MUST NOT\\n return more messages than the provided value, but MAY apply a lower limit.\"\n        },\n        \"pushNotificationConfig\": {\n          \"$ref\": \"a2a.v1.PushNotificationConfig.jsonschema.json\",\n          \"description\": \"Configuration for the agent to send push notifications for task updates.\"\n        }\n      },\n      \"title\": \"Send Message Configuration\",\n      \"type\": \"object\"\n    },\n    \"Send Message Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"/////////// Request Messages ///////////\\n Represents a request for the `SendMessage` method.\",\n      \"properties\": {\n        \"configuration\": {\n          \"$ref\": \"a2a.v1.SendMessageConfiguration.jsonschema.json\",\n          \"description\": \"Configuration for the send request.\"\n        },\n        \"message\": {\n          \"$ref\": \"a2a.v1.Message.jsonschema.json\",\n          \"description\": \"The message to send to the agent.\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"A flexible key-value map for passing additional context or parameters.\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Send Message Request\",\n      \"type\": \"object\"\n    },\n    \"Send Message Response\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"////// Response Messages ///////////\",\n      \"properties\": {\n        \"message\": {\n          \"$ref\": \"a2a.v1.Message.jsonschema.json\"\n        },\n        \"task\": {\n          \"$ref\": \"a2a.v1.Task.jsonschema.json\"\n        }\n      },\n      \"title\": \"Send Message Response\",\n      \"type\": \"object\"\n    },\n    \"Stream Response\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"A wrapper object used in streaming operations to encapsulate different types of response data.\",\n      \"patternProperties\": {\n        \"^(artifact_update)$\": {\n          \"$ref\": \"a2a.v1.TaskArtifactUpdateEvent.jsonschema.json\",\n          \"description\": \"An event indicating a task artifact update.\"\n        },\n        \"^(status_update)$\": {\n          \"$ref\": \"a2a.v1.TaskStatusUpdateEvent.jsonschema.json\",\n          \"description\": \"An event indicating a task status update.\"\n        }\n      },\n      \"properties\": {\n        \"artifactUpdate\": {\n          \"$ref\": \"a2a.v1.TaskArtifactUpdateEvent.jsonschema.json\",\n          \"description\": \"An event indicating a task artifact update.\"\n        },\n        \"message\": {\n          \"$ref\": \"a2a.v1.Message.jsonschema.json\",\n          \"description\": \"A Message object containing a message from the agent.\"\n        },\n        \"statusUpdate\": {\n          \"$ref\": \"a2a.v1.TaskStatusUpdateEvent.jsonschema.json\",\n          \"description\": \"An event indicating a task status update.\"\n        },\n        \"task\": {\n          \"$ref\": \"a2a.v1.Task.jsonschema.json\",\n          \"description\": \"A Task object containing the current state of the task.\"\n        }\n      },\n      \"title\": \"Stream Response\",\n      \"type\": \"object\"\n    },\n    \"String List\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"list\": {\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"title\": \"String List\",\n      \"type\": \"object\"\n    },\n    \"Subscribe To Task Request\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The resource name of the task to subscribe to.\\n Format: tasks/{task_id}\",\n          \"type\": \"string\"\n        },\n        \"tenant\": {\n          \"default\": \"\",\n          \"description\": \"Optional tenant, provided as a path parameter.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Subscribe To Task Request\",\n      \"type\": \"object\"\n    },\n    \"Task\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"Task is the core unit of action for A2A. It has a current status\\n and when results are created for the task they are stored in the\\n artifact. If there are multiple turns for a task, these are stored in\\n history.\",\n      \"patternProperties\": {\n        \"^(context_id)$\": {\n          \"default\": \"\",\n          \"description\": \"Unique identifier (e.g. UUID) for the contextual collection of interactions\\n (tasks and messages). Created by the A2A server.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"artifacts\": {\n          \"description\": \"A set of output artifacts for a Task.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Artifact.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"contextId\": {\n          \"default\": \"\",\n          \"description\": \"Unique identifier (e.g. UUID) for the contextual collection of interactions\\n (tasks and messages). Created by the A2A server.\",\n          \"type\": \"string\"\n        },\n        \"history\": {\n          \"description\": \"The history of interactions from a task.\",\n          \"items\": {\n            \"$ref\": \"a2a.v1.Message.jsonschema.json\"\n          },\n          \"type\": \"array\"\n        },\n        \"id\": {\n          \"default\": \"\",\n          \"description\": \"Unique identifier (e.g. UUID) for the task, generated by the server for a\\n new task.\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"A key/value object to store custom metadata about a task.\"\n        },\n        \"status\": {\n          \"$ref\": \"a2a.v1.TaskStatus.jsonschema.json\",\n          \"description\": \"The current status of a Task, including state and a message.\"\n        }\n      },\n      \"title\": \"Task\",\n      \"type\": \"object\"\n    },\n    \"Task Artifact Update Event\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"TaskArtifactUpdateEvent represents a task delta where an artifact has\\n been generated.\",\n      \"patternProperties\": {\n        \"^(context_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The id of the context that this task belongs to.\",\n          \"type\": \"string\"\n        },\n        \"^(last_chunk)$\": {\n          \"default\": false,\n          \"description\": \"If true, this is the final chunk of the artifact.\",\n          \"type\": \"boolean\"\n        },\n        \"^(task_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The id of the task for this artifact.\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"append\": {\n          \"default\": false,\n          \"description\": \"If true, the content of this artifact should be appended to a previously\\n sent artifact with the same ID.\",\n          \"type\": \"boolean\"\n        },\n        \"artifact\": {\n          \"$ref\": \"a2a.v1.Artifact.jsonschema.json\",\n          \"description\": \"The artifact that was generated or updated.\"\n        },\n        \"contextId\": {\n          \"default\": \"\",\n          \"description\": \"The id of the context that this task belongs to.\",\n          \"type\": \"string\"\n        },\n        \"lastChunk\": {\n          \"default\": false,\n          \"description\": \"If true, this is the final chunk of the artifact.\",\n          \"type\": \"boolean\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"Optional metadata associated with the artifact update.\"\n        },\n        \"taskId\": {\n          \"default\": \"\",\n          \"description\": \"The id of the task for this artifact.\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Task Artifact Update Event\",\n      \"type\": \"object\"\n    },\n    \"Task Push Notification Config\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"A container associating a push notification configuration with a specific\\n task.\",\n      \"patternProperties\": {\n        \"^(push_notification_config)$\": {\n          \"$ref\": \"a2a.v1.PushNotificationConfig.jsonschema.json\",\n          \"description\": \"The push notification configuration details.\"\n        }\n      },\n      \"properties\": {\n        \"name\": {\n          \"default\": \"\",\n          \"description\": \"The resource name of the config.\\n Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\",\n          \"type\": \"string\"\n        },\n        \"pushNotificationConfig\": {\n          \"$ref\": \"a2a.v1.PushNotificationConfig.jsonschema.json\",\n          \"description\": \"The push notification configuration details.\"\n        }\n      },\n      \"title\": \"Task Push Notification Config\",\n      \"type\": \"object\"\n    },\n    \"Task Status\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"A container for the status of a task\",\n      \"properties\": {\n        \"message\": {\n          \"$ref\": \"a2a.v1.Message.jsonschema.json\",\n          \"description\": \"A message associated with the status.\"\n        },\n        \"state\": {\n          \"anyOf\": [\n            {\n              \"pattern\": \"^TASK_STATE_UNSPECIFIED$\",\n              \"type\": \"string\"\n            },\n            {\n              \"enum\": [\n                \"TASK_STATE_SUBMITTED\",\n                \"TASK_STATE_WORKING\",\n                \"TASK_STATE_COMPLETED\",\n                \"TASK_STATE_FAILED\",\n                \"TASK_STATE_CANCELED\",\n                \"TASK_STATE_INPUT_REQUIRED\",\n                \"TASK_STATE_REJECTED\",\n                \"TASK_STATE_AUTH_REQUIRED\"\n              ],\n              \"type\": \"string\"\n            },\n            {\n              \"maximum\": 2147483647,\n              \"minimum\": -2147483648,\n              \"type\": \"integer\"\n            }\n          ],\n          \"default\": 0,\n          \"description\": \"The current state of this task.\",\n          \"title\": \"Task State\"\n        },\n        \"timestamp\": {\n          \"$ref\": \"google.protobuf.Timestamp.jsonschema.json\",\n          \"description\": \"ISO 8601 Timestamp when the status was recorded.\\n Example: \\\"2023-10-27T10:00:00Z\\\"\"\n        }\n      },\n      \"title\": \"Task Status\",\n      \"type\": \"object\"\n    },\n    \"Task Status Update Event\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"description\": \"An event sent by the agent to notify the client of a change in a task's\\n status.\",\n      \"patternProperties\": {\n        \"^(context_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The id of the context that the task belongs to\",\n          \"type\": \"string\"\n        },\n        \"^(task_id)$\": {\n          \"default\": \"\",\n          \"description\": \"The id of the task that is changed\",\n          \"type\": \"string\"\n        }\n      },\n      \"properties\": {\n        \"contextId\": {\n          \"default\": \"\",\n          \"description\": \"The id of the context that the task belongs to\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"$ref\": \"google.protobuf.Struct.jsonschema.json\",\n          \"description\": \"Optional metadata to associate with the task update.\"\n        },\n        \"status\": {\n          \"$ref\": \"a2a.v1.TaskStatus.jsonschema.json\",\n          \"description\": \"The new status of the task.\"\n        },\n        \"taskId\": {\n          \"default\": \"\",\n          \"description\": \"The id of the task that is changed\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Task Status Update Event\",\n      \"type\": \"object\"\n    },\n    \"Struct\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"title\": \"Struct\",\n      \"type\": \"object\"\n    },\n    \"Timestamp\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"format\": \"date-time\",\n      \"title\": \"Timestamp\",\n      \"type\": \"string\"\n    },\n    \"Value\": {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"title\": \"Value\"\n    }\n  }\n}\n</code></pre>"},{"location":"partners/","title":"Partners","text":"<p>Below is a list of partners (and a link to their A2A announcement or blog post, if available) who are part of the A2A community and are helping build, codify, and adopt A2A as the standard protocol for AI agents to communicate and collaborate effectively with each other and with users.</p> <ul> <li>A2A Net</li> <li>Accelirate Inc</li> <li>Accenture</li> <li>Activeloop</li> <li>Adobe</li> <li>AG2AI</li> <li>AI21 Labs</li> <li>AI71</li> <li>Aisera</li> <li>AliCloud</li> <li>Almawave.it</li> <li>AmikoNet</li> <li>ArcBlock</li> <li>Arize</li> <li>Articul8</li> <li>ask-ai.com</li> <li>Atlassian</li> <li>Auth0</li> <li>Autodesk</li> <li>AWS</li> <li>Beekeeper</li> <li>BCG</li> <li>Block Inc</li> <li>Bloomberg LP</li> <li>BLUEISH Inc</li> <li>BMC Software Inc</li> <li>Boomi</li> <li>Box</li> <li>Bridge2Things Automation Process GmbH</li> <li>Cafe 24</li> <li>C3 AI</li> <li>Capgemini</li> <li>Chronosphere</li> <li>Cisco</li> <li>Codimite PTE LTD</li> <li>Cognigy</li> <li>Cognizant</li> <li>Cohere</li> <li>Collibra</li> <li>Confluent</li> <li>Contextual</li> <li>Cotality (fka Corelogic)</li> <li>Crubyt</li> <li>Cyderes</li> <li>Datadog</li> <li>DataRobot</li> <li>DataStax</li> <li>Decagon.ai</li> <li>Deloitte</li> <li>Devnagri</li> <li>Deutsche Telekom</li> <li>Dexter Tech Labs</li> <li>Distyl.ai</li> <li>Elastic</li> <li>Ema.co</li> <li>EPAM</li> <li>Eviden (Atos Group)</li> <li>fractal.ai</li> <li>GenAI Nebula9.ai Solutions Pvt Ltd</li> <li>Glean</li> <li>Global Logic</li> <li>Gravitee</li> <li>GrowthLoop</li> <li>Guru</li> <li>Harness</li> <li>HCLTech</li> <li>Headwaters</li> <li>Hellotars</li> <li>Hexaware</li> <li>HUMAN</li> <li>IBM Research</li> <li>Incorta</li> <li>Infinitus</li> <li>InfoSys</li> <li>Intuit</li> <li>Iron Mountain</li> <li>JetBrains</li> <li>JFrog</li> <li>Kakao</li> <li>King's College London</li> <li>KPMG</li> <li>Kyndryl</li> <li>LabelBox</li> <li>LangChain</li> <li>LG CNS</li> <li>Livex.ai</li> <li>LlamaIndex</li> <li>LTIMindTtree</li> <li>Lumeris</li> <li>Lyzr.ai</li> <li>Magyar Telekom</li> <li>MasOrange</li> <li>Microsoft</li> <li>MindsDB</li> <li>McKinsey</li> <li>MongoDB</li> <li>Monite</li> <li>Neo4j</li> <li>New Relic</li> <li>Nisum</li> <li>Noorle Inc</li> <li>NTT DATA</li> <li>Optimizely Inc</li> <li>Oracle / NetSuite</li> <li>Palo Alto Networks</li> <li>PancakeAI</li> <li>ParkourSC</li> <li>Pendo</li> <li>PerfAI.ai</li> <li>Personal AI</li> <li>Poppulo</li> <li>Productive Edge</li> <li>Proofs</li> <li>Publicis Sapient</li> <li>PWC</li> <li>Quantiphi</li> <li>Radix</li> <li>RagaAI Inc</li> <li>Red Hat</li> <li>Reltio Inc</li> <li>S&amp;P</li> <li>Sage</li> <li>Salesforce</li> <li>SAP</li> <li>Sayone Technologies</li> <li>ServiceNow</li> <li>Siemens AG</li> <li>SoftBank Corp</li> <li>Solace</li> <li>Solo.io</li> <li>Stacklok, Inc</li> <li>Supertab</li> <li>Suzega</li> <li>TCS</li> <li>Tech Mahindra</li> <li>Telefonica</li> <li>Test Innovation Technology</li> <li>the artinet project</li> <li>Think41</li> <li>Thoughtworks</li> <li>Tredence</li> <li>Two Tall Totems Ltd. DBA TTT Studios</li> <li>Typeface</li> <li>UKG</li> <li>UiPath</li> <li>Upwork, Inc.</li> <li>Ushur, Inc.</li> <li>Valle AI</li> <li>Valtech</li> <li>Vervelo</li> <li>VoltAgent</li> <li>Weights &amp; Biases</li> <li>Wipro</li> <li>Workday</li> <li>Writer</li> <li>Zenity</li> <li>Zeotap</li> <li>Zocket Technologies , Inc.</li> <li>Zoom</li> <li>zyprova</li> </ul>"},{"location":"roadmap/","title":"A2A protocol roadmap","text":"<p>Last updated: Jul 16, 2025</p>"},{"location":"roadmap/#near-term-initiatives","title":"Near-term initiatives","text":"<ul> <li>Release <code>0.3</code> version of the protocol which we intend to keep supported and without breaking changes for a significant amount of time with backward compatibility of the SDKs starting at version <code>0.3</code>. As part of this release there are a few known breaking changes including:<ul> <li>Update the <code>/.well-known/agent.json</code> path for hosting Agent Cards to <code>/.well-known/agent-card.json</code> based on feedback from IANA.</li> <li>Refactor class fields to be more Pythonic and adopt <code>snake_case</code>. PR 199</li> </ul> </li> <li>Solidify the support for A2A extensions with SDK support (starting with the Python SDK) and publishing sample extensions.</li> <li>Introduce support for signed Agent Cards Discussion 199 to allow verifying the integrity of Agent Card content.</li> <li>Enhance the client side support in SDK (starting with Python) to expose ready-to-use A2A clients, streamlined auth handling and improved handling of tasks.</li> </ul> <p>To review recent protocol changes see Release Notes.</p>"},{"location":"roadmap/#longer-term-3-6-month-period-roadmap","title":"Longer term (3-6 month period) roadmap","text":""},{"location":"roadmap/#governance","title":"Governance","text":"<p>The protocol has been donated to the Linux Foundation. The TSC is working on implementing a governance structure that prioritizes community-led development with standardized processes for contributing to the specification, SDKs and tooling. As part of the effort there will be dedicated working groups created for specific areas of the protocol.</p>"},{"location":"roadmap/#agent-registry","title":"Agent Registry","text":"<p>Agent Registry enables the discovery of agents and is a critical component of a multi-agent system. There is an active and ongoing discussion in the community around the latest Discussion 741.</p>"},{"location":"roadmap/#validation","title":"Validation","text":"<p>As the A2A ecosystem matures, it becomes critical for the A2A community to have tools to validate their agents. The community has launched two efforts to help with validation which the group will continue to enhance in the coming months. Learn more about A2A Inspector and the A2A Protocol Technology Compatibility Kit (TCK).</p>"},{"location":"roadmap/#sdks","title":"SDKs","text":"<p>A2A Project currently hosts SDKs in five languages (Python, Go, JS, Java, .NET).</p>"},{"location":"roadmap/#community-best-practices","title":"Community best practices","text":"<p>As companies and individuals deploy A2A systems at an increasing pace, we are looking to accelerate the learning of the community by collecting and sharing the best practices and success stories that A2A enabled.</p>"},{"location":"specification/","title":"Agent2Agent (A2A) Protocol Specification (DRAFT v1.0)","text":"Latest Released Version <code>0.3.0</code> <p>Previous Versions</p> <ul> <li><code>0.2.6</code></li> <li><code>0.2.5</code></li> <li><code>0.2.4</code></li> <li><code>0.2.0</code></li> <li><code>0.1.0</code></li> </ul> <p>See Release Notes for changes made between versions.</p>"},{"location":"specification/#1-introduction","title":"1. Introduction","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to facilitate communication and interoperability between independent, potentially opaque AI agent systems. In an ecosystem where agents might be built using different frameworks, languages, or by different vendors, A2A provides a common language and interaction model.</p> <p>This document provides the detailed technical specification for the A2A protocol. Its primary goal is to enable agents to:</p> <ul> <li>Discover each other's capabilities.</li> <li>Negotiate interaction modalities (text, files, structured data).</li> <li>Manage collaborative tasks.</li> <li>Securely exchange information to achieve user goals without needing access to each other's internal state, memory, or tools.</li> </ul>"},{"location":"specification/#11-key-goals-of-a2a","title":"1.1. Key Goals of A2A","text":"<ul> <li>Interoperability: Bridge the communication gap between disparate agentic systems.</li> <li>Collaboration: Enable agents to delegate tasks, exchange context, and work together on complex user requests.</li> <li>Discovery: Allow agents to dynamically find and understand the capabilities of other agents.</li> <li>Flexibility: Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.</li> <li>Security: Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.</li> <li>Asynchronicity: Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.</li> </ul>"},{"location":"specification/#12-guiding-principles","title":"1.2. Guiding Principles","text":"<ul> <li>Simple: Reuse existing, well-understood standards (HTTP, JSON-RPC 2.0, Server-Sent Events).</li> <li>Enterprise Ready: Address authentication, authorization, security, privacy, tracing, and monitoring by aligning with established enterprise practices.</li> <li>Async First: Designed for (potentially very) long-running tasks and human-in-the-loop interactions.</li> <li>Modality Agnostic: Support exchange of diverse content types including text, audio/video (via file references), structured data/forms, and potentially embedded UI components (e.g., iframes referenced in parts).</li> <li>Opaque Execution: Agents collaborate based on declared capabilities and exchanged information, without needing to share their internal thoughts, plans, or tool implementations.</li> </ul> <p>For a broader understanding of A2A's purpose and benefits, see What is A2A?.</p>"},{"location":"specification/#13-specification-structure","title":"1.3. Specification Structure","text":"<p>This specification is organized into three distinct layers that work together to provide a complete protocol definition:</p> <pre><code>graph TB\n    subgraph L1 [\"A2A Data Model\"]\n        direction LR\n        A[Task] ~~~ B[Message] ~~~ C[AgentCard] ~~~ D[Part] ~~~ E[Artifact] ~~~ F[Extension]\n    end\n\n    subgraph L2 [\"A2A Operations\"]\n        direction LR\n        G[Send Message] ~~~ H[Stream Message] ~~~ I[Get Task] ~~~ J[List Tasks] ~~~ K[Cancel Task] ~~~ L[Get Agent Card]\n    end\n\n    subgraph L3 [\"Protocol Bindings\"]\n        direction LR\n        M[JSON-RPC Methods] ~~~ N[gRPC RPCs] ~~~ O[HTTP/REST Endpoints] ~~~ P[Custom Bindings]\n    end\n\n    %% Dependencies between layers\n    L1 --&gt; L2\n    L2 --&gt; L3\n\n\n    style A fill:#e1f5fe\n    style B fill:#e1f5fe\n    style C fill:#e1f5fe\n    style D fill:#e1f5fe\n    style E fill:#e1f5fe\n    style F fill:#e1f5fe\n\n    style G fill:#f3e5f5\n    style H fill:#f3e5f5\n    style I fill:#f3e5f5\n    style J fill:#f3e5f5\n    style K fill:#f3e5f5\n    style L fill:#f3e5f5\n\n    style M fill:#e8f5e8\n    style N fill:#e8f5e8\n    style O fill:#e8f5e8\n\n    style L1 fill:#f0f8ff,stroke:#333,stroke-width:2px\n    style L2 fill:#faf0ff,stroke:#333,stroke-width:2px\n    style L3 fill:#f0fff0,stroke:#333,stroke-width:2px</code></pre> <p>Layer 1: Canonical Data Model defines the core data structures and message formats that all A2A implementations must understand. These are protocol agnostic definitions expressed as Protocol Buffer messages.</p> <p>Layer 2: Abstract Operations describes the fundamental capabilities and behaviors that A2A agents must support, independent of how they are exposed over specific protocols.</p> <p>Layer 3: Protocol Bindings provides concrete mappings of the abstract operations and data structures to specific protocol bindings (JSON-RPC, gRPC, HTTP/REST), including method names, endpoint patterns, and protocol-specific behaviors.</p> <p>This layered approach ensures that:</p> <ul> <li>Core semantics remain consistent across all protocol bindings</li> <li>New protocol bindings can be added without changing the fundamental data model</li> <li>Developers can reason about A2A operations independently of binding concerns</li> <li>Interoperability is maintained through shared understanding of the canonical data model</li> </ul>"},{"location":"specification/#14-normative-content","title":"1.4 Normative Content","text":"<p>In addition to the protocol requirements defined in this document, the file <code>spec/a2a.proto</code> is the single authoritative normative definition of all protocol data objects and request/response messages. A generated JSON artifact (<code>spec/a2a.json</code>, produced at build time and not committed) MAY be published for convenience to tooling and the website, but it is a non-normative build artifact. SDK language bindings, schemas, and any other derived forms MUST be regenerated from the proto (directly or via code generation) rather than edited manually.</p> <p>Change Control and Deprecation Lifecycle:</p> <ul> <li>Introduction: When a proto message or field is renamed, the new name is added while existing published names remain available, but marked deprecated, until the next major release.</li> <li>Documentation: Migration guidance MUST be provided via an ancillary document when introducing major breaking changes.</li> <li>Anchors: Legacy documentation anchors MUST be preserved (as hidden HTML anchors) to avoid breaking inbound links.</li> <li>SDK/Schema Aliases: SDKs and JSON Schemas SHOULD provide deprecated alias types/definitions to maintain backward compatibility.</li> <li>Removal: A deprecated name SHOULD NOT be removed earlier than the next major version after introduction of its replacement.</li> </ul> <p>Automated Generation:</p> <p>The documentation build generates <code>specification/json/a2a.json</code> on-the-fly (the file is not tracked in source control). Future improvements may publish an OpenAPI v3 + JSON Schema bundle for enhanced tooling.</p> <p>Rationale:</p> <p>Centering the proto file as the normative source ensures protocol neutrality, reduces specification drift, and provides a deterministic evolution path for the ecosystem.</p>"},{"location":"specification/#2-terminology","title":"2. Terminology","text":""},{"location":"specification/#21-requirements-language","title":"2.1. Requirements Language","text":"<p>The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p>"},{"location":"specification/#22-core-concepts","title":"2.2. Core Concepts","text":"<p>A2A revolves around several key concepts. For detailed explanations, please refer to the Key Concepts guide.</p> <ul> <li>A2A Client: An application or agent that initiates requests to an A2A Server on behalf of a user or another system.</li> <li>A2A Server (Remote Agent): An agent or agentic system that exposes an A2A-compliant endpoint, processing tasks and providing responses.</li> <li>Agent Card: A JSON metadata document published by an A2A Server, describing its identity, capabilities, skills, service endpoint, and authentication requirements.</li> <li>Message: A communication turn between a client and a remote agent, having a <code>role</code> (\"user\" or \"agent\") and containing one or more <code>Parts</code>.</li> <li>Task: The fundamental unit of work managed by A2A, identified by a unique ID. Tasks are stateful and progress through a defined lifecycle.</li> <li>Part: The smallest unit of content within a Message or Artifact. Parts can contain text, file references, or structured data.</li> <li>Artifact: An output (e.g., a document, image, structured data) generated by the agent as a result of a task, composed of <code>Parts</code>.</li> <li>Streaming: Real-time, incremental updates for tasks (status changes, artifact chunks) delivered via protocol-specific streaming mechanisms.</li> <li>Push Notifications: Asynchronous task updates delivered via server-initiated HTTP POST requests to a client-provided webhook URL, for long-running or disconnected scenarios.</li> <li>Context: An optional, server-generated identifier to logically group related tasks and messages.</li> <li>Extension: A mechanism for agents to provide additional functionality or data beyond the core A2A specification.</li> </ul>"},{"location":"specification/#3-a2a-protocol-operations","title":"3. A2A Protocol Operations","text":"<p>This section describes the core operations of the A2A protocol in a binding-independent manner. These operations define the fundamental capabilities that all A2A implementations must support, regardless of the underlying binding mechanism.</p>"},{"location":"specification/#31-core-operations","title":"3.1. Core Operations","text":"<p>The following operations define the fundamental capabilities that all A2A implementations must support, independent of the specific protocol binding used. For a quick reference mapping of these operations to protocol-specific method names and endpoints, see Section 5.3 (Method Mapping Reference). For detailed protocol-specific implementation details, see:</p> <ul> <li>Section 9: JSON-RPC Protocol Binding</li> <li>Section 10: gRPC Protocol Binding</li> <li>Section 11: HTTP+JSON/REST Protocol Binding</li> </ul>"},{"location":"specification/#311-send-message","title":"3.1.1. Send Message","text":"<p>The primary operation for initiating agent interactions. Clients send a message to an agent and receive either a task that tracks the processing or a direct response message.</p> <p>Inputs:</p> <ul> <li><code>SendMessageRequest</code>: Request object containing the message, configuration, and metadata</li> </ul> <p>Outputs:</p> <ul> <li><code>Task</code>: A task object representing the processing of the message, OR</li> <li><code>Message</code>: A direct response message (for simple interactions that don't require task tracking)</li> </ul> <p>Errors:</p> <ul> <li><code>ContentTypeNotSupportedError</code>: A Media Type provided in the request's message parts is not supported by the agent.</li> <li><code>UnsupportedOperationError</code>: Messages sent to Tasks that are in a terminal state (e.g., completed, canceled, rejected) cannot accept further messages.</li> </ul> <p>Behavior:</p> <p>The agent MAY create a new <code>Task</code> to process the provided message asynchronously or MAY return a direct <code>Message</code> response for simple interactions. The operation MUST return immediately with either task information or response message. Task processing MAY continue asynchronously after the response when a <code>Task</code> is returned.</p>"},{"location":"specification/#312-send-streaming-message","title":"3.1.2. Send Streaming Message","text":"<p>Similar to Send Message but with real-time streaming of updates during processing.</p> <p>Inputs:</p> <ul> <li><code>SendMessageRequest</code>: Request object containing the message, configuration, and metadata</li> </ul> <p>Outputs:</p> <ul> <li><code>Stream Response</code> object containing:<ul> <li>Initial response: <code>Task</code> object OR <code>Message</code> object</li> <li>Subsequent events following a <code>Task</code> MAY include stream of <code>TaskStatusUpdateEvent</code> and <code>TaskArtifactUpdateEvent</code> objects</li> </ul> </li> <li>Final completion indicator</li> </ul> <p>Errors:</p> <ul> <li><code>UnsupportedOperationError</code>: Streaming is not supported by the agent (see Capability Validation).</li> <li><code>UnsupportedOperationError</code>: Messages sent to Tasks that are in a terminal state (e.g., completed, canceled, rejected) cannot accept further messages.</li> <li><code>ContentTypeNotSupportedError</code>: A Media Type provided in the request's message parts is not supported by the agent.</li> <li><code>TaskNotFoundError</code>: The task ID does not exist or is not accessible.</li> </ul> <p>Behavior:</p> <p>The operation MUST establish a streaming connection for real-time updates. The stream MUST follow one of these patterns:</p> <ol> <li> <p>Message-only stream: If the agent returns a <code>Message</code>, the stream MUST contain exactly one <code>Message</code> object and then close immediately. No task tracking or updates are provided.</p> </li> <li> <p>Task lifecycle stream: If the agent returns a <code>Task</code>, the stream MUST begin with the Task object, followed by zero or more <code>TaskStatusUpdateEvent</code> or <code>TaskArtifactUpdateEvent</code> objects. The stream MUST close when the task reaches a terminal state (e.g. completed, failed, canceled, rejected).</p> </li> </ol> <p>The agent MAY return a <code>Task</code> for complex processing with status/artifact updates or MAY return a <code>Message</code> for direct streaming responses without task overhead. The implementation MUST provide immediate feedback on progress and intermediate results.</p>"},{"location":"specification/#313-get-task","title":"3.1.3. Get Task","text":"<p>Retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task. This is typically used for polling the status of a task initiated with message/send, or for fetching the final state of a task after being notified via a push notification or after a stream has ended.</p> <p>Inputs:</p> <p>Represents a request for the <code>GetTask</code> method.</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>name</code> <code>string</code> Yes The resource name of the task. Format: tasks/{task_id} <code>historyLength</code> <code>integer</code> Optional The maximum number of most recent messages from the task's history to retrieve. An unset value means the client does not impose any limit. A value of zero is a request to not include any messages. The server MUST NOT return more messages than the provided value, but MAY apply a lower limit. <p>See History Length Semantics for details about <code>historyLength</code>.</p> <p>Outputs:</p> <ul> <li><code>Task</code>: Current state and artifacts of the requested task</li> </ul> <p>Errors:</p> <ul> <li><code>TaskNotFoundError</code>: The task ID does not exist or is not accessible.</li> </ul>"},{"location":"specification/#314-list-tasks","title":"3.1.4. List Tasks","text":"<p>Retrieves a list of tasks with optional filtering and pagination capabilities. This method allows clients to discover and manage multiple tasks across different contexts or with specific status criteria.</p> <p>Inputs:</p> <p>Parameters for listing tasks with optional filtering criteria.</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>contextId</code> <code>string</code> No Filter tasks by context ID to get tasks from a specific conversation or session. <code>status</code> <code>TaskState</code> No Filter tasks by their current status state. <code>pageSize</code> <code>integer</code> Optional Maximum number of tasks to return. Must be between 1 and 100. Defaults to 50 if not specified. <code>pageToken</code> <code>string</code> No Token for pagination. Use the next_page_token from a previous ListTasksResponse. <code>historyLength</code> <code>integer</code> Optional The maximum number of messages to include in each task's history. <code>statusTimestampAfter</code> <code>timestamp</code> No Filter tasks which have a status updated after the provided timestamp in ISO 8601 format (e.g., \"2023-10-27T10:00:00Z\"). Only tasks with a status timestamp time greater than or equal to this value will be returned. <code>includeArtifacts</code> <code>boolean</code> Optional Whether to include artifacts in the returned tasks. Defaults to false to reduce payload size. <p>When <code>includeArtifacts</code> is false (the default), the artifacts field MUST be omitted entirely from each Task object in the response. The field should not be present as an empty array or null value. When <code>includeArtifacts</code> is true, the artifacts field should be included with its actual content (which may be an empty array if the task has no artifacts).</p> <p>Outputs:</p> <p>Result object for tasks/list method containing an array of tasks and pagination information.</p> Field Type Required Description <code>tasks</code> array of <code>Task</code> Yes Array of tasks matching the specified criteria. <code>nextPageToken</code> <code>string</code> Yes Token for retrieving the next page. Empty string if no more results. <code>pageSize</code> <code>integer</code> Yes The size of page requested. <code>totalSize</code> <code>integer</code> Yes Total number of tasks available (before pagination). <p>Note on <code>nextPageToken</code>: The <code>nextPageToken</code> field MUST always be present in the response. When there are no more results to retrieve (i.e., this is the final page), the field MUST be set to an empty string (\"\"). Clients should check for an empty string to determine if more pages are available.</p> <p>Errors:</p> <p>None specific to this operation beyond standard protocol errors.</p> <p>Behavior:</p> <p>The operation MUST return only tasks visible to the authenticated client and MUST use cursor-based pagination for performance and consistency. Tasks MUST be sorted by last update time in descending order. Implementations MUST implement appropriate authorization scoping to ensure clients can only access authorized tasks. See Section 13.1 Data Access and Authorization Scoping for detailed security requirements.</p> <p>Pagination Strategy:</p> <p>This method uses cursor-based pagination (via <code>pageToken</code>/<code>nextPageToken</code>) rather than offset-based pagination for better performance and consistency, especially with large datasets. Cursor-based pagination avoids the \"deep pagination problem\" where skipping large numbers of records becomes inefficient for databases. This approach is consistent with the gRPC specification, which also uses cursor-based pagination (page_token/next_page_token).</p> <p>Ordering:</p> <p>Implementations MUST return tasks sorted by their status timestamp time in descending order (most recently updated tasks first). This ensures consistent pagination and allows clients to efficiently monitor recent task activity.</p>"},{"location":"specification/#315-cancel-task","title":"3.1.5. Cancel Task","text":"<p>Requests the cancellation of an ongoing task. The server will attempt to cancel the task, but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).</p> <p>Inputs:</p> <p>Represents a request for the <code>CancelTask</code> method.</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>name</code> <code>string</code> No The resource name of the task to cancel. Format: tasks/{task_id} <p>Outputs:</p> <ul> <li>Updated <code>Task</code> with cancellation status</li> </ul> <p>Errors:</p> <ul> <li><code>TaskNotCancelableError</code>: The task is not in a cancelable state (e.g., already completed, failed, or canceled).</li> <li><code>TaskNotFoundError</code>: The task ID does not exist or is not accessible.</li> </ul> <p>Behavior:</p> <p>The operation attempts to cancel the specified task and returns its updated state.</p>"},{"location":"specification/#316-subscribe-to-task","title":"3.1.6. Subscribe to Task","text":"<p>Establishes a streaming connection to receive updates for an existing task.</p> <p>Inputs:</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>name</code> <code>string</code> No The resource name of the task to subscribe to. Format: tasks/{task_id} <p>Outputs:</p> <ul> <li><code>Stream Response</code> object containing:<ul> <li>Initial response: <code>Task</code> object with current state</li> <li>Stream of <code>TaskStatusUpdateEvent</code> and <code>TaskArtifactUpdateEvent</code> objects</li> </ul> </li> </ul> <p>Errors:</p> <ul> <li><code>UnsupportedOperationError</code>: Streaming is not supported by the agent (see Capability Validation).</li> <li><code>TaskNotFoundError</code>: The task ID does not exist or is not accessible.</li> <li><code>UnsupportedOperationError</code>: The operation is attempted on a task that is in a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>, or <code>rejected</code>).</li> </ul> <p>Behavior:</p> <p>The operation enables real-time monitoring of task progress and can be used with any task that is not in a terminal state. The stream MUST terminate when the task reaches a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>, or <code>rejected</code>).</p> <p>The operation MUST return a <code>Task</code> object as the first event in the stream, representing the current state of the task at the time of subscription. This prevents a potential loss of information between a call to <code>GetTask</code> and calling <code>SubscribeToTask</code>.</p>"},{"location":"specification/#317-create-push-notification-config","title":"3.1.7. Create Push Notification Config","text":"<p>Creates a push notification configuration for a task to receive asynchronous updates via webhook.</p> <p>Inputs:</p> <p>Represents a request for the <code>CreateTaskPushNotificationConfig</code> method.</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>parent</code> <code>string</code> Yes The parent task resource for this config. Format: tasks/{task_id} <code>configId</code> <code>string</code> Yes The ID for the new config. <code>config</code> <code>TaskPushNotificationConfig</code> Yes The configuration to create. <p>Outputs:</p> <ul> <li><code>PushNotificationConfig</code>: Created configuration with assigned ID</li> </ul> <p>Errors:</p> <ul> <li><code>PushNotificationNotSupportedError</code>: Push notifications are not supported by the agent (see Capability Validation).</li> <li><code>TaskNotFoundError</code>: The task ID does not exist or is not accessible.</li> </ul> <p>Behavior:</p> <p>The operation MUST establish a webhook endpoint for task update notifications. When task updates occur, the agent will send HTTP POST requests to the configured webhook URL with <code>StreamResponse</code> payloads (see Push Notification Payload for details). This operation is only available if the agent supports push notifications capability. The configuration MUST persist until task completion or explicit deletion.</p> <p></p>"},{"location":"specification/#318-get-push-notification-config","title":"3.1.8. Get Push Notification Config","text":"<p>Retrieves an existing push notification configuration for a task.</p> <p>Inputs:</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>name</code> <code>string</code> No The resource name of the config to retrieve. Format: tasks/{task_id}/pushNotificationConfigs/{config_id} <p>Outputs:</p> <ul> <li><code>PushNotificationConfig</code>: The requested configuration</li> </ul> <p>Errors:</p> <ul> <li><code>PushNotificationNotSupportedError</code>: Push notifications are not supported by the agent (see Capability Validation).</li> <li><code>TaskNotFoundError</code>: The push notification configuration does not exist.</li> </ul> <p>Behavior:</p> <p>The operation MUST return configuration details including webhook URL and notification settings. The operation MUST fail if the configuration does not exist or the client lacks access.</p>"},{"location":"specification/#319-list-push-notification-configs","title":"3.1.9. List Push Notification Configs","text":"<p>Retrieves all push notification configurations for a task.</p> <p>Inputs:</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>parent</code> <code>string</code> No The parent task resource. Format: tasks/{task_id} <code>pageSize</code> <code>integer</code> No The maximum number of configurations to return. <code>pageToken</code> <code>string</code> No A page token received from a previous ListTaskPushNotificationConfigRequest call. <p>Outputs:</p> <p>Represents a successful response for the <code>ListTaskPushNotificationConfig</code> method.</p> Field Type Required Description <code>configs</code> array of <code>TaskPushNotificationConfig</code> No The list of push notification configurations. <code>nextPageToken</code> <code>string</code> No A token, which can be sent as <code>page_token</code> to retrieve the next page. If this field is omitted, there are no subsequent pages. <p>Errors:</p> <ul> <li><code>PushNotificationNotSupportedError</code>: Push notifications are not supported by the agent (see Capability Validation).</li> <li><code>TaskNotFoundError</code>: The task ID does not exist or is not accessible.</li> </ul> <p>Behavior:</p> <p>The operation MUST return all active push notification configurations for the specified task and MAY support pagination for tasks with many configurations.</p>"},{"location":"specification/#3110-delete-push-notification-config","title":"3.1.10. Delete Push Notification Config","text":"<p>Removes a push notification configuration for a task.</p> <p>Inputs:</p> <p>Represents a request for the <code>DeleteTaskPushNotificationConfig</code> method.</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>name</code> <code>string</code> No The resource name of the config to delete. Format: tasks/{task_id}/pushNotificationConfigs/{config_id} <p>Outputs:</p> <ul> <li>Confirmation of deletion (implementation-specific)</li> </ul> <p>Errors:</p> <ul> <li><code>PushNotificationNotSupportedError</code>: Push notifications are not supported by the agent (see Capability Validation).</li> <li><code>TaskNotFoundError</code>: The task ID does not exist.</li> </ul> <p>Behavior:</p> <p>The operation MUST permanently remove the specified push notification configuration. No further notifications will be sent to the configured webhook after deletion. This operation MUST be idempotent - multiple deletions of the same config have the same effect.</p>"},{"location":"specification/#3111-get-extended-agent-card","title":"3.1.11. Get Extended Agent Card","text":"<p>Retrieves a potentially more detailed version of the Agent Card after the client has authenticated. This endpoint is available only if <code>AgentCard.capabilities.extendedAgentCard</code> is <code>true</code>.</p> <p>Inputs:</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <p>Outputs:</p> <ul> <li><code>AgentCard</code>: A complete Agent Card object, which may contain additional details or skills not present in the public card</li> </ul> <p>Errors:</p> <ul> <li><code>UnsupportedOperationError</code>: The agent does not support authenticated extended cards (see Capability Validation).</li> <li><code>ExtendedAgentCardNotConfiguredError</code>: The agent declares support but does not have an extended agent card configured.</li> </ul> <p>Behavior:</p> <ul> <li>Authentication: The client MUST authenticate the request using one of the schemes declared in the public <code>AgentCard.securitySchemes</code> and <code>AgentCard.security</code> fields.</li> <li>Extended Information: The operation MAY return different details based on client authentication level, including additional skills, capabilities, or configuration not available in the public Agent Card.</li> <li>Card Replacement: Clients retrieving this extended card SHOULD replace their cached public Agent Card with the content received from this endpoint for the duration of their authenticated session or until the card's version changes.</li> <li>Availability: This operation is only available if the public Agent Card declares <code>capabilities.extendedAgentCard: true</code>.</li> </ul> <p>For detailed security guidance on extended agent cards, see Section 13.3 Extended Agent Card Access Control.</p>"},{"location":"specification/#32-operation-parameter-objects","title":"3.2. Operation Parameter Objects","text":"<p>This section defines common parameter objects used across multiple operations.</p>"},{"location":"specification/#321-sendmessagerequest","title":"3.2.1. SendMessageRequest","text":"<p>Represents a request for the <code>SendMessage</code> method.</p> Field Type Required Description <code>tenant</code> <code>string</code> No Optional tenant, provided as a path parameter. <code>message</code> <code>Message</code> Yes The message to send to the agent. <code>configuration</code> <code>SendMessageConfiguration</code> No Configuration for the send request. <code>metadata</code> <code>object</code> No A flexible key-value map for passing additional context or parameters."},{"location":"specification/#322-sendmessageconfiguration","title":"3.2.2. SendMessageConfiguration","text":"<p>Configuration of a send message request.</p> Field Type Required Description <code>acceptedOutputModes</code> array of <code>string</code> No A list of media types the client is prepared to accept for response parts. Agents SHOULD use this to tailor their output. <code>pushNotificationConfig</code> <code>PushNotificationConfig</code> No Configuration for the agent to send push notifications for task updates. <code>historyLength</code> <code>integer</code> Optional The maximum number of most recent messages from the task's history to retrieve in the response. An unset value means the client does not impose any limit. A value of zero is a request to not include any messages. The server MUST NOT return more messages than the provided value, but MAY apply a lower limit. <code>blocking</code> <code>boolean</code> No If true, the operation waits until the task reaches a terminal or interrupted state before returning. Default is false. <p>Blocking vs Non-Blocking Execution:</p> <p>The <code>blocking</code> field in <code>SendMessageConfiguration</code> controls whether the operation waits for task completion:</p> <ul> <li> <p>Blocking (<code>blocking: true</code>): The operation MUST wait until the task reaches a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>, <code>rejected</code>) or an interrupted state (<code>input_required</code>, <code>auth_required</code>) before returning. The response MUST include the current task state with all artifacts and status information.</p> </li> <li> <p>Non-Blocking (<code>blocking: false</code>): The operation MUST return immediately after creating the task, even if processing is still in progress. The returned task will have an in-progress state (e.g., <code>working</code>, <code>input_required</code>). It is the caller's responsibility to poll for updates using Get Task, subscribe via Subscribe to Task, or receive updates via push notifications.</p> </li> </ul> <p>The <code>blocking</code> field has no effect:</p> <ul> <li>when the operation returns a direct <code>Message</code> response instead of a task.</li> <li>for streaming operations, which always return updates in real-time.</li> <li>on configured push notification configurations, which operates independently of blocking mode.</li> </ul>"},{"location":"specification/#323-stream-response","title":"3.2.3. Stream Response","text":"<p>A wrapper object used in streaming operations to encapsulate different types of response data.</p> Field Type Required Description <code>task</code> <code>Task</code> No A Task object containing the current state of the task. <code>message</code> <code>Message</code> No A Message object containing a message from the agent. <code>statusUpdate</code> <code>TaskStatusUpdateEvent</code> No An event indicating a task status update. <code>artifactUpdate</code> <code>TaskArtifactUpdateEvent</code> No An event indicating a task artifact update. <p>Note: A StreamResponse MUST contain exactly one of the following: <code>task</code>, <code>message</code>, <code>statusUpdate</code>, <code>artifactUpdate</code></p> <p>This wrapper allows streaming endpoints to return different types of updates through a single response stream while maintaining type safety.</p>"},{"location":"specification/#324-history-length-semantics","title":"3.2.4. History Length Semantics","text":"<p>The <code>historyLength</code> parameter appears in multiple operations and controls how much task history is returned in responses. This parameter follows consistent semantics across all operations:</p> <ul> <li>Unset/undefined: No limit imposed; server returns its default amount of history (implementation-defined, may be all history)</li> <li>0: No history should be returned; the <code>history</code> field SHOULD be omitted</li> <li>&gt; 0: Return at most this many recent messages from the task's history</li> </ul>"},{"location":"specification/#325-metadata","title":"3.2.5. Metadata","text":"<p>A flexible key-value map for passing additional context or parameters with operations. Metadata keys and are strings and values can be any valid value that can be represented in JSON. <code>Extensions</code> can be used to strongly type metadata values for specific use cases.</p>"},{"location":"specification/#326-service-parameters","title":"3.2.6 Service Parameters","text":"<p>A key-value map for passing horizontally applicable context or parameters with case-insensitive string keys and case-sensitive string values. The transmission mechanism for these service parameter key-value pairs is defined by the specific protocol binding (e.g., HTTP headers for HTTP-based bindings, gRPC metadata for gRPC bindings). Custom protocol bindings MUST specify how service parameters are transmitted in their binding specification.</p> <p>Standard A2A Service Parameters:</p> Name Description Example Value <code>A2A-Extensions</code> Comma-separated list of extension URIs that the client wants to use for the request <code>https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1</code> <code>A2A-Version</code> The A2A protocol version that the client is using. If the version is not supported, the agent returns <code>VersionNotSupportedError</code> <code>0.3</code> <p>As service parameter names MAY need to co-exist with other parameters defined by the underlying transport protocol or infrastructure, all service parameters defined by this specification will be prefixed with <code>a2a-</code>.</p>"},{"location":"specification/#33-operation-semantics","title":"3.3. Operation Semantics","text":""},{"location":"specification/#331-idempotency","title":"3.3.1. Idempotency","text":"<ul> <li>Get operations (Get Task, List Tasks, Get Extended Agent Card) are naturally idempotent</li> <li>Send Message operations MAY be idempotent. Agents may utilize the messageId to detect duplicate messages.</li> <li>Cancel Task operations are idempotent - multiple cancellation requests have the same effect. A duplicate cancellation request MAY return <code>TaskNotFoundError</code> if the task has already been canceled and purged.</li> </ul>"},{"location":"specification/#332-error-handling","title":"3.3.2. Error Handling","text":"<p>All operations may return errors in the following categories. Servers MUST return appropriate errors and SHOULD provide actionable information to help clients resolve issues.</p> <p>Error Categories and Server Requirements:</p> <ul> <li> <p>Authentication Errors: Invalid or missing credentials</p> <ul> <li>Servers MUST reject requests with invalid or missing authentication credentials</li> <li>Servers SHOULD include authentication challenge information in the error response</li> <li>Servers SHOULD specify which authentication scheme is required</li> <li>Example error codes: HTTP <code>401 Unauthorized</code>, gRPC <code>UNAUTHENTICATED</code>, JSON-RPC custom error</li> <li>Example scenarios: Missing bearer token, expired API key, invalid OAuth token</li> </ul> </li> <li> <p>Authorization Errors: Insufficient permissions for requested operation</p> <ul> <li>Servers MUST return an authorization error when the authenticated client lacks required permissions</li> <li>Servers SHOULD indicate what permission or scope is missing (without leaking sensitive information about resources the client cannot access)</li> <li>Servers MUST NOT reveal the existence of resources the client is not authorized to access</li> <li>Example error codes: HTTP <code>403 Forbidden</code>, gRPC <code>PERMISSION_DENIED</code>, JSON-RPC custom error</li> <li>Example scenarios: Attempting to access a task created by another user, insufficient OAuth scopes</li> </ul> </li> <li> <p>Validation Errors: Invalid input parameters or message format</p> <ul> <li>Servers MUST validate all input parameters before processing</li> <li>Servers SHOULD specify which parameter(s) failed validation and why</li> <li>Servers SHOULD provide guidance on valid parameter values or formats</li> <li>Example error codes: HTTP <code>400 Bad Request</code>, gRPC <code>INVALID_ARGUMENT</code>, JSON-RPC <code>-32602 Invalid params</code></li> <li>Example scenarios: Invalid task ID format, missing required message parts, unsupported content type</li> </ul> </li> <li> <p>Resource Errors: Requested task not found or not accessible</p> <ul> <li>Servers MUST return a not found error when a requested resource does not exist or is not accessible to the authenticated client</li> <li>Servers SHOULD NOT distinguish between \"does not exist\" and \"not authorized\" to prevent information leakage</li> <li>Example error codes: HTTP <code>404 Not Found</code>, gRPC <code>NOT_FOUND</code>, JSON-RPC custom error (see A2A-specific errors)</li> <li>Example scenarios: Task ID does not exist, task has been deleted, configuration not found</li> </ul> </li> <li> <p>System Errors: Internal agent failures or temporary unavailability</p> <ul> <li>Servers SHOULD return appropriate error codes for temporary failures vs. permanent errors</li> <li>Servers MAY include retry guidance (e.g., Retry-After header in HTTP)</li> <li>Servers SHOULD log system errors for diagnostic purposes</li> <li>Example error codes: HTTP <code>500 Internal Server Error</code> or <code>503 Service Unavailable</code>, gRPC <code>INTERNAL</code> or <code>UNAVAILABLE</code>, JSON-RPC <code>-32603 Internal error</code></li> <li>Example scenarios: Database connection failure, downstream service timeout, rate limit exceeded</li> </ul> </li> </ul> <p>Error Payload Structure:</p> <p>All error responses in the A2A protocol, regardless of binding, MUST convey the following information:</p> <ol> <li>Error Code: A machine-readable identifier for the error type (e.g., string code, numeric code, or protocol-specific status)</li> <li>Error Message: A human-readable description of the error</li> <li>Error Details (optional): Additional structured information about the error, such as:<ul> <li>Affected fields or parameters</li> <li>Contextual information (e.g., task ID, timestamp)</li> <li>Suggestions for resolution</li> </ul> </li> </ol> <p>Protocol bindings MUST map these elements to their native error representations while preserving semantic meaning. See binding-specific sections for concrete error format examples: JSON-RPC Error Handling, gRPC Error Handling, and HTTP/REST Error Handling.</p> <p>A2A-Specific Errors:</p> Error Name Description <code>TaskNotFoundError</code> The specified task ID does not correspond to an existing or accessible task. It might be invalid, expired, or already completed and purged. <code>TaskNotCancelableError</code> An attempt was made to cancel a task that is not in a cancelable state (e.g., it has already reached a terminal state like <code>completed</code>, <code>failed</code>, or <code>canceled</code>). <code>PushNotificationNotSupportedError</code> Client attempted to use push notification features but the server agent does not support them (i.e., <code>AgentCard.capabilities.pushNotifications</code> is <code>false</code>). <code>UnsupportedOperationError</code> The requested operation or a specific aspect of it is not supported by this server agent implementation. <code>ContentTypeNotSupportedError</code> A Media Type provided in the request's message parts or implied for an artifact is not supported by the agent or the specific skill being invoked. <code>InvalidAgentResponseError</code> An agent returned a response that does not conform to the specification for the current method. <code>ExtendedAgentCardNotConfiguredError</code> The agent does not have an extended agent card configured when one is required for the requested operation. <code>ExtensionSupportRequiredError</code> Client requested use of an extension marked as <code>required: true</code> in the Agent Card but the client did not declare support for it in the request. <code>VersionNotSupportedError</code> The A2A protocol version specified in the request (via <code>A2A-Version</code> service parameter) is not supported by the agent."},{"location":"specification/#333-asynchronous-processing","title":"3.3.3. Asynchronous Processing","text":"<p>A2A operations are designed for asynchronous task execution. Operations return immediately with either <code>Task</code> objects or <code>Message</code> objects, and when a Task is returned, processing continues in the background. Clients retrieve task updates through polling, streaming, or push notifications (see Section 3.5). Agents MAY accept additional messages for tasks in non-terminal states to enable multi-turn interactions (see Section 3.4).</p>"},{"location":"specification/#334-capability-validation","title":"3.3.4. Capability Validation","text":"<p>Agents declare optional capabilities in their <code>AgentCard</code>. When clients attempt to use operations or features that require capabilities not declared as supported in the Agent Card, the agent MUST return an appropriate error response:</p> <ul> <li>Push Notifications: If <code>AgentCard.capabilities.pushNotifications</code> is <code>false</code> or not present, operations related to push notification configuration (Create, Get, List, Delete) MUST return <code>PushNotificationNotSupportedError</code>.</li> <li>Streaming: If <code>AgentCard.capabilities.streaming</code> is <code>false</code> or not present, attempts to use <code>SendStreamingMessage</code> or <code>SubscribeToTask</code> operations MUST return <code>UnsupportedOperationError</code>.</li> <li>Extended Agent Card: If <code>AgentCard.capabilities.extendedAgentCard</code> is <code>false</code> or not present, attempts to call the Get Extended Agent Card operation MUST return <code>UnsupportedOperationError</code>. If the agent declares support but has not configured an extended card, it MUST return <code>ExtendedAgentCardNotConfiguredError</code>.</li> <li>Extensions: When a client requests use of an extension marked as <code>required: true</code> in the Agent Card but the client does not declare support for it, the agent MUST return <code>ExtensionSupportRequiredError</code>.</li> </ul> <p>Clients SHOULD validate capability support by examining the Agent Card before attempting operations that require optional capabilities.</p>"},{"location":"specification/#34-multi-turn-interactions","title":"3.4. Multi-Turn Interactions","text":"<p>The A2A protocol supports multi-turn conversations through context identifiers and task references, enabling agents to maintain conversational continuity across multiple interactions.</p>"},{"location":"specification/#341-context-identifier-semantics","title":"3.4.1. Context Identifier Semantics","text":"<p>A <code>contextId</code> is an identifier that logically groups multiple related <code>Task</code> and <code>Message</code> objects, providing continuity across a series of interactions.</p> <p>Generation and Assignment:</p> <ul> <li>Agents MUST generate a new <code>contextId</code> when processing a <code>Message</code> that does not include a <code>contextId</code> field</li> <li>The generated <code>contextId</code> MUST be included in the response (either <code>Task</code> or <code>Message</code>)</li> <li>Agents MUST accept and preserve client-provided <code>contextId</code> values if validations pass (i.e., it doesn't conflict with provided <code>taskId</code>)</li> <li><code>contextId</code> values SHOULD be treated as opaque identifiers by clients</li> </ul> <p>Grouping and Scope:</p> <ul> <li>A <code>contextId</code> logically groups multiple <code>Task</code> objects and <code>Message</code> objects that are part of the same conversational context</li> <li>All tasks and messages with the same <code>contextId</code> SHOULD be treated as part of the same conversational session</li> <li>Agents MAY use the <code>contextId</code> to maintain internal state, conversational history, or LLM context across multiple interactions</li> <li>Agents MAY implement context expiration or cleanup policies and SHOULD document any such policies</li> </ul>"},{"location":"specification/#342-task-identifier-semantics","title":"3.4.2. Task Identifier Semantics","text":"<p>A <code>taskId</code> is a unique identifier for a <code>Task</code> object, representing a stateful unit of work with a defined lifecycle.</p> <p>Generation and Assignment:</p> <ul> <li>Task IDs are server-generated when a new task is created in response to a <code>Message</code></li> <li>Agents MUST generate a unique <code>taskId</code> for each new task they create</li> <li>The generated <code>taskId</code> MUST be included in the <code>Task</code> object returned to the client</li> <li>When a client includes a <code>taskId</code> in a <code>Message</code>, it MUST reference an existing task</li> <li>Agents MUST return a <code>TaskNotFoundError</code> if the provided <code>taskId</code> does not correspond to an existing task</li> <li>Client-provided <code>taskId</code> values for creating new tasks is NOT supported</li> </ul>"},{"location":"specification/#343-multi-turn-conversation-patterns","title":"3.4.3. Multi-Turn Conversation Patterns","text":"<p>The A2A protocol supports several patterns for multi-turn interactions:</p> <p>Context Continuity:</p> <ul> <li><code>Task</code> objects maintain conversation context through the <code>contextId</code> field</li> <li>Clients MAY include the <code>contextId</code> in subsequent messages to indicate continuation of a previous interaction</li> <li>Clients MAY use <code>taskId</code> (with or without <code>contextId</code>) to continue or refine a specific task</li> <li>Clients MAY use <code>contextId</code> without <code>taskId</code> to start a new task within an existing conversation context</li> <li>Agents MUST infer <code>contextId</code> from the task if only <code>taskId</code> is provided</li> <li>Agents MUST reject messages containing mismatching <code>contextId</code> and <code>taskId</code> (i.e., the provided <code>contextId</code> is different from that of the referenced <code>Task</code>).</li> </ul> <p>Input Required State:</p> <ul> <li>Agents can request additional input mid-processing by transitioning a task to the <code>input-required</code> state</li> <li>The client continues the interaction by sending a new message with the same <code>taskId</code> and <code>contextId</code></li> </ul> <p>Follow-up Messages:</p> <ul> <li>Clients can send additional messages with <code>taskId</code> references to continue or refine existing tasks</li> <li>Clients SHOULD use the <code>referenceTaskIds</code> field in <code>Message</code> to explicitly reference related tasks</li> <li>Agents SHOULD use referenced tasks to understand the context and intent of follow-up requests</li> </ul> <p>Context Inheritance:</p> <ul> <li>New tasks created within the same <code>contextId</code> can inherit context from previous interactions</li> <li>Agents SHOULD leverage the shared <code>contextId</code> to provide contextually relevant responses</li> </ul>"},{"location":"specification/#35-task-update-delivery-mechanisms","title":"3.5. Task Update Delivery Mechanisms","text":"<p>The A2A protocol provides three complementary mechanisms for clients to receive updates about task progress and completion.</p>"},{"location":"specification/#351-overview-of-update-mechanisms","title":"3.5.1. Overview of Update Mechanisms","text":"<p>Polling (Get Task):</p> <ul> <li>Client periodically calls Get Task (Section 3.1.3) to check task status</li> <li>Simple to implement, works with all protocol bindings</li> <li>Higher latency, potential for unnecessary requests</li> <li>Best for: Simple integrations, infrequent updates, clients behind restrictive firewalls</li> </ul> <p>Streaming:</p> <ul> <li>Real-time delivery of events as they occur</li> <li>Operations: Stream Message (Section 3.1.2) and Subscribe to Task (Section 3.1.6)</li> <li>Low latency, efficient for frequent updates</li> <li>Requires persistent connection support</li> <li>Best for: Interactive applications, real-time dashboards, live progress monitoring</li> <li>Requires <code>AgentCard.capabilities.streaming</code> to be <code>true</code></li> </ul> <p>Push Notifications (WebHooks):</p> <ul> <li>Agent sends HTTP POST requests to client-registered endpoints when task state changes</li> <li>Client does not maintain persistent connection</li> <li>Asynchronous delivery, client must be reachable via HTTP</li> <li>Best for: Server-to-server integrations, long-running tasks, event-driven architectures</li> <li>Operations: Create (Section 3.1.7), Get (Section 3.1.8), List (Section 3.1.9), Delete (Section 3.1.10)</li> <li>Event types: TaskStatusUpdateEvent (Section 4.2.1), TaskArtifactUpdateEvent (Section 4.2.2), WebHook payloads (Section 4.3)</li> <li>Requires <code>AgentCard.capabilities.pushNotifications</code> to be <code>true</code></li> <li>Regardless of the protocol binding being used by the agent, WebHook calls use plain HTTP and the JSON payloads as defined in the HTTP protocol binding</li> </ul>"},{"location":"specification/#352-streaming-event-delivery","title":"3.5.2. Streaming Event Delivery","text":"<p>Event Ordering:</p> <p>All implementations MUST deliver events in the order they were generated. Events MUST NOT be reordered during transmission, regardless of protocol binding.</p> <p>Multiple Streams Per Task:</p> <p>An agent MAY serve multiple concurrent streams to one or more clients for the same task. This allows multiple clients (or the same client with multiple connections) to independently subscribe to and receive updates about a task's progress.</p> <p>When multiple streams are active for a task:</p> <ul> <li>Events MUST be broadcast to all active streams for that task</li> <li>Each stream MUST receive the same events in the same order</li> <li>Closing one stream MUST NOT affect other active streams for the same task</li> <li>The task lifecycle is independent of any individual stream's lifecycle</li> </ul> <p>This capability enables scenarios such as:</p> <ul> <li>Multiple team members monitoring the same long-running task</li> <li>A client reconnecting to a task after a network interruption by opening a new stream</li> <li>Different applications or dashboards displaying real-time updates for the same task</li> </ul>"},{"location":"specification/#353-push-notification-delivery","title":"3.5.3. Push Notification Delivery","text":"<p>Push notifications are delivered via HTTP POST to client-registered webhook endpoints. The delivery semantics and reliability guarantees are defined in Section 4.3.</p>"},{"location":"specification/#36-versioning","title":"3.6 Versioning","text":"<p>The specific version of the A2A protocol in use is identified using the <code>Major.Minor</code> elements (e.g. <code>1.0</code>) of the corresponding A2A specification version. Patch version numbers used by the specification, do not affect protocol compatibility. Patch version numbers SHOULD NOT be used in requests, responses and Agent Cards, and MUST not be considered when clients and servers negotiate protocol versions.</p>"},{"location":"specification/#361-client-responsibilities","title":"3.6.1 Client Responsibilities","text":"<p>It is RECOMMENDED that clients send the <code>A2A-Version</code> header with each request to maintain compatibility after an agent upgrades to a new version of the protocol. Sending the <code>A2A-Version</code> header also provides visibility to agents about version usage in the ecosystem, which can help inform the risks of inplace version upgrades.</p> <p>Example of HTTP GET Request with Version Header:</p> <pre><code>GET /tasks/task-123 HTTP/1.1\nHost: agent.example.com\nA2A-Version: 1.0\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\nAccept: application/json\n</code></pre>"},{"location":"specification/#362-server-responsibilities","title":"3.6.2 Server Responsibilities","text":"<p>Agents MUST process requests using the semantics of the requested <code>A2A-Version</code> (matching <code>Major.Minor</code>). If the version is not supported, agents MUST return a <code>VersionNotSupportedError</code>.</p> <p>Agents SHOULD declare their supported protocol versions in the <code>protocolVersions</code> field of their Agent Card:</p> <ul> <li>For stable versions (1.x and above): Backward compatibility within a major version is required. An agent supporting version <code>1.2</code> must also support <code>1.0</code> and <code>1.1</code>. Only the latest supported minor version per major version needs to be listed.</li> <li>For legacy experimental versions (0.x): These early versions introduced breaking changes between minor versions. Agents that still support any <code>0.x</code> versions MUST explicitly list each one they support.</li> </ul> <p>Example of Agent Card with Supported Protocol Versions:</p> <pre><code>{\n  \"agentId\": \"agent-123\",\n  \"name\": \"Example Agent\",\n  \"protocolVersions\": [\"0.3\", \"1.1\"]\n}\n</code></pre> <p>The above example indicates that the agent supports A2A protocol versions <code>0.3</code>, <code>1.0</code> and <code>1.1</code>.</p>"},{"location":"specification/#363-client-fallback","title":"3.6.3 Client Fallback","text":"<p>Clients that receive a <code>VersionNotSupportedError</code> can choose to retry the request with an earlier supported version, or fail the request. This explicit failure handling helps prevent unexpected behavior that could arise if an agent processes a request containing protocol features or fields it does not recognize.</p>"},{"location":"specification/#364-tooling-support","title":"3.6.4 Tooling support","text":"<p>Tooling libraries and SDKs that implement the A2A protocol SHOULD provide mechanisms to help clients manage protocol versioning, such as providing configuration options to enable automatic fallback to earlier versions when a <code>VersionNotSupportedError</code> is encountered. Client Agents that require the latest features of the protocol should not enable automatic fallback, to avoid silently losing functionality.</p>"},{"location":"specification/#4-protocol-data-model","title":"4. Protocol Data Model","text":"<p>The A2A protocol defines a canonical data model using Protocol Buffers. All protocol bindings MUST provide functionally equivalent representations of these data structures.</p>"},{"location":"specification/#41-core-objects","title":"4.1. Core Objects","text":""},{"location":"specification/#411-task","title":"4.1.1. Task","text":"<p>Task is the core unit of action for A2A. It has a current status and when results are created for the task they are stored in the artifact. If there are multiple turns for a task, these are stored in history.</p> Field Type Required Description <code>id</code> <code>string</code> Yes Unique identifier (e.g. UUID) for the task, generated by the server for a new task. <code>contextId</code> <code>string</code> Yes Unique identifier (e.g. UUID) for the contextual collection of interactions (tasks and messages). Created by the A2A server. <code>status</code> <code>TaskStatus</code> Yes The current status of a Task, including state and a message. <code>artifacts</code> array of <code>Artifact</code> No A set of output artifacts for a Task. <code>history</code> array of <code>Message</code> No The history of interactions from a task. <code>metadata</code> <code>object</code> No A key/value object to store custom metadata about a task. <p></p>"},{"location":"specification/#412-taskstatus","title":"4.1.2. TaskStatus","text":"<p>A container for the status of a task</p> Field Type Required Description <code>state</code> <code>TaskState</code> Yes The current state of this task. <code>message</code> <code>Message</code> No A message associated with the status. <code>timestamp</code> <code>timestamp</code> No ISO 8601 Timestamp when the status was recorded. Example: \"2023-10-27T10:00:00Z\" <p></p>"},{"location":"specification/#413-taskstate","title":"4.1.3. TaskState","text":"<p>Defines the possible lifecycle states of a Task.</p> Value Description <code>TASK_STATE_UNSPECIFIED</code> The task is in an unknown or indeterminate state. <code>TASK_STATE_SUBMITTED</code> Represents the status that acknowledges a task is created. <code>TASK_STATE_WORKING</code> Represents the status that a task is actively being processed. <code>TASK_STATE_COMPLETED</code> Represents the status a task is finished. This is a terminal state. <code>TASK_STATE_FAILED</code> Represents the status a task is done but failed. This is a terminal state. <code>TASK_STATE_CANCELED</code> Represents the status a task was canceled before it finished. This is a terminal state. <code>TASK_STATE_INPUT_REQUIRED</code> Represents the status that the task requires information to complete. This is an interrupted state. <code>TASK_STATE_REJECTED</code> Represents the status that the agent has decided to not perform the task. This may be done during initial task creation or later once an agent has determined it can't or won't proceed. This is a terminal state. <code>TASK_STATE_AUTH_REQUIRED</code> Represents the state that some authentication is needed from the upstream client. This is an interrupted state. Authentication is expected to come out-of-band. <p></p>"},{"location":"specification/#414-message","title":"4.1.4. Message","text":"<p>Message is one unit of communication between client and server. It can be associated with a context and/or a task. For server messages, context_id must be provided, and task_id only if a task was created. For client messages, both fields are optional, with the caveat that if both are provided, they have to match (the context_id has to be the one that is set on the task). If only task_id is provided, the server will infer context_id from it.</p> Field Type Required Description <code>messageId</code> <code>string</code> Yes The unique identifier (e.g. UUID) of the message. This is required and created by the message creator. <code>contextId</code> <code>string</code> No The context id of the message. This is optional and if set, the message will be associated with the given context. <code>taskId</code> <code>string</code> No The task id of the message. This is optional and if set, the message will be associated with the given task. <code>role</code> <code>Role</code> Yes Identifies the sender of the message. <code>parts</code> array of <code>Part</code> Yes Parts is the container of the message content. <code>metadata</code> <code>object</code> No Any optional metadata to provide along with the message. <code>extensions</code> array of <code>string</code> No The URIs of extensions that are present or contributed to this Message. <code>referenceTaskIds</code> array of <code>string</code> No A list of task IDs that this message references for additional context. <p></p>"},{"location":"specification/#415-role","title":"4.1.5. Role","text":"<p>Defines the sender of a message in A2A protocol communication.</p> Value Description <code>ROLE_UNSPECIFIED</code> <code>ROLE_USER</code> USER role refers to communication from the client to the server. <code>ROLE_AGENT</code> AGENT role refers to communication from the server to the client. <p></p>"},{"location":"specification/#416-part","title":"4.1.6. Part","text":"<p>Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).</p> Field Type Required Description <code>text</code> <code>string</code> No The string content of the text part. <code>raw</code> <code>bytes</code> No The raw byte content of a file. In JSON serialization, this is encoded as a base64 string. <code>url</code> <code>string</code> No A URL pointing to the file's content. <code>data</code> <code>google.protobuf.Value</code> No Arbitrary structured data as a JSON value (object, array, string, number, boolean, or null). <code>metadata</code> <code>object</code> No Optional metadata associated with this part. <code>filename</code> <code>string</code> No An optional name for the file (e.g., \"document.pdf\"). <code>mediaType</code> <code>string</code> No The media type (MIME type) of the part content (e.g., \"text/plain\", \"application/json\", \"image/png\"). This field is available for all part types. <p>Note: A Part MUST contain exactly one of the following: <code>text</code>, <code>raw</code>, <code>url</code>, <code>data</code></p> <p></p>"},{"location":"specification/#417-artifact","title":"4.1.7. Artifact","text":"<p>Artifacts represent task outputs.</p> Field Type Required Description <code>artifactId</code> <code>string</code> Yes Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task. <code>name</code> <code>string</code> No A human readable name for the artifact. <code>description</code> <code>string</code> No A human readable description of the artifact, optional. <code>parts</code> array of <code>Part</code> Yes The content of the artifact. Must contain at least one part. <code>metadata</code> <code>object</code> No Optional metadata included with the artifact. <code>extensions</code> array of <code>string</code> No The URIs of extensions that are present or contributed to this Artifact."},{"location":"specification/#42-streaming-events","title":"4.2. Streaming Events","text":""},{"location":"specification/#421-taskstatusupdateevent","title":"4.2.1. TaskStatusUpdateEvent","text":"<p>An event sent by the agent to notify the client of a change in a task's status.</p> Field Type Required Description <code>taskId</code> <code>string</code> Yes The id of the task that is changed <code>contextId</code> <code>string</code> Yes The id of the context that the task belongs to <code>status</code> <code>TaskStatus</code> Yes The new status of the task. <code>metadata</code> <code>object</code> No Optional metadata to associate with the task update. <p></p>"},{"location":"specification/#422-taskartifactupdateevent","title":"4.2.2. TaskArtifactUpdateEvent","text":"<p>TaskArtifactUpdateEvent represents a task delta where an artifact has been generated.</p> Field Type Required Description <code>taskId</code> <code>string</code> Yes The id of the task for this artifact. <code>contextId</code> <code>string</code> Yes The id of the context that this task belongs to. <code>artifact</code> <code>Artifact</code> Yes The artifact that was generated or updated. <code>append</code> <code>boolean</code> No If true, the content of this artifact should be appended to a previously sent artifact with the same ID. <code>lastChunk</code> <code>boolean</code> No If true, this is the final chunk of the artifact. <code>metadata</code> <code>object</code> No Optional metadata associated with the artifact update."},{"location":"specification/#43-push-notification-objects","title":"4.3. Push Notification Objects","text":""},{"location":"specification/#431-pushnotificationconfig","title":"4.3.1. PushNotificationConfig","text":"<p>Configuration for setting up push notifications for task updates.</p> Field Type Required Description <code>id</code> <code>string</code> No A unique identifier (e.g. UUID) for this push notification. <code>url</code> <code>string</code> Yes Url to send the notification too <code>token</code> <code>string</code> No Token unique for this task/session <code>authentication</code> <code>AuthenticationInfo</code> No Authentication information required to send the notification <p></p>"},{"location":"specification/#432-authenticationinfo","title":"4.3.2. AuthenticationInfo","text":"<p>Defines authentication details, used for push notifications.</p> Field Type Required Description <code>scheme</code> <code>string</code> Yes HTTP Authentication Scheme from the IANA registry. Common values: <code>Bearer</code>, <code>Basic</code>, <code>Digest</code>. Scheme names are case-insensitive per RFC 9110 Section 11.1. <code>credentials</code> <code>string</code> No Push Notification credentials. Format depends on the scheme (e.g., token for Bearer)."},{"location":"specification/#433-push-notification-payload","title":"4.3.3. Push Notification Payload","text":"<p>When a task update occurs, the agent sends an HTTP POST request to the configured webhook URL. The payload uses the same <code>StreamResponse</code> format as streaming operations, allowing push notifications to deliver the same event types as real-time streams.</p> <p>Request Format:</p> <pre><code>POST {webhook_url}\nAuthorization: {authentication_scheme} {credentials}\nContent-Type: application/json\n\n{\n  /* StreamResponse object - one of: */\n  \"task\": { /* Task object */ },\n  \"message\": { /* Message object */ },\n  \"statusUpdate\": { /* TaskStatusUpdateEvent object */ },\n  \"artifactUpdate\": { /* TaskArtifactUpdateEvent object */ }\n}\n</code></pre> <p>Payload Structure:</p> <p>The webhook payload is a <code>StreamResponse</code> object containing exactly one of the following:</p> <ul> <li>task: A <code>Task</code> object with the current task state</li> <li>message: A <code>Message</code> object containing a message response</li> <li>statusUpdate: A <code>TaskStatusUpdateEvent</code> indicating a status change</li> <li>artifactUpdate: A <code>TaskArtifactUpdateEvent</code> indicating artifact updates</li> </ul> <p>Authentication:</p> <p>The agent MUST include authentication credentials in the request headers as specified in the <code>PushNotificationConfig.authentication</code> field. The format follows standard HTTP authentication patterns (Bearer tokens, Basic auth, etc.).</p> <p>Client Responsibilities:</p> <ul> <li>Clients MUST respond with HTTP 2xx status codes to acknowledge successful receipt</li> <li>Clients SHOULD process notifications idempotently, as duplicate deliveries may occur</li> <li>Clients MUST validate the task ID matches an expected task</li> <li>Clients SHOULD implement appropriate security measures to verify the notification source</li> </ul> <p>Server Guarantees:</p> <ul> <li>Agents MUST attempt delivery at least once for each configured webhook</li> <li>Agents MAY implement retry logic with exponential backoff for failed deliveries</li> <li>Agents SHOULD include a reasonable timeout for webhook requests (recommended: 10-30 seconds)</li> <li>Agents MAY stop attempting delivery after a configured number of consecutive failures</li> </ul> <p>For detailed security guidance on push notifications, see Section 13.2 Push Notification Security.</p>"},{"location":"specification/#44-agent-discovery-objects","title":"4.4. Agent Discovery Objects","text":""},{"location":"specification/#441-agentcard","title":"4.4.1. AgentCard","text":"<p>AgentCard is a self-describing manifest for an agent. It provides essential metadata including the agent's identity, capabilities, skills, supported communication methods, and security requirements.</p> Field Type Required Description <code>protocolVersions</code> array of <code>string</code> Yes The versions of the A2A protocol this agent supports. For stable versions (1.x+), list only the latest supported minor version per major version. For legacy experimental versions (0.x), explicitly list each supported version. Default: [\"1.0\"] <code>name</code> <code>string</code> Yes A human readable name for the agent. Example: \"Recipe Agent\" <code>description</code> <code>string</code> Yes A human-readable description of the agent, assisting users and other agents in understanding its purpose. Example: \"Agent that helps users with recipes and cooking.\" <code>supportedInterfaces</code> array of <code>AgentInterface</code> Yes Ordered list of supported interfaces. First entry is preferred. <code>provider</code> <code>AgentProvider</code> No The service provider of the agent. <code>version</code> <code>string</code> Yes The version of the agent. Example: \"1.0.0\" <code>documentationUrl</code> <code>string</code> Optional A url to provide additional documentation about the agent. <code>capabilities</code> <code>AgentCapabilities</code> Yes A2A Capability set supported by the agent. <code>securitySchemes</code> map of <code>SecurityScheme</code> No The security scheme details used for authenticating with this agent. <code>security</code> array of <code>Security</code> No Security requirements for contacting the agent. <code>defaultInputModes</code> array of <code>string</code> Yes The set of interaction modes that the agent supports across all skills. This can be overridden per skill. Defined as media types. <code>defaultOutputModes</code> array of <code>string</code> Yes The media types supported as outputs from this agent. <code>skills</code> array of <code>AgentSkill</code> Yes Skills represent an ability of an agent. It is largely a descriptive concept but represents a more focused set of behaviors that the agent is likely to succeed at. <code>signatures</code> array of <code>AgentCardSignature</code> No JSON Web Signatures computed for this AgentCard. <code>iconUrl</code> <code>string</code> Optional An optional URL to an icon for the agent. <p></p>"},{"location":"specification/#442-agentprovider","title":"4.4.2. AgentProvider","text":"<p>Represents the service provider of an agent.</p> Field Type Required Description <code>url</code> <code>string</code> Yes A URL for the agent provider's website or relevant documentation. Example: \"https://ai.google.dev\" <code>organization</code> <code>string</code> Yes The name of the agent provider's organization. Example: \"Google\" <p></p>"},{"location":"specification/#443-agentcapabilities","title":"4.4.3. AgentCapabilities","text":"<p>Defines optional capabilities supported by an agent.</p> Field Type Required Description <code>streaming</code> <code>boolean</code> Optional Indicates if the agent supports streaming responses. <code>pushNotifications</code> <code>boolean</code> Optional Indicates if the agent supports sending push notifications for asynchronous task updates. <code>extensions</code> array of <code>AgentExtension</code> No A list of protocol extensions supported by the agent. <code>extendedAgentCard</code> <code>boolean</code> Optional Indicates if the agent supports providing an extended agent card when authenticated. <p></p>"},{"location":"specification/#444-agentextension","title":"4.4.4. AgentExtension","text":"<p>A declaration of a protocol extension supported by an Agent.</p> Field Type Required Description <code>uri</code> <code>string</code> No The unique URI identifying the extension. <code>description</code> <code>string</code> No A human-readable description of how this agent uses the extension. <code>required</code> <code>boolean</code> No If true, the client must understand and comply with the extension's requirements. <code>params</code> <code>object</code> No Optional, extension-specific configuration parameters. <p></p>"},{"location":"specification/#445-agentskill","title":"4.4.5. AgentSkill","text":"<p>Represents a distinct capability or function that an agent can perform.</p> Field Type Required Description <code>id</code> <code>string</code> Yes A unique identifier for the agent's skill. <code>name</code> <code>string</code> Yes A human-readable name for the skill. <code>description</code> <code>string</code> Yes A detailed description of the skill. <code>tags</code> array of <code>string</code> Yes A set of keywords describing the skill's capabilities. <code>examples</code> array of <code>string</code> No Example prompts or scenarios that this skill can handle. <code>inputModes</code> array of <code>string</code> No The set of supported input media types for this skill, overriding the agent's defaults. <code>outputModes</code> array of <code>string</code> No The set of supported output media types for this skill, overriding the agent's defaults. <code>security</code> array of <code>Security</code> No Security schemes necessary for this skill. <p></p>"},{"location":"specification/#446-agentinterface","title":"4.4.6. AgentInterface","text":"<p>Declares a combination of a target URL and a transport protocol for interacting with the agent. This allows agents to expose the same functionality over multiple protocol binding mechanisms.</p> Field Type Required Description <code>url</code> <code>string</code> Yes The URL where this interface is available. Must be a valid absolute HTTPS URL in production. Example: \"https://api.example.com/a2a/v1\", \"https://grpc.example.com/a2a\" <code>protocolBinding</code> <code>string</code> Yes The protocol binding supported at this URL. This is an open form string, to be easily extended for other protocol bindings. The core ones officially supported are <code>JSONRPC</code>, <code>GRPC</code> and <code>HTTP+JSON</code>. <code>tenant</code> <code>string</code> No Tenant to be set in the request when calling the agent. <p></p>"},{"location":"specification/#447-agentcardsignature","title":"4.4.7. AgentCardSignature","text":"<p>AgentCardSignature represents a JWS signature of an AgentCard. This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).</p> Field Type Required Description <code>protected</code> <code>string</code> Yes The protected JWS header for the signature. This is always a base64url-encoded JSON object. Required. <code>signature</code> <code>string</code> Yes The computed signature, base64url-encoded. Required. <code>header</code> <code>object</code> No The unprotected JWS header values."},{"location":"specification/#45-security-objects","title":"4.5. Security Objects","text":""},{"location":"specification/#451-securityscheme","title":"4.5.1. SecurityScheme","text":"<p>Defines a security scheme that can be used to secure an agent's endpoints. This is a discriminated union type based on the OpenAPI 3.2 Security Scheme Object. See: https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object</p> Field Type Required Description <code>apiKeySecurityScheme</code> <code>APIKeySecurityScheme</code> No API key-based authentication. <code>httpAuthSecurityScheme</code> <code>HTTPAuthSecurityScheme</code> No HTTP authentication (Basic, Bearer, etc.). <code>oauth2SecurityScheme</code> <code>OAuth2SecurityScheme</code> No OAuth 2.0 authentication. <code>openIdConnectSecurityScheme</code> <code>OpenIdConnectSecurityScheme</code> No OpenID Connect authentication. <code>mtlsSecurityScheme</code> <code>MutualTlsSecurityScheme</code> No Mutual TLS authentication. <p>Note: A SecurityScheme MUST contain exactly one of the following: <code>apiKeySecurityScheme</code>, <code>httpAuthSecurityScheme</code>, <code>oauth2SecurityScheme</code>, <code>openIdConnectSecurityScheme</code>, <code>mtlsSecurityScheme</code></p> <p></p>"},{"location":"specification/#452-apikeysecurityscheme","title":"4.5.2. APIKeySecurityScheme","text":"<p>Defines a security scheme using an API key.</p> Field Type Required Description <code>description</code> <code>string</code> No An optional description for the security scheme. <code>location</code> <code>string</code> Yes The location of the API key. Valid values are \"query\", \"header\", or \"cookie\". <code>name</code> <code>string</code> Yes The name of the header, query, or cookie parameter to be used. <p></p>"},{"location":"specification/#453-httpauthsecurityscheme","title":"4.5.3. HTTPAuthSecurityScheme","text":"<p>Defines a security scheme using HTTP authentication.</p> Field Type Required Description <code>description</code> <code>string</code> No An optional description for the security scheme. <code>scheme</code> <code>string</code> Yes The name of the HTTP Authentication scheme to be used in the Authorization header, as defined in RFC7235 (e.g., \"Bearer\"). This value should be registered in the IANA Authentication Scheme registry. <code>bearerFormat</code> <code>string</code> No A hint to the client to identify how the bearer token is formatted (e.g., \"JWT\"). This is primarily for documentation purposes. <p></p>"},{"location":"specification/#454-oauth2securityscheme","title":"4.5.4. OAuth2SecurityScheme","text":"<p>Defines a security scheme using OAuth 2.0.</p> Field Type Required Description <code>description</code> <code>string</code> No An optional description for the security scheme. <code>flows</code> <code>OAuthFlows</code> Yes An object containing configuration information for the supported OAuth 2.0 flows. <code>oauth2MetadataUrl</code> <code>string</code> No URL to the oauth2 authorization server metadata RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required. <p></p>"},{"location":"specification/#455-openidconnectsecurityscheme","title":"4.5.5. OpenIdConnectSecurityScheme","text":"<p>Defines a security scheme using OpenID Connect.</p> Field Type Required Description <code>description</code> <code>string</code> No An optional description for the security scheme. <code>openIdConnectUrl</code> <code>string</code> Yes The OpenID Connect Discovery URL for the OIDC provider's metadata. See: https://openid.net/specs/openid-connect-discovery-1_0.html <p></p>"},{"location":"specification/#456-mutualtlssecurityscheme","title":"4.5.6. MutualTLSSecurityScheme","text":"<p>Error: Message 'MutualTlsSecurityScheme' not found in specification/grpc/a2a.proto</p> <p></p>"},{"location":"specification/#457-oauthflows","title":"4.5.7. OAuthFlows","text":"<p>Defines the configuration for the supported OAuth 2.0 flows.</p> Field Type Required Description <code>authorizationCode</code> <code>AuthorizationCodeOAuthFlow</code> No Configuration for the OAuth Authorization Code flow. <code>clientCredentials</code> <code>ClientCredentialsOAuthFlow</code> No Configuration for the OAuth Client Credentials flow. <code>deviceCode</code> <code>DeviceCodeOAuthFlow</code> No Configuration for the OAuth Device Code flow. <p>Note: A OAuthFlows MUST contain exactly one of the following: <code>authorizationCode</code>, <code>clientCredentials</code>, <code>deviceCode</code></p> <p></p>"},{"location":"specification/#458-authorizationcodeoauthflow","title":"4.5.8. AuthorizationCodeOAuthFlow","text":"<p>Defines configuration details for the OAuth 2.0 Authorization Code flow.</p> Field Type Required Description <code>authorizationUrl</code> <code>string</code> Yes The authorization URL to be used for this flow. <code>tokenUrl</code> <code>string</code> Yes The token URL to be used for this flow. <code>refreshUrl</code> <code>string</code> No The URL to be used for obtaining refresh tokens. <code>scopes</code> map of <code>string</code> Yes The available scopes for the OAuth2 security scheme. <code>pkceRequired</code> <code>boolean</code> No Indicates if PKCE (RFC 7636) is required for this flow. PKCE should always be used for public clients and is recommended for all clients. <p></p>"},{"location":"specification/#459-clientcredentialsoauthflow","title":"4.5.9. ClientCredentialsOAuthFlow","text":"<p>Defines configuration details for the OAuth 2.0 Client Credentials flow.</p> Field Type Required Description <code>tokenUrl</code> <code>string</code> Yes The token URL to be used for this flow. <code>refreshUrl</code> <code>string</code> No The URL to be used for obtaining refresh tokens. <code>scopes</code> map of <code>string</code> Yes The available scopes for the OAuth2 security scheme. <p></p>"},{"location":"specification/#4510-devicecodeoauthflow","title":"4.5.10. DeviceCodeOAuthFlow","text":"<p>Defines configuration details for the OAuth 2.0 Device Code flow (RFC 8628). This flow is designed for input-constrained devices such as IoT devices, and CLI tools where the user authenticates on a separate device.</p> Field Type Required Description <code>deviceAuthorizationUrl</code> <code>string</code> Yes The device authorization endpoint URL. <code>tokenUrl</code> <code>string</code> Yes The token URL to be used for this flow. <code>refreshUrl</code> <code>string</code> No The URL to be used for obtaining refresh tokens. <code>scopes</code> map of <code>string</code> Yes The available scopes for the OAuth2 security scheme."},{"location":"specification/#46-extensions","title":"4.6. Extensions","text":"<p>The A2A protocol supports extensions to provide additional functionality or data beyond the core specification while maintaining backward compatibility and interoperability. Extensions allow agents to declare additional capabilities such as protocol enhancements or vendor-specific features, maintain compatibility with clients that don't support specific extensions, enable innovation through experimental or domain-specific features without modifying the core protocol, and facilitate standardization by providing a pathway for community-developed features to become part of the core specification.</p>"},{"location":"specification/#461-extension-declaration","title":"4.6.1. Extension Declaration","text":"<p>Agents declare their supported extensions in the <code>AgentCard</code> using the <code>extensions</code> field, which contains an array of <code>AgentExtension</code> objects.</p> <p>Example: Agent declaring extension support in AgentCard:</p> <pre><code>{\n  \"protocolVersions\": [\"0.3\"],\n  \"name\": \"Research Assistant Agent\",\n  \"description\": \"AI agent for academic research and fact-checking\",\n  \"supportedInterfaces\": [\n    {\n      \"url\": \"https://research-agent.example.com/a2a/v1\",\n      \"protocolBinding\": \"HTTP+JSON\"\n    }\n  ],\n  \"capabilities\": {\n    \"streaming\": false,\n    \"pushNotifications\": false,\n    \"extensions\": [\n      {\n        \"uri\": \"https://standards.org/extensions/citations/v1\",\n        \"description\": \"Provides citation formatting and source verification\",\n        \"required\": false\n      },\n      {\n        \"uri\": \"https://example.com/extensions/geolocation/v1\",\n        \"description\": \"Location-based search capabilities\",\n        \"required\": false\n      }\n    ]\n  },\n  \"defaultInputModes\": [\"text/plain\"],\n  \"defaultOutputModes\": [\"text/plain\"],\n  \"skills\": [\n    {\n      \"id\": \"academic-research\",\n      \"name\": \"Academic Research Assistant\",\n      \"description\": \"Provides research assistance with citations and source verification\",\n      \"tags\": [\"research\", \"citations\", \"academic\"],\n      \"examples\": [\"Find peer-reviewed articles on climate change\"],\n      \"inputModes\": [\"text/plain\"],\n      \"outputModes\": [\"text/plain\"]\n    }\n  ]\n}\n</code></pre> <p>Clients indicate their desire to opt into the use of specific extensions through binding-specific mechanisms such as HTTP headers, gRPC metadata, or JSON-RPC request parameters that identify the extension identifiers they wish to utilize during the interaction.</p> <p>Example: HTTP client opting into extensions using headers:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\nAuthorization: Bearer token\nA2A-Extensions: https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"Find restaurants near me\"}],\n    \"extensions\": [\"https://example.com/extensions/geolocation/v1\"],\n    \"metadata\": {\n      \"https://example.com/extensions/geolocation/v1\": {\n        \"latitude\": 37.7749,\n        \"longitude\": -122.4194\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"specification/#462-extensions-points","title":"4.6.2. Extensions Points","text":"<p>Extensions can be integrated into the A2A protocol at several well-defined extension points:</p> <p>Message Extensions:</p> <p>Messages can be extended to allow clients to provide additional strongly typed context or parameters relevant to the message being sent, or TaskStatus Messages to include extra information about the task's progress.</p> <p>Example: A location extension using the extensions and metadata arrays:</p> <pre><code>{\n  \"role\": \"ROLE_USER\",\n  \"parts\": [\n    {\"text\": \"Find restaurants near me\"}\n  ],\n  \"extensions\": [\"https://example.com/extensions/geolocation/v1\"],\n  \"metadata\": {\n    \"https://example.com/extensions/geolocation/v1\": {\n      \"latitude\": 37.7749,\n      \"longitude\": -122.4194,\n      \"accuracy\": 10.0,\n      \"timestamp\": \"2025-10-21T14:30:00Z\"\n    }\n  }\n}\n</code></pre> <p>Artifact Extensions:</p> <p>Artifacts can include extension data to provide strongly typed context or metadata about the generated content.</p> <p>Example: An artifact with citation extension for research sources:</p> <pre><code>{\n  \"artifactId\": \"research-summary-001\",\n  \"name\": \"Climate Change Summary\",\n  \"parts\": [\n    {\n      \"text\": \"Global temperatures have risen by 1.1\u00b0C since pre-industrial times, with significant impacts on weather patterns and sea levels.\"\n    }\n  ],\n  \"extensions\": [\"https://standards.org/extensions/citations/v1\"],\n  \"metadata\": {\n    \"https://standards.org/extensions/citations/v1\": {\n      \"sources\": [\n        {\n          \"title\": \"Global Temperature Anomalies - 2023 Report\",\n          \"authors\": [\"Smith, J.\", \"Johnson, M.\"],\n          \"url\": \"https://climate.gov/reports/2023-temperature\",\n          \"accessDate\": \"2025-10-21\",\n          \"relevantText\": \"Global temperatures have risen by 1.1\u00b0C\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"specification/#463-extension-versioning-and-compatibility","title":"4.6.3. Extension Versioning and Compatibility","text":"<p>Extensions SHOULD include version information in their URI identifier. This allows clients and agents to negotiate compatible versions of extensions during interactions. A new URI MUST be created for breaking changes to an extension.</p> <p>If a client requests a versions of an extension that the agent does not support, the agent SHOULD ignore the extension for that interaction and proceed without it, unless the extension is marked as <code>required</code> in the AgentCard, in which case the agent MUST return an error indicating unsupported extension. It MUST NOT fall back to a previous version of the extension automatically.</p>"},{"location":"specification/#5-protocol-binding-requirements-and-interoperability","title":"5. Protocol Binding Requirements and Interoperability","text":""},{"location":"specification/#51-functional-equivalence-requirements","title":"5.1. Functional Equivalence Requirements","text":"<p>When an agent supports multiple protocols, all supported protocols MUST:</p> <ul> <li>Identical Functionality: Provide the same set of operations and capabilities</li> <li>Consistent Behavior: Return semantically equivalent results for the same requests</li> <li>Same Error Handling: Map errors consistently using appropriate protocol-specific codes</li> <li>Equivalent Authentication: Support the same authentication schemes declared in the AgentCard</li> </ul>"},{"location":"specification/#52-protocol-selection-and-negotiation","title":"5.2. Protocol Selection and Negotiation","text":"<ul> <li>Agent Declaration: Agents MUST declare all supported protocols in their AgentCard</li> <li>Client Choice: Clients MAY choose any protocol declared by the agent</li> <li>No Dynamic Negotiation: A2A does not define runtime protocol negotiation</li> <li>Fallback Behavior: Clients SHOULD implement fallback logic for alternative protocols</li> </ul>"},{"location":"specification/#53-method-mapping-reference","title":"5.3. Method Mapping Reference","text":"Functionality JSON-RPC Method gRPC Method REST Endpoint Send message <code>SendMessage</code> <code>SendMessage</code> <code>POST /message:send</code> Stream message <code>SendStreamingMessage</code> <code>SendStreamingMessage</code> <code>POST /message:stream</code> Get task <code>GetTask</code> <code>GetTask</code> <code>GET /tasks/{id}</code> List tasks <code>ListTasks</code> <code>ListTasks</code> <code>GET /tasks</code> Cancel task <code>CancelTask</code> <code>CancelTask</code> <code>POST /tasks/{id}:cancel</code> Subscribe to task <code>SubscribeToTask</code> <code>SubscribeToTask</code> <code>POST /tasks/{id}:subscribe</code> Create push notification config <code>CreateTaskPushNotificationConfig</code> <code>CreateTaskPushNotificationConfig</code> <code>POST /tasks/{id}/pushNotificationConfigs</code> Get push notification config <code>GetTaskPushNotificationConfig</code> <code>GetTaskPushNotificationConfig</code> <code>GET /tasks/{id}/pushNotificationConfigs/{configId}</code> List push notification configs <code>ListTaskPushNotificationConfig</code> <code>ListTaskPushNotificationConfig</code> <code>GET /tasks/{id}/pushNotificationConfigs</code> Delete push notification config <code>DeleteTaskPushNotificationConfig</code> <code>DeleteTaskPushNotificationConfig</code> <code>DELETE /tasks/{id}/pushNotificationConfigs/{configId}</code> Get extended Agent Card <code>GetExtendedAgentCard</code> <code>GetExtendedAgentCard</code> <code>GET /extendedAgentCard</code>"},{"location":"specification/#54-error-code-mappings","title":"5.4. Error Code Mappings","text":"<p>All A2A-specific errors defined in Section 3.3.2 MUST be mapped to binding-specific error representations. The following table provides the canonical mappings for each standard protocol binding:</p> A2A Error Type JSON-RPC Code gRPC Status HTTP Status HTTP Type URI <code>TaskNotFoundError</code> <code>-32001</code> <code>NOT_FOUND</code> <code>404 Not Found</code> <code>https://a2a-protocol.org/errors/task-not-found</code> <code>TaskNotCancelableError</code> <code>-32002</code> <code>FAILED_PRECONDITION</code> <code>409 Conflict</code> <code>https://a2a-protocol.org/errors/task-not-cancelable</code> <code>PushNotificationNotSupportedError</code> <code>-32003</code> <code>UNIMPLEMENTED</code> <code>400 Bad Request</code> <code>https://a2a-protocol.org/errors/push-notification-not-supported</code> <code>UnsupportedOperationError</code> <code>-32004</code> <code>UNIMPLEMENTED</code> <code>400 Bad Request</code> <code>https://a2a-protocol.org/errors/unsupported-operation</code> <code>ContentTypeNotSupportedError</code> <code>-32005</code> <code>INVALID_ARGUMENT</code> <code>415 Unsupported Media Type</code> <code>https://a2a-protocol.org/errors/content-type-not-supported</code> <code>InvalidAgentResponseError</code> <code>-32006</code> <code>INTERNAL</code> <code>502 Bad Gateway</code> <code>https://a2a-protocol.org/errors/invalid-agent-response</code> <code>ExtendedAgentCardNotConfiguredError</code> <code>-32007</code> <code>FAILED_PRECONDITION</code> <code>400 Bad Request</code> <code>https://a2a-protocol.org/errors/extended-agent-card-not-configured</code> <code>ExtensionSupportRequiredError</code> <code>-32008</code> <code>FAILED_PRECONDITION</code> <code>400 Bad Request</code> <code>https://a2a-protocol.org/errors/extension-support-required</code> <code>VersionNotSupportedError</code> <code>-32009</code> <code>UNIMPLEMENTED</code> <code>400 Bad Request</code> <code>https://a2a-protocol.org/errors/version-not-supported</code> <p>Custom Binding Requirements:</p> <p>Custom protocol bindings MUST define equivalent error code mappings that preserve the semantic meaning of each A2A error type. The binding specification SHOULD provide a similar mapping table showing how each A2A error type is represented in the custom binding's native error format.</p> <p>For binding-specific error structures and examples, see:</p> <ul> <li>JSON-RPC Error Handling</li> <li>gRPC Error Handling</li> <li>HTTP/REST Error Handling</li> </ul>"},{"location":"specification/#55-json-field-naming-convention","title":"5.5. JSON Field Naming Convention","text":"<p>All JSON serializations of the A2A protocol data model MUST use camelCase naming for field names, not the snake_case convention used in Protocol Buffer definitions.</p> <p>Naming Convention:</p> <ul> <li>Protocol Buffer field: <code>protocol_versions</code> \u2192 JSON field: <code>protocolVersions</code></li> <li>Protocol Buffer field: <code>context_id</code> \u2192 JSON field: <code>contextId</code></li> <li>Protocol Buffer field: <code>default_input_modes</code> \u2192 JSON field: <code>defaultInputModes</code></li> <li>Protocol Buffer field: <code>push_notification_config</code> \u2192 JSON field: <code>pushNotificationConfig</code></li> </ul> <p>Enum Values:</p> <ul> <li>Enum values MUST be represented according to the ProtoJSON specification, which serializes enums as their string names as defined in the Protocol Buffer definition (typically SCREAMING_SNAKE_CASE).</li> </ul> <p>Examples:</p> <ul> <li>Protocol Buffer enum: <code>TASK_STATE_INPUT_REQUIRED</code> \u2192 JSON value: <code>\"TASK_STATE_INPUT_REQUIRED\"</code></li> <li>Protocol Buffer enum: <code>ROLE_USER</code> \u2192 JSON value: <code>\"ROLE_USER\"</code></li> </ul> <p>Note: This follows the ProtoJSON specification as adopted in ADR-001.</p>"},{"location":"specification/#56-data-type-conventions","title":"5.6. Data Type Conventions","text":"<p>This section documents conventions for common data types used throughout the A2A protocol, particularly as they apply to protocol bindings.</p>"},{"location":"specification/#561-timestamps","title":"5.6.1. Timestamps","text":"<p>The A2A protocol uses <code>google.protobuf.Timestamp</code> for all timestamp fields in the Protocol Buffer definitions. When serialized to JSON (in JSON-RPC, HTTP/REST, or other JSON-based bindings), these timestamps MUST be represented as ISO 8601 formatted strings in UTC timezone.</p> <p>Format Requirements:</p> <ul> <li>Format: ISO 8601 combined date and time representation</li> <li>Timezone: UTC (denoted by 'Z' suffix)</li> <li>Precision: Millisecond precision SHOULD be used where available</li> <li>Pattern: <code>YYYY-MM-DDTHH:mm:ss.sssZ</code></li> </ul> <p>Examples:</p> <pre><code>{\n  \"timestamp\": \"2025-10-28T10:30:00.000Z\",\n  \"createdAt\": \"2025-10-28T14:25:33.142Z\",\n  \"lastModified\": \"2025-10-31T17:45:22.891Z\"\n}\n</code></pre> <p>Implementation Notes:</p> <ul> <li>Protocol Buffer's <code>google.protobuf.Timestamp</code> represents time as seconds since Unix epoch (January 1, 1970, 00:00:00 UTC) plus nanoseconds</li> <li>JSON serialization automatically converts this to ISO 8601 format when using standard Protocol Buffer JSON encoding</li> <li>Clients and servers MUST parse and generate ISO 8601 timestamps correctly</li> <li>When millisecond precision is not available, the fractional seconds portion MAY be omitted or zero-filled</li> <li>Timestamps MUST NOT include timezone offsets other than 'Z' (all times are UTC)</li> </ul>"},{"location":"specification/#57-field-presence-and-optionality","title":"5.7. Field Presence and Optionality","text":"<p>The Protocol Buffer definition in <code>specification/grpc/a2a.proto</code> uses <code>google.api.field_behavior</code> annotations to indicate whether fields are <code>REQUIRED</code>. These annotations serve as both documentation and validation hints for implementations.</p> <p>Required Fields:</p> <p>Fields marked with <code>[(google.api.field_behavior) = REQUIRED]</code> indicate that the field MUST be present and set in valid messages. Implementations SHOULD validate these requirements and reject messages with missing required fields. Arrays marked as required MUST contain at least one element.</p> <p>Optional Field Presence:</p> <p>The Protocol Buffer <code>optional</code> keyword is used to distinguish between a field being explicitly set versus omitted. This distinction is critical for two scenarios:</p> <ol> <li> <p>Explicit Default Values: Some fields in the specification define default values that differ from Protocol Buffer's implicit defaults (e.g., <code>protocolVersions</code> defaults to <code>[\"1.0\"]</code> rather than an empty array). Implementations should apply the default value when the field is not explicitly provided.</p> </li> <li> <p>Agent Card Canonicalization: When creating cryptographic signatures of Agent Cards, it is required to produce a canonical JSON representation. The <code>optional</code> keyword enables implementations to distinguish between fields that were explicitly set (and should be included in the canonical form) versus fields that were omitted (and should be excluded from canonicalization). This ensures Agent Cards can be reconstructed to accurately match their signature.</p> </li> </ol> <p>Unrecognized Fields:</p> <p>Implementations SHOULD ignore unrecognized fields in messages, allowing for forward compatibility as the protocol evolves.</p>"},{"location":"specification/#6-common-workflows-examples","title":"6. Common Workflows &amp; Examples","text":"<p>This section provides illustrative examples of common A2A interactions across different bindings.</p>"},{"location":"specification/#61-basic-task-execution","title":"6.1. Basic Task Execution","text":"<p>Scenario: Client asks a question and receives a completed task response.</p> <p>Request:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"What is the weather today?\"}],\n    \"messageId\": \"msg-uuid\"\n  }\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"task\": {\n    \"id\": \"task-uuid\",\n    \"contextId\": \"context-uuid\",\n    \"status\": {\"state\": \"TASK_STATE_COMPLETED\"},\n    \"artifacts\": [{\n      \"artifactId\": \"artifact-uuid\",\n      \"name\": \"Weather Report\",\n      \"parts\": [{\"text\": \"Today will be sunny with a high of 75\u00b0F\"}]\n    }]\n  }\n}\n</code></pre>"},{"location":"specification/#62-streaming-task-execution","title":"6.2. Streaming Task Execution","text":"<p>Scenario: Client requests a long-running task with real-time updates.</p> <p>Request:</p> <pre><code>POST /message:stream HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"Write a detailed report on climate change\"}],\n    \"messageId\": \"msg-uuid\"\n  }\n}\n</code></pre> <p>SSE Response Stream:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\n\ndata: {\"task\": {\"id\": \"task-uuid\", \"status\": {\"state\": \"TASK_STATE_WORKING\"}}}\n\ndata: {\"artifactUpdate\": {\"taskId\": \"task-uuid\", \"artifact\": {\"parts\": [{\"text\": \"# Climate Change Report\\n\\n\"}]}}}\n\ndata: {\"statusUpdate\": {\"taskId\": \"task-uuid\", \"status\": {\"state\": \"TASK_STATE_COMPLETED\"}, \"final\": true}}\n</code></pre>"},{"location":"specification/#63-multi-turn-interaction","title":"6.3. Multi-Turn Interaction","text":"<p>Scenario: Agent requires additional input to complete a task.</p> <p>Initial Request:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"Book me a flight\"}],\n    \"messageId\": \"msg-1\"\n  }\n}\n</code></pre> <p>Response (Input Required):</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"task\": {\n    \"id\": \"task-uuid\",\n    \"status\": {\n      \"state\": \"TASK_STATE_INPUT_REQUIRED\",\n      \"message\": {\n        \"role\": \"ROLE_AGENT\",\n        \"parts\": [{\"text\": \"I need more details. Where would you like to fly from and to?\"}]\n      }\n    }\n  }\n}\n</code></pre> <p>Follow-up Request:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"taskId\": \"task-uuid\",\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"From San Francisco to New York\"}],\n    \"messageId\": \"msg-2\"\n  }\n}\n</code></pre>"},{"location":"specification/#64-version-negotiation-error","title":"6.4. Version Negotiation Error","text":"<p>Scenario: Client requests an unsupported protocol version.</p> <p>Request:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\nA2A-Version: 0.5\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"Hello\"}],\n    \"messageId\": \"msg-uuid\"\n  }\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: application/problem+json\n\n{\n  \"type\": \"https://a2a-protocol.org/errors/version-not-supported\",\n  \"title\": \"Protocol Version Not Supported\",\n  \"status\": 400,\n  \"detail\": \"The requested A2A protocol version 0.5 is not supported by this agent\",\n  \"supportedVersions\": [\"0.3\"]\n}\n</code></pre>"},{"location":"specification/#65-task-listing-and-management","title":"6.5. Task Listing and Management","text":"<p>Scenario: Client wants to see all tasks from a specific context or all tasks with a particular status.</p>"},{"location":"specification/#request-all-tasks-from-a-specific-context","title":"Request: All tasks from a specific context","text":"<p>Request:</p> <pre><code>POST /tasks/list HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n  \"pageSize\": 10,\n  \"historyLength\": 3\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"tasks\": [\n    {\n      \"id\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n      \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n      \"status\": {\n        \"state\": \"TASK_STATE_COMPLETED\",\n        \"timestamp\": \"2024-03-15T10:15:00Z\"\n      }\n    }\n  ],\n  \"totalSize\": 5,\n  \"pageSize\": 10,\n  \"nextPageToken\": \"\"\n}\n</code></pre>"},{"location":"specification/#request-all-working-tasks-across-all-contexts","title":"Request: All working tasks across all contexts","text":"<p>Request:</p> <pre><code>POST /tasks/list HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"status\": \"TASK_STATE_WORKING\",\n  \"pageSize\": 20\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"tasks\": [\n    {\n      \"id\": \"789abc-def0-1234-5678-9abcdef01234\",\n      \"contextId\": \"another-context-id\",\n      \"status\": {\n        \"state\": \"TASK_STATE_WORKING\",\n        \"message\": {\n          \"role\": \"ROLE_AGENT\",\n          \"parts\": [\n            {\n              \"text\": \"Processing your document analysis...\"\n            }\n          ],\n          \"messageId\": \"msg-status-update\"\n        },\n        \"timestamp\": \"2024-03-15T10:20:00Z\"\n      }\n    }\n  ],\n  \"totalSize\": 1,\n  \"pageSize\": 20,\n  \"nextPageToken\": \"\"\n}\n</code></pre>"},{"location":"specification/#pagination-example","title":"Pagination Example","text":"<p>Request:</p> <pre><code>POST /tasks/list HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n  \"pageSize\": 10,\n  \"pageToken\": \"base64-encoded-cursor-token\"\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"tasks\": [\n    /* ... additional tasks */\n  ],\n  \"totalSize\": 15,\n  \"pageSize\": 10,\n  \"nextPageToken\": \"base64-encoded-next-cursor-token\"\n}\n</code></pre>"},{"location":"specification/#validation-error-example","title":"Validation Error Example","text":"<p>Request:</p> <pre><code>POST /tasks/list HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"pageSize\": 150,\n  \"historyLength\": -5,\n  \"status\": \"running\"\n}\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: application/problem+json\n\n{\n  \"status\": 400,\n  \"detail\": \"Invalid parameters\",\n  \"errors\": [\n    {\n      \"field\": \"pageSize\",\n      \"message\": \"Must be between 1 and 100 inclusive, got 150\"\n    },\n    {\n      \"field\": \"historyLength\",\n      \"message\": \"Must be non-negative integer, got -5\"\n    },\n    {\n      \"field\": \"status\",\n      \"message\": \"Invalid status value 'running'. Must be one of: pending, working, completed, failed, canceled\"\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#66-push-notification-setup-and-usage","title":"6.6. Push Notification Setup and Usage","text":"<p>Scenario: Client requests a long-running report generation and wants to be notified via webhook when it's done.</p> <p>Initial Request with Push Notification Config:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [\n      {\n        \"text\": \"Generate the Q1 sales report. This usually takes a while. Notify me when it's ready.\"\n      }\n    ],\n    \"messageId\": \"6dbc13b5-bd57-4c2b-b503-24e381b6c8d6\"\n  },\n  \"configuration\": {\n    \"pushNotificationConfig\": {\n      \"url\": \"https://client.example.com/webhook/a2a-notifications\",\n      \"token\": \"secure-client-token-for-task-aaa\",\n      \"authentication\": {\n        \"schemes\": [\"Bearer\"]\n      }\n    }\n  }\n}\n</code></pre> <p>Response (Task Submitted):</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"task\": {\n    \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"submitted\",\n      \"timestamp\": \"2024-03-15T11:00:00Z\"\n    }\n  }\n}\n</code></pre> <p>Later: Server POSTs Notification to Webhook:</p> <pre><code>POST /webhook/a2a-notifications HTTP/1.1\nHost: client.example.com\nAuthorization: Bearer server-generated-jwt\nContent-Type: application/a2a+json\nX-A2A-Notification-Token: secure-client-token-for-task-aaa\n\n{\n  \"statusUpdate\": {\n    \"taskId\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"TASK_STATE_COMPLETED\",\n      \"timestamp\": \"2024-03-15T18:30:00Z\"\n    }\n  }\n}\n</code></pre>"},{"location":"specification/#67-file-exchange-upload-and-download","title":"6.7. File Exchange (Upload and Download)","text":"<p>Scenario: Client sends an image for analysis, and the agent returns a modified image.</p> <p>Request with File Upload:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [\n      {\n        \"text\": \"Analyze this image and highlight any faces.\"\n      },\n      {\n        \"file\": {\n          \"name\": \"input_image.png\",\n          \"mediaType\": \"image/png\",\n          \"fileWithBytes\": \"iVBORw0KGgoAAAANSUhEUgAAAAUA...\"\n        }\n      }\n    ],\n    \"messageId\": \"6dbc13b5-bd57-4c2b-b503-24e381b6c8d6\"\n  }\n}\n</code></pre> <p>Response with File Reference:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"task\": {\n    \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"TASK_STATE_COMPLETED\",\n      \"timestamp\": \"2024-03-15T12:05:00Z\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"processed_image_with_faces.png\",\n        \"parts\": [\n          {\n            \"file\": {\n              \"name\": \"output.png\",\n              \"mediaType\": \"image/png\",\n              \"fileWithUri\": \"https://storage.example.com/processed/task-bbb/output.png?token=xyz\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/#68-structured-data-exchange","title":"6.8. Structured Data Exchange","text":"<p>Scenario: Client asks for a list of open support tickets in a specific JSON format.</p> <p>Request:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/a2a+json\nAuthorization: Bearer token\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [\n      {\n        \"text\": \"Show me a list of my open IT tickets\",\n        \"metadata\": {\n          \"mediaType\": \"application/json\",\n          \"schema\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"ticketNumber\": { \"type\": \"string\" },\n                \"description\": { \"type\": \"string\" }\n              }\n            }\n          }\n        }\n      }\n    ],\n    \"messageId\": \"85b26db5-ffbb-4278-a5da-a7b09dea1b47\"\n  }\n}\n</code></pre> <p>Response with Structured Data:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"task\": {\n    \"id\": \"d8c6243f-5f7a-4f6f-821d-957ce51e856c\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"TASK_STATE_COMPLETED\",\n      \"timestamp\": \"2025-04-17T17:47:09.680794Z\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"c5e0382f-b57f-4da7-87d8-b85171fad17c\",\n        \"parts\": [\n          {\n            \"text\": \"[{\\\"ticketNumber\\\":\\\"REQ12312\\\",\\\"description\\\":\\\"request for VPN access\\\"},{\\\"ticketNumber\\\":\\\"REQ23422\\\",\\\"description\\\":\\\"Add to DL - team-gcp-onboarding\\\"}]\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/#69-fetching-authenticated-extended-agent-card","title":"6.9. Fetching Authenticated Extended Agent Card","text":"<p>Scenario: A client discovers a public Agent Card indicating support for an authenticated extended card and wants to retrieve the full details.</p> <p>Step 1: Client fetches the public Agent Card:</p> <pre><code>GET /.well-known/agent-card.json HTTP/1.1\nHost: example.com\n</code></pre> <p>Response includes:</p> <pre><code>{\n  \"capabilities\": {\n    \"extendedAgentCard\": true\n  },\n  \"securitySchemes\": {\n    \"google\": {\n      \"openIdConnectSecurityScheme\": {\n        \"openIdConnectUrl\": \"https://accounts.google.com/.well-known/openid-configuration\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"specification/#step-2-client-obtains-credentials-out-of-band-oauth-20-flow","title":"Step 2: Client obtains credentials (out-of-band OAuth 2.0 flow)","text":""},{"location":"specification/#step-3-client-fetches-authenticated-extended-agent-card","title":"Step 3: Client fetches authenticated extended Agent Card","text":"<pre><code>GET /extendedAgentCard HTTP/1.1\nHost: agent.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n</code></pre> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/a2a+json\n\n{\n  \"protocolVersions\": [\"1.0\"],\n  \"name\": \"Extended Agent with Additional Skills\",\n  \"skills\": [\n    /* Extended skills available to authenticated users */\n  ]\n}\n</code></pre>"},{"location":"specification/#7-authentication-and-authorization","title":"7. Authentication and Authorization","text":"<p>A2A treats agents as standard enterprise applications, relying on established web security practices. Identity information is handled at the protocol layer, not within A2A semantics.</p> <p>For a comprehensive guide on enterprise security aspects, see Enterprise-Ready Features.</p>"},{"location":"specification/#71-protocol-security","title":"7.1. Protocol Security","text":"<p>Production deployments MUST use encrypted communication (HTTPS for HTTP-based bindings, TLS for gRPC). Implementations SHOULD use modern TLS configurations (TLS 1.3+ recommended) with strong cipher suites.</p>"},{"location":"specification/#72-server-identity-verification","title":"7.2. Server Identity Verification","text":"<p>A2A Clients SHOULD verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.</p>"},{"location":"specification/#73-client-authentication-process","title":"7.3. Client Authentication Process","text":"<ol> <li>Discovery of Requirements: The client discovers the server's required authentication schemes via the <code>securitySchemes</code> field in the AgentCard.</li> <li>Credential Acquisition (Out-of-Band): The client obtains the necessary credentials through an out-of-band process specific to the required authentication scheme.</li> <li>Credential Transmission: The client includes these credentials in protocol-appropriate headers or metadata for every A2A request.</li> </ol>"},{"location":"specification/#74-server-authentication-responsibilities","title":"7.4. Server Authentication Responsibilities","text":"<p>The A2A Server:</p> <ul> <li>MUST authenticate every incoming request based on the provided credentials and its declared authentication requirements.</li> <li>SHOULD use appropriate binding-specific error codes for authentication challenges or rejections.</li> <li>SHOULD provide relevant authentication challenge information with error responses.</li> </ul>"},{"location":"specification/#75-in-task-authentication-secondary-credentials","title":"7.5. In-Task Authentication (Secondary Credentials)","text":"<p>If an agent requires additional credentials during task execution:</p> <ol> <li>It SHOULD transition the A2A task to the <code>TASK_STATE_AUTH_REQUIRED</code> state.</li> <li>The accompanying <code>TaskStatus.update</code> SHOULD provide details about the required secondary authentication.</li> <li>The A2A Client obtains these credentials out-of-band and provides them in a subsequent message request.</li> </ol>"},{"location":"specification/#76-authorization","title":"7.6. Authorization","text":"<p>Once authenticated, the A2A Server authorizes requests based on the authenticated identity and its own policies. Authorization logic is implementation-specific and MAY consider:</p> <ul> <li>Specific skills requested</li> <li>Actions attempted within tasks</li> <li>Data access policies</li> <li>OAuth scopes (if applicable)</li> </ul>"},{"location":"specification/#8-agent-discovery-the-agent-card","title":"8. Agent Discovery: The Agent Card","text":""},{"location":"specification/#81-purpose","title":"8.1. Purpose","text":"<p>A2A Servers MUST make an Agent Card available. The Agent Card describes the server's identity, capabilities, skills, and interaction requirements. Clients use this information for discovering suitable agents and configuring interactions.</p> <p>For more on discovery strategies, see the Agent Discovery guide.</p>"},{"location":"specification/#82-discovery-mechanisms","title":"8.2. Discovery Mechanisms","text":"<p>Clients can find Agent Cards through:</p> <ul> <li>Well-Known URI: Accessing <code>https://{server_domain}/.well-known/agent-card.json</code></li> <li>Registries/Catalogs: Querying curated catalogs of agents</li> <li>Direct Configuration: Pre-configured Agent Card URLs or content</li> </ul>"},{"location":"specification/#83-protocol-declaration-requirements","title":"8.3. Protocol Declaration Requirements","text":"<p>The AgentCard MUST properly declare supported protocols:</p>"},{"location":"specification/#831-supported-interfaces-declaration","title":"8.3.1. Supported Interfaces Declaration","text":"<ul> <li>The <code>supportedInterfaces</code> field SHOULD declare all supported protocol combinations in preference order</li> <li>The first entry in <code>supportedInterfaces</code> represents the preferred interface</li> <li>Each interface MUST accurately declare its transport protocol and URL</li> <li>URLs MAY be reused if multiple transports are available at the same endpoint</li> </ul>"},{"location":"specification/#832-client-protocol-selection","title":"8.3.2. Client Protocol Selection","text":"<p>Clients MUST follow these rules:</p> <ol> <li>Parse <code>supportedInterfaces</code> if present, and select the first supported transport</li> <li>Prefer earlier entries in the ordered list when multiple options are supported</li> <li>Use the correct URL for the selected transport</li> </ol>"},{"location":"specification/#84-agent-card-signing","title":"8.4. Agent Card Signing","text":"<p>Agent Cards MAY be digitally signed using JSON Web Signature (JWS) as defined in RFC 7515 to ensure authenticity and integrity. Signatures allow clients to verify that an Agent Card has not been tampered with and originates from the claimed provider.</p>"},{"location":"specification/#841-canonicalization-requirements","title":"8.4.1. Canonicalization Requirements","text":"<p>Before signing, the Agent Card content MUST be canonicalized using the JSON Canonicalization Scheme (JCS) as defined in RFC 8785. This ensures consistent signature generation and verification across different JSON implementations.</p> <p>Canonicalization Rules:</p> <ol> <li> <p>Field Presence and Default Value Handling: Before canonicalization, the JSON representation MUST respect Protocol Buffer field presence semantics as defined in Section 5.7. This ensures that the canonical form accurately reflects which fields were explicitly provided versus which were omitted, enabling signature verification when Agent Cards are reconstructed:</p> <ul> <li>Optional fields not explicitly set: Fields marked with the <code>optional</code> keyword that were not explicitly set MUST be omitted from the JSON object</li> <li>Optional fields explicitly set to defaults: Fields marked with <code>optional</code> that were explicitly set to a value (even if that value matches a default) MUST be included in the JSON object</li> <li>Required fields: Fields marked with <code>REQUIRED</code> MUST always be present, even if the field value matches the default.</li> <li>Default values: Fields with default values MUST be omitted unless the field is marked as <code>REQUIRED</code> or has the <code>optional</code> keyword.</li> </ul> </li> <li> <p>RFC 8785 Compliance: The Agent Card JSON MUST be canonicalized according to RFC 8785, which specifies:</p> <ul> <li>Predictable ordering of object properties (lexicographic by key)</li> <li>Consistent representation of numbers, strings, and other primitive values</li> <li>Removal of insignificant whitespace</li> </ul> </li> <li> <p>Signature Field Exclusion: The <code>signatures</code> field itself MUST be excluded from the content being signed to avoid circular dependencies.</p> </li> </ol> <p>Example of Default Value Removal:</p> <p>Original Agent Card fragment:</p> <pre><code>{\n  \"name\": \"Example Agent\",\n  \"description\": \"\",\n  \"capabilities\": {\n    \"streaming\": false,\n    \"pushNotifications\": false,\n    \"extensions\": []\n  },\n  \"skills\": []\n}\n</code></pre> <p>Applying the canonicalization rules:</p> <ul> <li><code>name</code>: \"Example Agent\" - REQUIRED field \u2192 include</li> <li><code>description</code>: \"\" - REQUIRED field \u2192 include</li> <li><code>capabilities</code>: object - REQUIRED field \u2192 include (after processing children)<ul> <li><code>streaming</code>: false - optional field, present in JSON (explicitly set) \u2192 include</li> <li><code>pushNotifications</code>: false - optional field, present in JSON (explicitly set) \u2192 include</li> <li><code>extensions</code>: [] - repeated field (not REQUIRED) with empty array \u2192 omit</li> </ul> </li> <li><code>skills</code>: [] - REQUIRED field \u2192 include</li> </ul> <p>After applying RFC 8785:</p> <pre><code>{\"capabilities\":{\"pushNotifications\":false,\"streaming\":false},\"description\":\"\",\"name\":\"Example Agent\",\"skills\":[]}\n</code></pre>"},{"location":"specification/#842-signature-format","title":"8.4.2. Signature Format","text":"<p>Signatures use the JSON Web Signature (JWS) format as defined in RFC 7515. The <code>AgentCardSignature</code> object represents JWS components using three fields:</p> <ul> <li><code>protected</code> (required, string): Base64url-encoded JSON object containing the JWS Protected Header</li> <li><code>signature</code> (required, string): Base64url-encoded signature value</li> <li><code>header</code> (optional, object): JWS Unprotected Header as a JSON object (not base64url-encoded)</li> </ul> <p>JWS Protected Header Parameters:</p> <p>The protected header MUST include:</p> <ul> <li><code>alg</code>: Algorithm used for signing (e.g., \"ES256\", \"RS256\")</li> <li><code>typ</code>: SHOULD be set to \"JOSE\" for JWS</li> <li><code>kid</code>: Key ID for identifying the signing key</li> </ul> <p>The protected header MAY include:</p> <ul> <li><code>jku</code>: URL to JSON Web Key Set (JWKS) containing the public key</li> </ul> <p>Signature Generation Process:</p> <ol> <li> <p>Prepare the payload:</p> <ul> <li>Remove properties with default values from the Agent Card</li> <li>Exclude the <code>signatures</code> field</li> <li>Canonicalize the resulting JSON using RFC 8785 to produce the canonical payload</li> </ul> </li> <li> <p>Create the protected header:</p> <ul> <li>Construct a JSON object with the required header parameters (<code>alg</code>, <code>typ</code>, <code>kid</code>) and any optional parameters (<code>jku</code>)</li> <li>Serialize the header to JSON</li> <li>Base64url-encode the serialized header to produce the <code>protected</code> field value</li> </ul> </li> <li> <p>Compute the signature:</p> <ul> <li>Construct the JWS Signing Input: <code>ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload))</code></li> <li>Sign the JWS Signing Input using the algorithm specified in the <code>alg</code> header parameter and the private key</li> <li>Base64url-encode the resulting signature bytes to produce the <code>signature</code> field value</li> </ul> </li> <li> <p>Assemble the AgentCardSignature:</p> <ul> <li>Set <code>protected</code> to the base64url-encoded protected header from step 2</li> <li>Set <code>signature</code> to the base64url-encoded signature value from step 3</li> <li>Optionally set <code>header</code> to a JSON object containing any unprotected header parameters.</li> </ul> </li> </ol> <p>Example:</p> <p>Given a canonical Agent Card payload and signing key, the signature generation produces:</p> <pre><code>{\n  \"protected\": \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0\",\n  \"signature\": \"QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ\"\n}\n</code></pre> <p>Where the <code>protected</code> value decodes to:</p> <pre><code>{\"alg\":\"ES256\",\"typ\":\"JOSE\",\"kid\":\"key-1\",\"jku\":\"https://example.com/agent/jwks.json\"}\n</code></pre>"},{"location":"specification/#843-signature-verification","title":"8.4.3. Signature Verification","text":"<p>Clients verifying Agent Card signatures MUST:</p> <ol> <li>Extract the signature from the <code>signatures</code> array</li> <li>Retrieve the public key using the <code>kid</code> and <code>jku</code> (or from a trusted key store)</li> <li>Remove properties with default values from the received Agent Card</li> <li>Exclude the <code>signatures</code> field</li> <li>Canonicalize the resulting JSON using RFC 8785</li> <li>Verify the signature against the canonicalized payload</li> </ol> <p>Security Considerations:</p> <ul> <li>Clients SHOULD verify at least one signature before trusting an Agent Card</li> <li>Public keys SHOULD be retrieved over secure channels (HTTPS)</li> <li>Clients MAY maintain a trusted key store for known agent providers</li> <li>Expired or revoked keys MUST NOT be used for verification</li> <li>Multiple signatures MAY be present to support key rotation</li> </ul>"},{"location":"specification/#85-sample-agent-card","title":"8.5. Sample Agent Card","text":"<pre><code>{\n  \"protocolVersions\": [\"1.0\"],\n  \"name\": \"GeoSpatial Route Planner Agent\",\n  \"description\": \"Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.\",\n  \"supportedInterfaces\": [\n    {\"url\": \"https://georoute-agent.example.com/a2a/v1\", \"protocolBinding\": \"JSONRPC\"},\n    {\"url\": \"https://georoute-agent.example.com/a2a/grpc\", \"protocolBinding\": \"GRPC\"},\n    {\"url\": \"https://georoute-agent.example.com/a2a/json\", \"protocolBinding\": \"HTTP+JSON\"}\n  ],\n  \"provider\": {\n    \"organization\": \"Example Geo Services Inc.\",\n    \"url\": \"https://www.examplegeoservices.com\"\n  },\n  \"iconUrl\": \"https://georoute-agent.example.com/icon.png\",\n  \"version\": \"1.2.0\",\n  \"documentationUrl\": \"https://docs.examplegeoservices.com/georoute-agent/api\",\n  \"capabilities\": {\n    \"streaming\": true,\n    \"pushNotifications\": true,\n    \"stateTransitionHistory\": false,\n    \"extendedAgentCard\": true\n  },\n  \"securitySchemes\": {\n    \"google\": {\n      \"openIdConnectSecurityScheme\": {\n        \"openIdConnectUrl\": \"https://accounts.google.com/.well-known/openid-configuration\"\n      }\n    }\n  },\n  \"security\": [{ \"google\": [\"openid\", \"profile\", \"email\"] }],\n  \"defaultInputModes\": [\"application/json\", \"text/plain\"],\n  \"defaultOutputModes\": [\"application/json\", \"image/png\"],\n  \"skills\": [\n    {\n      \"id\": \"route-optimizer-traffic\",\n      \"name\": \"Traffic-Aware Route Optimizer\",\n      \"description\": \"Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).\",\n      \"tags\": [\"maps\", \"routing\", \"navigation\", \"directions\", \"traffic\"],\n      \"examples\": [\n        \"Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.\",\n        \"{\\\"origin\\\": {\\\"lat\\\": 37.422, \\\"lng\\\": -122.084}, \\\"destination\\\": {\\\"lat\\\": 37.7749, \\\"lng\\\": -122.4194}, \\\"preferences\\\": [\\\"avoid_ferries\\\"]}\"\n      ],\n      \"inputModes\": [\"application/json\", \"text/plain\"],\n      \"outputModes\": [\n        \"application/json\",\n        \"application/vnd.geo+json\",\n        \"text/html\"\n      ]\n    },\n    {\n      \"id\": \"custom-map-generator\",\n      \"name\": \"Personalized Map Generator\",\n      \"description\": \"Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.\",\n      \"tags\": [\"maps\", \"customization\", \"visualization\", \"cartography\"],\n      \"examples\": [\n        \"Generate a map of my upcoming road trip with all planned stops highlighted.\",\n        \"Show me a map visualizing all coffee shops within a 1-mile radius of my current location.\"\n      ],\n      \"inputModes\": [\"application/json\"],\n      \"outputModes\": [\n        \"image/png\",\n        \"image/jpeg\",\n        \"application/json\",\n        \"text/html\"\n      ]\n    }\n  ],\n  \"signatures\": [\n    {\n      \"protected\": \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0\",\n      \"signature\": \"QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ\"\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#9-json-rpc-protocol-binding","title":"9. JSON-RPC Protocol Binding","text":"<p>The JSON-RPC protocol binding provides a simple, HTTP-based interface using JSON-RPC 2.0 for method calls and Server-Sent Events for streaming.</p>"},{"location":"specification/#91-protocol-requirements","title":"9.1. Protocol Requirements","text":"<ul> <li>Protocol: JSON-RPC 2.0 over HTTP(S)</li> <li>Content-Type: <code>application/json</code> for requests and responses</li> <li>Method Naming: PascalCase method names matching gRPC conventions (e.g., <code>SendMessage</code>, <code>GetTask</code>)</li> <li>Streaming: Server-Sent Events (<code>text/event-stream</code>)</li> </ul>"},{"location":"specification/#92-service-parameter-transmission","title":"9.2. Service Parameter Transmission","text":"<p>A2A service parameters defined in Section 3.2.6 MUST be transmitted using standard HTTP request headers, as JSON-RPC 2.0 operates over HTTP(S).</p> <p>Service Parameter Requirements:</p> <ul> <li>Service parameter names MUST be transmitted as HTTP header fields</li> <li>Service parameter keys are case-insensitive per HTTP specification (RFC 7230)</li> <li>Multiple values for the same service parameter (e.g., <code>A2A-Extensions</code>) SHOULD be comma-separated in a single header field</li> </ul> <p>Example Request with A2A Service Parameters:</p> <pre><code>POST /rpc HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\nAuthorization: Bearer token\nA2A-Version: 0.3\nA2A-Extensions: https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"SendMessage\",\n  \"params\": { /* SendMessageRequest */ }\n}\n</code></pre>"},{"location":"specification/#93-base-request-structure","title":"9.3. Base Request Structure","text":"<p>All JSON-RPC requests MUST follow the standard JSON-RPC 2.0 format:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"unique-request-id\",\n  \"method\": \"category/action\",\n  \"params\": { /* method-specific parameters */ }\n}\n</code></pre>"},{"location":"specification/#94-core-methods","title":"9.4. Core Methods","text":""},{"location":"specification/#941-sendmessage","title":"9.4.1. <code>SendMessage</code>","text":"<p>Sends a message to initiate or continue a task.</p> <p>Request:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"SendMessage\",\n  \"params\": { /* SendMessageRequest object */ }\n}\n</code></pre> <p>Referenced Objects: <code>SendMessageRequest</code>, <code>Message</code></p> <p>Response:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    /* SendMessageResponse object, contains one of:\n     * \"task\": { Task object }\n     * \"message\": { Message object }\n    */\n  }\n</code></pre> <p>Referenced Objects: <code>Task</code>, <code>Message</code></p>"},{"location":"specification/#942-sendstreamingmessage","title":"9.4.2. <code>SendStreamingMessage</code>","text":"<p>Sends a message and subscribes to real-time updates via Server-Sent Events.</p> <p>Request: Same as <code>SendMessage</code></p> <p>Response: HTTP 200 with <code>Content-Type: text/event-stream</code></p> <pre><code>data: {\"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { /* Task | Message | TaskArtifactUpdateEvent | TaskStatusUpdateEvent */ }}\n\ndata: {\"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { /* Task | Message | TaskArtifactUpdateEvent | TaskStatusUpdateEvent */ }}\n</code></pre> <p>Referenced Objects: <code>Task</code>, <code>Message</code>, <code>TaskArtifactUpdateEvent</code>, <code>TaskStatusUpdateEvent</code></p>"},{"location":"specification/#943-gettask","title":"9.4.3. <code>GetTask</code>","text":"<p>Retrieves the current state of a task.</p> <p>Request:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"GetTask\",\n  \"params\": {\n    \"id\": \"task-uuid\",\n    \"historyLength\": 10\n  }\n}\n</code></pre>"},{"location":"specification/#944-listtasks","title":"9.4.4. <code>ListTasks</code>","text":"<p>Lists tasks with optional filtering and pagination.</p> <p>Request:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"ListTasks\",\n  \"params\": {\n    \"contextId\": \"context-uuid\",\n    \"status\": \"TASK_STATE_WORKING\",\n    \"pageSize\": 50,\n    \"pageToken\": \"cursor-token\"\n  }\n}\n</code></pre>"},{"location":"specification/#945-canceltask","title":"9.4.5. <code>CancelTask</code>","text":"<p>Cancels an ongoing task.</p> <p>Request:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"method\": \"CancelTask\",\n  \"params\": {\n    \"id\": \"task-uuid\"\n  }\n}\n</code></pre>"},{"location":"specification/#946-subscribetotask","title":"9.4.6. <code>SubscribeToTask</code>","text":"<p>Subscribes to a task stream for receiving updates on a task that is not in a terminal state.</p> <p>Request:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 5,\n  \"method\": \"SubscribeToTask\",\n  \"params\": {\n    \"id\": \"task-uuid\"\n  }\n}\n</code></pre> <p>Response: SSE stream (same format as <code>SendStreamingMessage</code>)</p> <p>Error: Returns <code>UnsupportedOperationError</code> if the task is in a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>, or <code>rejected</code>).</p>"},{"location":"specification/#947-push-notification-configuration-methods","title":"9.4.7. Push Notification Configuration Methods","text":"<ul> <li><code>CreateTaskPushNotificationConfig</code> - Create push notification configuration</li> <li><code>GetTaskPushNotificationConfig</code> - Get push notification configuration</li> <li><code>ListTaskPushNotificationConfig</code> - List push notification configurations</li> <li><code>DeleteTaskPushNotificationConfig</code> - Delete push notification configuration</li> </ul>"},{"location":"specification/#948-getextendedagentcard","title":"9.4.8. <code>GetExtendedAgentCard</code>","text":"<p>Retrieves an extended Agent Card.</p> <p>Request:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 6,\n  \"method\": \"GetExtendedAgentCard\"\n}\n</code></pre>"},{"location":"specification/#95-error-handling","title":"9.5. Error Handling","text":"<p>JSON-RPC error responses use the standard JSON-RPC 2.0 error object structure, which maps to the generic A2A error model defined in Section 3.3.2 as follows:</p> <ul> <li>Error Code: Mapped to <code>error.code</code> (numeric JSON-RPC error code)</li> <li>Error Message: Mapped to <code>error.message</code> (human-readable string)</li> <li>Error Details: Mapped to <code>error.data</code> (optional structured object)</li> </ul> <p>Standard JSON-RPC Error Codes:</p> JSON-RPC Error Code Error Name Standard Message Description <code>-32700</code> <code>JSONParseError</code> \"Invalid JSON payload\" The server received invalid JSON <code>-32600</code> <code>InvalidRequestError</code> \"Request payload validation error\" The JSON sent is not a valid Request object <code>-32601</code> <code>MethodNotFoundError</code> \"Method not found\" The requested method does not exist or is not available <code>-32602</code> <code>InvalidParamsError</code> \"Invalid parameters\" The method parameters are invalid <code>-32603</code> <code>InternalError</code> \"Internal error\" An internal error occurred on the server <p>A2A-Specific Error Codes:</p> <p>A2A-specific errors use codes in the range <code>-32001</code> to <code>-32099</code>. For the complete mapping of A2A error types to JSON-RPC error codes, see Section 5.4 (Error Code Mappings).</p> <p>Error Response Structure:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Method not found\",\n    \"data\": {\n      \"method\": \"invalid/method\"\n    }\n  }\n}\n</code></pre> <p>Example A2A-Specific Error Response:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"error\": {\n    \"code\": -32001,\n    \"message\": \"Task not found\",\n    \"data\": {\n      \"taskId\": \"nonexistent-task-id\",\n      \"timestamp\": \"2025-11-09T10:30:00.000Z\"\n    }\n  }\n}\n</code></pre> <p>The <code>data</code> field MAY include additional context-specific information to help clients diagnose and resolve the error.</p>"},{"location":"specification/#10-grpc-protocol-binding","title":"10. gRPC Protocol Binding","text":"<p>The gRPC Protocol Binding provides a high-performance, strongly-typed interface using Protocol Buffers over HTTP/2. The gRPC Protocol Binding leverages the API guidelines to simplify gRPC to HTTP mapping.</p>"},{"location":"specification/#101-protocol-requirements","title":"10.1. Protocol Requirements","text":"<ul> <li>Protocol: gRPC over HTTP/2 with TLS</li> <li>Definition: Use the normative Protocol Buffers definition in <code>specification/grpc/a2a.proto</code></li> <li>Serialization: Protocol Buffers version 3</li> <li>Service: Implement the <code>A2AService</code> gRPC service</li> </ul>"},{"location":"specification/#102-service-parameter-transmission","title":"10.2. Service Parameter Transmission","text":"<p>A2A service parameters defined in Section 3.2.6 MUST be transmitted using gRPC metadata (headers).</p> <p>Service Parameter Requirements:</p> <ul> <li>Service parameter names MUST be transmitted as gRPC metadata keys</li> <li>Metadata keys are case-insensitive and automatically converted to lowercase by gRPC</li> <li>Multiple values for the same service parameter (e.g., <code>A2A-Extensions</code>) SHOULD be comma-separated in a single metadata entry</li> </ul> <p>Example gRPC Request with A2A Service Parameters:</p> <pre><code>// Go example using gRPC metadata\nmd := metadata.Pairs(\n    \"authorization\", \"Bearer token\",\n    \"a2a-version\", \"0.3\",\n    \"a2a-extensions\", \"https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1\",\n)\nctx := metadata.NewOutgoingContext(context.Background(), md)\n\n// Make the RPC call with the context containing metadata\nresponse, err := client.SendMessage(ctx, request)\n</code></pre> <p>Metadata Handling:</p> <ul> <li>Implementations MUST extract A2A service parameters from gRPC metadata for processing</li> <li>Servers SHOULD validate required service parameters (e.g., <code>A2A-Version</code>) from metadata</li> <li>Service parameter keys in metadata are normalized to lowercase per gRPC conventions</li> </ul>"},{"location":"specification/#103-service-definition","title":"10.3. Service Definition","text":"<pre><code>service A2AService {\n  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);\n  rpc SendStreamingMessage(SendMessageRequest) returns (stream StreamResponse);\n  rpc GetTask(GetTaskRequest) returns (Task);\n  rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);\n  rpc CancelTask(CancelTaskRequest) returns (Task);\n  rpc SubscribeToTask(SubscribeToTaskRequest) returns (stream StreamResponse);\n  rpc CreateTaskPushNotificationConfig(CreateTaskPushNotificationConfigRequest) returns (TaskPushNotificationConfig);\n  rpc GetTaskPushNotificationConfig(GetTaskPushNotificationConfigRequest) returns (TaskPushNotificationConfig);\n  rpc ListTaskPushNotificationConfig(ListTaskPushNotificationConfigRequest) returns (ListTaskPushNotificationConfigResponse);\n  rpc DeleteTaskPushNotificationConfig(DeleteTaskPushNotificationConfigRequest) returns (google.protobuf.Empty);\n  rpc GetExtendedAgentCard(GetExtendedAgentCardRequest) returns (AgentCard);\n}\n</code></pre>"},{"location":"specification/#104-core-methods","title":"10.4. Core Methods","text":""},{"location":"specification/#1041-sendmessage","title":"10.4.1. SendMessage","text":"<p>Sends a message to an agent.</p> <p>Request:</p> <pre><code>// Represents a request for the `SendMessage` method.\nmessage SendMessageRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The message to send to the agent.\n  Message message = 1 [(google.api.field_behavior) = REQUIRED];\n  // Configuration for the send request.\n  SendMessageConfiguration configuration = 2;\n  // A flexible key-value map for passing additional context or parameters.\n  google.protobuf.Struct metadata = 3;\n}\n</code></pre> <p>Response:</p> <pre><code>message SendMessageResponse {\n  oneof payload {\n    Task task = 1;\n    Message message = 2;\n  }\n}\n</code></pre>"},{"location":"specification/#1042-sendstreamingmessage","title":"10.4.2. SendStreamingMessage","text":"<p>Sends a message with streaming updates.</p> <p>Request:</p> <pre><code>// Represents a request for the `SendMessage` method.\nmessage SendMessageRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The message to send to the agent.\n  Message message = 1 [(google.api.field_behavior) = REQUIRED];\n  // Configuration for the send request.\n  SendMessageConfiguration configuration = 2;\n  // A flexible key-value map for passing additional context or parameters.\n  google.protobuf.Struct metadata = 3;\n}\n</code></pre> <p>Response: Server streaming <code>StreamResponse</code> objects.</p>"},{"location":"specification/#1043-gettask","title":"10.4.3. GetTask","text":"<p>Retrieves task status.</p> <p>Request:</p> <pre><code>// Represents a request for the `GetTask` method.\nmessage GetTaskRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 3;\n  // The resource name of the task.\n  // Format: tasks/{task_id}\n  string name = 1 [(google.api.field_behavior) = REQUIRED];\n  // The maximum number of most recent messages from the task's history to retrieve. An\n  // unset value means the client does not impose any limit. A value of zero is\n  // a request to not include any messages. The server MUST NOT return more\n  // messages than the provided value, but MAY apply a lower limit.\n  optional int32 history_length = 2;\n}\n</code></pre> <p>Response: See <code>Task</code> object definition.</p>"},{"location":"specification/#1044-listtasks","title":"10.4.4. ListTasks","text":"<p>Lists tasks with filtering.</p> <p>Request:</p> <pre><code>// Parameters for listing tasks with optional filtering criteria.\nmessage ListTasksRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 9;\n  // Filter tasks by context ID to get tasks from a specific conversation or session.\n  string context_id = 1;\n  // Filter tasks by their current status state.\n  TaskState status = 2;\n  // Maximum number of tasks to return. Must be between 1 and 100.\n  // Defaults to 50 if not specified.\n  optional int32 page_size = 3;\n  // Token for pagination. Use the next_page_token from a previous ListTasksResponse.\n  string page_token = 4;\n  // The maximum number of messages to include in each task's history.\n  optional int32 history_length = 5;\n  // Filter tasks which have a status updated after the provided timestamp in ISO 8601 format (e.g., \"2023-10-27T10:00:00Z\").\n  // Only tasks with a status timestamp time greater than or equal to this value will be returned.\n  google.protobuf.Timestamp status_timestamp_after = 6;\n  // Whether to include artifacts in the returned tasks.\n  // Defaults to false to reduce payload size.\n  optional bool include_artifacts = 7;\n}\n</code></pre> <p>Response:</p> <pre><code>// Result object for tasks/list method containing an array of tasks and pagination information.\nmessage ListTasksResponse {\n  // Array of tasks matching the specified criteria.\n  repeated Task tasks = 1 [(google.api.field_behavior) = REQUIRED];\n  // Token for retrieving the next page. Empty string if no more results.\n  string next_page_token = 2 [(google.api.field_behavior) = REQUIRED];\n  // The size of page requested.\n  int32 page_size = 3 [(google.api.field_behavior) = REQUIRED];\n  // Total number of tasks available (before pagination).\n  int32 total_size = 4 [(google.api.field_behavior) = REQUIRED];\n}\n</code></pre>"},{"location":"specification/#1045-canceltask","title":"10.4.5. CancelTask","text":"<p>Cancels a running task.</p> <p>Request:</p> <pre><code>// Represents a request for the `CancelTask` method.\nmessage CancelTaskRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the task to cancel.\n  // Format: tasks/{task_id}\n  string name = 1;\n}\n</code></pre> <p>Response: See <code>Task</code> object definition.</p>"},{"location":"specification/#1046-subscribetotask","title":"10.4.6. SubscribeToTask","text":"<p>Subscribe to task updates via streaming. Returns <code>UnsupportedOperationError</code> if the task is in a terminal state.</p> <p>Request:</p> <pre><code>message SubscribeToTaskRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the task to subscribe to.\n  // Format: tasks/{task_id}\n  string name = 1;\n}\n</code></pre> <p>Response: Server streaming <code>StreamResponse</code> objects.</p>"},{"location":"specification/#1047-createtaskpushnotificationconfig","title":"10.4.7. CreateTaskPushNotificationConfig","text":"<p>Creates a push notification configuration for a task.</p> <p>Request:</p> <pre><code>// Represents a request for the `CreateTaskPushNotificationConfig` method.\nmessage CreateTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The parent task resource for this config.\n  // Format: tasks/{task_id}\n  string parent = 1 [(google.api.field_behavior) = REQUIRED];\n  // The ID for the new config.\n  string config_id = 2 [(google.api.field_behavior) = REQUIRED];\n  // The configuration to create.\n  TaskPushNotificationConfig config = 3 [(google.api.field_behavior) = REQUIRED];\n}\n</code></pre> <p>Response: See <code>PushNotificationConfig</code> object definition.</p>"},{"location":"specification/#1048-gettaskpushnotificationconfig","title":"10.4.8. GetTaskPushNotificationConfig","text":"<p>Retrieves an existing push notification configuration for a task.</p> <p>Request:</p> <pre><code>message GetTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the config to retrieve.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1;\n}\n</code></pre> <p>Response: See <code>PushNotificationConfig</code> object definition.</p>"},{"location":"specification/#1049-listtaskpushnotificationconfig","title":"10.4.9. ListTaskPushNotificationConfig","text":"<p>Lists all push notification configurations for a task.</p> <p>Request:</p> <pre><code>message ListTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 4;\n  // The parent task resource.\n  // Format: tasks/{task_id}\n  string parent = 1;\n  // The maximum number of configurations to return.\n  int32 page_size = 2;\n\n  // A page token received from a previous ListTaskPushNotificationConfigRequest call.\n  string page_token = 3;\n}\n</code></pre> <p>Response:</p> <pre><code>// Represents a successful response for the `ListTaskPushNotificationConfig`\n// method.\nmessage ListTaskPushNotificationConfigResponse {\n  // The list of push notification configurations.\n  repeated TaskPushNotificationConfig configs = 1;\n  // A token, which can be sent as `page_token` to retrieve the next page.\n  // If this field is omitted, there are no subsequent pages.\n  string next_page_token = 2;\n}\n</code></pre>"},{"location":"specification/#10410-deletetaskpushnotificationconfig","title":"10.4.10. DeleteTaskPushNotificationConfig","text":"<p>Removes a push notification configuration for a task.</p> <p>Request:</p> <pre><code>// Represents a request for the `DeleteTaskPushNotificationConfig` method.\nmessage DeleteTaskPushNotificationConfigRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 2;\n  // The resource name of the config to delete.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1;\n}\n</code></pre> <p>Response: <code>google.protobuf.Empty</code></p>"},{"location":"specification/#10411-getextendedagentcard","title":"10.4.11. GetExtendedAgentCard","text":"<p>Retrieves the agent's extended capability card after authentication.</p> <p>Request:</p> <pre><code>message GetExtendedAgentCardRequest {\n  // Optional tenant, provided as a path parameter.\n  string tenant = 1;\n}\n</code></pre> <p>Response: See <code>AgentCard</code> object definition.</p>"},{"location":"specification/#105-grpc-specific-data-types","title":"10.5. gRPC-Specific Data Types","text":""},{"location":"specification/#1051-taskpushnotificationconfig","title":"10.5.1. TaskPushNotificationConfig","text":"<p>Resource wrapper for push notification configurations. This is a gRPC-specific type used in resource-oriented operations to provide the full resource name along with the configuration data.</p> <pre><code>// A container associating a push notification configuration with a specific\n// task.\nmessage TaskPushNotificationConfig {\n  // The resource name of the config.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1 [(google.api.field_behavior) = REQUIRED];\n  // The push notification configuration details.\n  PushNotificationConfig push_notification_config = 2 [(google.api.field_behavior) = REQUIRED];\n}\n</code></pre> <p>Fields:</p> <p>A container associating a push notification configuration with a specific task.</p> Field Type Required Description <code>name</code> <code>string</code> Yes The resource name of the config. Format: tasks/{task_id}/pushNotificationConfigs/{config_id} <code>pushNotificationConfig</code> <code>PushNotificationConfig</code> Yes The push notification configuration details."},{"location":"specification/#106-error-handling","title":"10.6. Error Handling","text":"<p>gRPC error responses use the standard gRPC status structure with google.rpc.Status, which maps to the generic A2A error model defined in Section 3.3.2 as follows:</p> <ul> <li>Error Code: Mapped to <code>status.code</code> (gRPC status code enum)</li> <li>Error Message: Mapped to <code>status.message</code> (human-readable string)</li> <li>Error Details: Mapped to <code>status.details</code> (repeated google.protobuf.Any messages)</li> </ul> <p>A2A Error Representation:</p> <p>For A2A-specific errors, implementations MUST include a <code>google.rpc.ErrorInfo</code> message in the <code>status.details</code> array with:</p> <ul> <li><code>reason</code>: The A2A error type in UPPER_SNAKE_CASE without the \"Error\" suffix (e.g., <code>TASK_NOT_FOUND</code>)</li> <li><code>domain</code>: Set to <code>\"a2a-protocol.org\"</code></li> <li><code>metadata</code>: Optional map of additional error context</li> </ul> <p>For the complete mapping of A2A error types to gRPC status codes, see Section 5.4 (Error Code Mappings).</p> <p>Error Response Example:</p> <pre><code>// Standard gRPC invalid argument error\nstatus {\n  code: INVALID_ARGUMENT\n  message: \"Invalid request parameters\"\n  details: [\n    {\n      type: \"type.googleapis.com/google.rpc.BadRequest\"\n      field_violations: [\n        {\n          field: \"message.parts\"\n          description: \"At least one part is required\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Example A2A-Specific Error Response:</p> <pre><code>// A2A-specific task not found error\nstatus {\n  code: NOT_FOUND\n  message: \"Task with ID 'task-123' not found\"\n  details: [\n    {\n      type: \"type.googleapis.com/google.rpc.ErrorInfo\"\n      reason: \"TASK_NOT_FOUND\"\n      domain: \"a2a-protocol.org\"\n      metadata: {\n        task_id: \"task-123\"\n        timestamp: \"2025-11-09T10:30:00Z\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#107-streaming","title":"10.7. Streaming","text":"<p>gRPC streaming uses server streaming RPCs for real-time updates. The <code>StreamResponse</code> message provides a union of possible streaming events:</p> <pre><code>// A wrapper object used in streaming operations to encapsulate different types of response data.\nmessage StreamResponse {\n  oneof payload {\n    // A Task object containing the current state of the task.\n    Task task = 1;\n    // A Message object containing a message from the agent.\n    Message message = 2;\n    // An event indicating a task status update.\n    TaskStatusUpdateEvent status_update = 3;\n    // An event indicating a task artifact update.\n    TaskArtifactUpdateEvent artifact_update = 4;\n  }\n}\n</code></pre>"},{"location":"specification/#11-httpjsonrest-protocol-binding","title":"11. HTTP+JSON/REST Protocol Binding","text":"<p>The HTTP+JSON protocol binding provides a RESTful interface using standard HTTP methods and JSON payloads.</p>"},{"location":"specification/#111-protocol-requirements","title":"11.1. Protocol Requirements","text":"<ul> <li>Protocol: HTTP(S) with JSON payloads</li> <li>Content-Type: <code>application/json</code> for requests and responses</li> <li>Methods: Standard HTTP verbs (GET, POST, PUT, DELETE)</li> <li>URL Patterns: RESTful resource-based URLs</li> <li>Streaming: Server-Sent Events for real-time updates</li> </ul>"},{"location":"specification/#112-service-parameter-transmission","title":"11.2. Service Parameter Transmission","text":"<p>A2A service parameters defined in Section 3.2.6 MUST be transmitted using standard HTTP request headers.</p> <p>Service Parameter Requirements:</p> <ul> <li>Service parameter names MUST be transmitted as HTTP header fields</li> <li>Service parameter keys are case-insensitive per HTTP specification (RFC 9110)</li> <li>Multiple values for the same service parameter (e.g., <code>A2A-Extensions</code>) SHOULD be comma-separated in a single header field</li> </ul> <p>Example Request with A2A Service Parameters:</p> <pre><code>POST /message:send HTTP/1.1\nHost: agent.example.com\nContent-Type: application/json\nAuthorization: Bearer token\nA2A-Version: 0.3\nA2A-Extensions: https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1\n\n{\n  \"message\": {\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"Find restaurants near me\"}]\n  }\n}\n</code></pre>"},{"location":"specification/#113-url-patterns-and-http-methods","title":"11.3. URL Patterns and HTTP Methods","text":""},{"location":"specification/#1131-message-operations","title":"11.3.1. Message Operations","text":"<ul> <li><code>POST /message:send</code> - Send message</li> <li><code>POST /message:stream</code> - Send message with streaming (SSE response)</li> </ul>"},{"location":"specification/#1132-task-operations","title":"11.3.2. Task Operations","text":"<ul> <li><code>GET /tasks/{id}</code> - Get task status</li> <li><code>GET /tasks</code> - List tasks (with query parameters)</li> <li><code>POST /tasks/{id}:cancel</code> - Cancel task</li> <li><code>POST /tasks/{id}:subscribe</code> - Subscribe to task updates (SSE response, returns error for terminal tasks)</li> </ul>"},{"location":"specification/#1133-push-notification-configuration","title":"11.3.3. Push Notification Configuration","text":"<ul> <li><code>POST /tasks/{id}/pushNotificationConfigs</code> - Create configuration</li> <li><code>GET /tasks/{id}/pushNotificationConfigs/{configId}</code> - Get configuration</li> <li><code>GET /tasks/{id}/pushNotificationConfigs</code> - List configurations</li> <li><code>DELETE /tasks/{id}/pushNotificationConfigs/{configId}</code> - Delete configuration</li> </ul>"},{"location":"specification/#1134-agent-card","title":"11.3.4. Agent Card","text":"<ul> <li><code>GET /extendedAgentCard</code> - Get authenticated extended Agent Card</li> </ul>"},{"location":"specification/#114-requestresponse-format","title":"11.4. Request/Response Format","text":"<p>All requests and responses use JSON objects structurally equivalent to the Protocol Buffer definitions.</p> <p>Example Send Message:</p> <pre><code>POST /message:send\nContent-Type: application/json\n\n{\n  \"message\": {\n    \"messageId\": \"uuid\",\n    \"role\": \"ROLE_USER\",\n    \"parts\": [{\"text\": \"Hello\"}]\n  },\n  \"configuration\": {\n    \"acceptedOutputModes\": [\"text/plain\"]\n  }\n}\n</code></pre> <p>Referenced Objects: <code>SendMessageRequest</code>, <code>Message</code></p> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"task\": {\n    \"id\": \"task-uuid\",\n    \"contextId\": \"context-uuid\",\n    \"status\": {\n      \"state\": \"TASK_STATE_COMPLETED\"\n    }\n  }\n}\n</code></pre> <p>Referenced Objects: <code>Task</code></p>"},{"location":"specification/#115-query-parameter-naming-for-request-parameters","title":"11.5. Query Parameter Naming for Request Parameters","text":"<p>HTTP methods that do not support request bodies (GET, DELETE) MUST transmit operation request parameters as path parameters or query parameters. This section defines how to map Protocol Buffer field names to query parameter names.</p> <p>Naming Convention:</p> <p>Query parameter names MUST use <code>camelCase</code> to match the JSON serialization of Protocol Buffer field names. This ensures consistency with request bodies used in POST operations.</p> <p>Example Mappings:</p> Protocol Buffer Field Query Parameter Name Example Usage <code>context_id</code> <code>contextId</code> <code>?contextId=uuid</code> <code>page_size</code> <code>pageSize</code> <code>?pageSize=50</code> <code>page_token</code> <code>pageToken</code> <code>?pageToken=cursor</code> <code>task_id</code> <code>taskId</code> <code>?taskId=uuid</code> <p>Usage Examples:</p> <p>List tasks with filtering:</p> <pre><code>GET /tasks?contextId=uuid&amp;status=working&amp;pageSize=50&amp;pageToken=cursor\n</code></pre> <p>Get task with history:</p> <pre><code>GET /tasks/{id}?historyLength=10\n</code></pre> <p>Field Type Handling:</p> <ul> <li>Strings: Passed directly as query parameter values</li> <li>Booleans: Represented as lowercase strings (<code>true</code>, <code>false</code>)</li> <li>Numbers: Represented as decimal strings</li> <li>Enums: Represented using their string values (e.g., <code>status=working</code>)</li> <li>Repeated Fields: Multiple values MAY be passed by repeating the parameter name (e.g., <code>?tag=value1&amp;tag=value2</code>) or as comma-separated values (e.g., <code>?tag=value1,value2</code>)</li> <li>Nested Objects: Not supported in query parameters; operations requiring nested objects MUST use POST with a request body</li> </ul> <p>URL Encoding:</p> <p>All query parameter values MUST be properly URL-encoded per RFC 3986.</p>"},{"location":"specification/#116-error-handling","title":"11.6. Error Handling","text":"<p>HTTP error responses use RFC 9457 Problem Details format with <code>Content-Type: application/problem+json</code>, which maps to the generic A2A error model defined in Section 3.3.2 as follows:</p> <ul> <li>Error Code: Mapped to <code>status</code> (HTTP status code) and <code>type</code> (URI identifier)</li> <li>Error Message: Mapped to <code>detail</code> (human-readable string)</li> <li>Error Details: Mapped to extension fields in the problem details object</li> </ul> <p>A2A Error Representation:</p> <p>For A2A-specific errors, the <code>type</code> field MUST use the URI from the mapping table in Section 5.4 (Error Code Mappings). Additional error context MAY be included as extension fields in the problem details object.</p> <p>Error Response Example:</p> <pre><code>HTTP/1.1 404 Not Found\nContent-Type: application/problem+json\n\n{\n  \"type\": \"https://a2a-protocol.org/errors/task-not-found\",\n  \"title\": \"Task Not Found\",\n  \"status\": 404,\n  \"detail\": \"The specified task ID does not exist or is not accessible\",\n  \"taskId\": \"task-123\",\n  \"timestamp\": \"2025-11-09T10:30:00.000Z\"\n}\n</code></pre> <p>Extension fields like <code>taskId</code> and <code>timestamp</code> provide additional context to help diagnose the error.</p>"},{"location":"specification/#117-streaming","title":"11.7. Streaming","text":"<p>REST streaming uses Server-Sent Events with the <code>data</code> field containing JSON serializations of the protocol data objects:</p> <pre><code>POST /message:stream\nContent-Type: application/json\n\n{ /* SendMessageRequest object */ }\n</code></pre> <p>Referenced Objects: <code>SendMessageRequest</code></p> <p>Response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\n\ndata: {\"task\": { /* Task object */ }}\n\ndata: {\"artifactUpdate\": { /* TaskArtifactUpdateEvent */ }}\n\ndata: {\"statusUpdate\": { /* TaskStatusUpdateEvent */ }}\n</code></pre> <p>Referenced Objects: <code>Task</code>, <code>TaskStatusUpdateEvent</code>, <code>TaskArtifactUpdateEvent</code>  Streaming responses are simple, linearly ordered sequences: first a <code>Task</code> (or single <code>Message</code>), then zero or more status or artifact update events until the task reaches a terminal or interrupted state, at which point the stream closes. Implementations SHOULD avoid re-ordering events and MAY optionally resend a final <code>Task</code> snapshot before closing.</p>"},{"location":"specification/#12-custom-binding-guidelines","title":"12. Custom Binding Guidelines","text":"<p>While the A2A protocol provides three standard bindings (JSON-RPC, gRPC, and HTTP+JSON/REST), implementers MAY create custom protocol bindings to support additional transport mechanisms or communication patterns. Custom bindings MUST comply with all requirements defined in Section 5 (Protocol Binding Requirements and Interoperability). This section provides additional guidelines specific to developing custom bindings.</p>"},{"location":"specification/#121-binding-requirements","title":"12.1. Binding Requirements","text":"<p>Custom protocol bindings MUST:</p> <ol> <li>Implement All Core Operations: Support all operations defined in Section 3 (A2A Protocol Operations)</li> <li>Preserve Data Model: Use data structures functionally equivalent to those defined in Section 4 (Protocol Data Model)</li> <li>Maintain Semantics: Ensure operations behave consistently with the abstract operation definitions</li> <li>Document Completely: Provide comprehensive documentation of the binding specification</li> </ol>"},{"location":"specification/#122-data-type-mappings","title":"12.2. Data Type Mappings","text":"<p>Custom bindings MUST provide clear mappings for:</p> <ul> <li>Protocol Buffer Types: Define how each Protocol Buffer message type is represented</li> <li>Timestamps: Follow the conventions in Section 5.6.1 (Timestamps)</li> <li>Binary Data: Specify encoding for binary content (e.g., base64 for text-based protocols)</li> <li>Enumerations: Define representation of enum values (e.g., strings, integers)</li> </ul>"},{"location":"specification/#123-service-parameter-transmission","title":"12.3. Service Parameter Transmission","text":"<p>As specified in Section 3.2.6 (Service Parameters), custom protocol bindings MUST document how service parameters are transmitted. The binding specification MUST address:</p> <ol> <li>Transmission Mechanism: The protocol-specific method for transmitting service parameter key-value pairs</li> <li>Value Constraints: Any limitations on service parameter values (e.g., character encoding, size limits)</li> <li>Reserved Names: Any service parameter names reserved by the binding itself</li> <li>Fallback Strategy: What happens when the protocol lacks native header support (e.g., passing service parameters in metadata)</li> </ol> <p>Example Documentation Requirements:</p> <ul> <li>For native header support: \"Service parameters are transmitted using HTTP request headers. Service parameter keys are case-insensitive and must conform to RFC 7230. Service parameter values must be UTF-8 strings.\"</li> <li>For protocols without headers: \"Service parameters are serialized as a JSON object and transmitted in the request metadata field <code>a2a-service-parameters</code>.\"</li> </ul>"},{"location":"specification/#124-error-mapping","title":"12.4. Error Mapping","text":"<p>Custom bindings MUST:</p> <ol> <li>Map Standard Errors: Provide mappings for all A2A-specific error types defined in Section 3.2.2 (Error Handling)</li> <li>Preserve Error Information: Ensure error details are accessible to clients</li> <li>Use Appropriate Codes: Map to protocol-native error codes where applicable</li> <li>Document Error Format: Specify the structure of error responses</li> </ol>"},{"location":"specification/#125-streaming-support","title":"12.5. Streaming Support","text":"<p>If the binding supports streaming operations:</p> <ol> <li>Define Stream Mechanism: Document how streaming is implemented (e.g., WebSockets, long-polling, chunked encoding)</li> <li>Event Ordering: Specify ordering guarantees for streaming events</li> <li>Reconnection: Define behavior for connection interruption and resumption</li> <li>Stream Termination: Specify how stream completion is signaled</li> </ol> <p>If streaming is not supported, the binding MUST clearly document this limitation in the Agent Card.</p>"},{"location":"specification/#126-authentication-and-authorization","title":"12.6. Authentication and Authorization","text":"<p>Custom bindings MUST:</p> <ol> <li>Support Standard Schemes: Implement authentication schemes declared in the Agent Card</li> <li>Document Integration: Specify how credentials are transmitted in the protocol</li> <li>Handle Challenges: Define how authentication challenges are communicated</li> <li>Maintain Security: Follow security best practices for the transport protocol</li> </ol>"},{"location":"specification/#127-agent-card-declaration","title":"12.7. Agent Card Declaration","text":"<p>Custom bindings MUST be declared in the Agent Card:</p> <ol> <li>Transport Identifier: Use a clear, descriptive transport name</li> <li>Endpoint URL: Provide the full URL where the binding is available</li> <li>Documentation Link: Include a URL to the complete binding specification</li> </ol> <p>Example:</p> <pre><code>{\n  \"supportedInterfaces\": [\n    {\n      \"url\": \"wss://agent.example.com/a2a/websocket\",\n      \"protocolBinding\": \"WEBSOCKET\"\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#128-interoperability-testing","title":"12.8. Interoperability Testing","text":"<p>Custom binding implementers SHOULD:</p> <ol> <li>Test Against Reference: Verify behavior matches standard bindings</li> <li>Document Differences: Clearly note any deviations from standard binding behavior</li> <li>Provide Examples: Include sample requests and responses</li> <li>Test Edge Cases: Verify handling of error conditions, large payloads, and long-running tasks</li> </ol>"},{"location":"specification/#13-security-considerations","title":"13. Security Considerations","text":"<p>This section consolidates security guidance and best practices for implementing and operating A2A agents. For additional enterprise security considerations, see Enterprise-Ready Features.</p>"},{"location":"specification/#131-data-access-and-authorization-scoping","title":"13.1. Data Access and Authorization Scoping","text":"<p>Implementations MUST ensure appropriate scope limitation based on the authenticated caller's authorization boundaries. This applies to all operations that access or list tasks and other resources.</p> <p>Authorization Principles:</p> <ul> <li>Servers MUST implement authorization checks on every A2A Protocol Operations request</li> <li>Implementations MUST scope results to the caller's authorized access boundaries as defined by the agent's authorization model</li> <li>Even when <code>contextId</code> or other filter parameters are not specified in requests, implementations MUST scope results to the caller's authorized access boundaries</li> <li>Authorization models are agent-defined and MAY be based on:<ul> <li>User identity (user-based authorization)</li> <li>Organizational roles or groups (role-based authorization)</li> <li>Project or workspace membership (project-based authorization)</li> <li>Organizational or tenant boundaries (multi-tenant authorization)</li> <li>Custom authorization logic specific to the agent's domain</li> </ul> </li> </ul> <p>Operations Requiring Scope Limitation:</p> <ul> <li><code>List Tasks</code>: MUST only return tasks visible to the authenticated client according to the agent's authorization model</li> <li><code>Get Task</code>: MUST verify the authenticated client has access to the requested task according to the agent's authorization model</li> <li>Task-related operations (Cancel, Subscribe, Push Notification Config): MUST verify the client has appropriate access rights according to the agent's authorization model</li> </ul> <p>Implementation Requirements:</p> <ul> <li>Authorization boundaries are defined by each agent's authorization model, not prescribed by the protocol</li> <li>Authorization checks MUST occur before any database queries or operations that could leak information about the existence of resources outside the caller's authorization scope</li> <li>Agents SHOULD document their authorization model and access control policies</li> </ul> <p>See also: Section 3.1.4 List Tasks (Security Note) for operation-specific requirements.</p>"},{"location":"specification/#132-push-notification-security","title":"13.2. Push Notification Security","text":"<p>When implementing push notifications, both agents (as webhook callers) and clients (as webhook receivers) have security responsibilities.</p> <p>Agent (Webhook Caller) Requirements:</p> <ul> <li>Agents MUST include authentication credentials in webhook requests as specified in <code>PushNotificationConfig.authentication</code></li> <li>Agents SHOULD implement reasonable timeout values for webhook requests (recommended: 10-30 seconds)</li> <li>Agents SHOULD implement retry logic with exponential backoff for failed deliveries</li> <li>Agents MAY stop attempting delivery after a configured number of consecutive failures</li> <li>Agents SHOULD validate webhook URLs to prevent SSRF (Server-Side Request Forgery) attacks:<ul> <li>Reject private IP ranges (127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)</li> <li>Reject localhost and link-local addresses</li> <li>Implement URL allowlists where appropriate</li> </ul> </li> </ul> <p>Client (Webhook Receiver) Requirements:</p> <ul> <li>Clients MUST validate webhook authenticity using the provided authentication credentials</li> <li>Clients SHOULD verify the task ID in the payload matches an expected task they created</li> <li>Clients MUST respond with HTTP 2xx status codes to acknowledge successful receipt</li> <li>Clients SHOULD process notifications idempotently, as duplicate deliveries may occur</li> <li>Clients SHOULD implement rate limiting to prevent webhook flooding</li> <li>Clients SHOULD use HTTPS endpoints for webhook URLs to ensure confidentiality</li> </ul> <p>Configuration Security:</p> <ul> <li>Webhook URLs SHOULD use HTTPS to protect payload confidentiality in transit</li> <li>Authentication tokens in <code>PushNotificationConfig</code> SHOULD be treated as secrets and rotated periodically</li> <li>Agents SHOULD securely store push notification configurations and credentials</li> <li>Clients SHOULD use unique, single-purpose tokens for each push notification configuration</li> </ul> <p>See also: Section 4.3 Push Notification Objects and Section 4.3.3 Push Notification Payload.</p>"},{"location":"specification/#133-extended-agent-card-access-control","title":"13.3. Extended Agent Card Access Control","text":"<p>The extended Agent Card feature allows agents to provide additional capabilities or information to authenticated clients beyond what is available in the public Agent Card.</p> <p>Access Control Requirements:</p> <ul> <li>The <code>Get Extended Agent Card</code> operation MUST require authentication</li> <li>Agents MUST authenticate requests using one of the schemes declared in the public <code>AgentCard.securitySchemes</code> and <code>AgentCard.security</code> fields</li> <li>Agents MAY return different extended card content based on the authenticated client's identity or authorization level</li> <li>Agents SHOULD implement appropriate caching headers to control client-side caching of extended cards</li> </ul> <p>Capability-Based Access:</p> <ul> <li>Extended cards MAY include additional skills not present in the public card</li> <li>Extended cards MAY expose more detailed capability information (e.g., rate limits, quotas)</li> <li>Extended cards MAY include organization-specific or user-specific configuration</li> <li>Agents SHOULD document which capabilities are available at different authentication levels</li> </ul> <p>Security Considerations:</p> <ul> <li>Extended cards SHOULD NOT include sensitive information that could be exploited if leaked (e.g., internal service URLs, unmasked credentials)</li> <li>Agents MUST validate that clients have appropriate permissions before returning privileged information in extended cards</li> <li>Clients retrieving extended cards SHOULD replace their cached public Agent Card with the extended version for the duration of their authenticated session</li> <li>Agents SHOULD version extended cards appropriately and honor client cache invalidation</li> </ul> <p>Availability Declaration:</p> <ul> <li>Agents declare extended card support via <code>AgentCard.capabilities.extendedAgentCard</code></li> <li>When <code>capabilities.extendedAgentCard</code> is <code>false</code> or not present, the operation MUST return <code>UnsupportedOperationError</code></li> <li>When support is declared but no extended card is configured, the operation MUST return <code>ExtendedAgentCardNotConfiguredError</code></li> </ul> <p>See also: Section 3.1.11 Get Extended Agent Card and Section 3.3.4 Capability Validation.</p>"},{"location":"specification/#134-general-security-best-practices","title":"13.4. General Security Best Practices","text":"<p>Transport Security:</p> <ul> <li>Production deployments MUST use encrypted communication (HTTPS for HTTP-based bindings, TLS for gRPC)</li> <li>Implementations SHOULD use modern TLS configurations (TLS 1.3+ recommended) with strong cipher suites</li> <li>Agents SHOULD enforce HSTS (HTTP Strict Transport Security) headers when using HTTP-based bindings</li> <li>Implementations SHOULD disable support for deprecated SSL/TLS versions (SSLv3, TLS 1.0, TLS 1.1)</li> </ul> <p>Input Validation:</p> <ul> <li>Agents MUST validate all input parameters before processing</li> <li>Agents SHOULD implement appropriate limits on message sizes, file sizes, and request complexity</li> <li>Agents SHOULD sanitize or validate file content types and reject unexpected media types</li> </ul> <p>Credential Management:</p> <ul> <li>API keys, tokens, and other credentials MUST be treated as secrets</li> <li>Credentials SHOULD be rotated periodically</li> <li>Credentials SHOULD be transmitted only over encrypted connections</li> <li>Agents SHOULD implement credential revocation mechanisms</li> <li>Agents SHOULD log authentication failures and implement rate limiting to prevent brute-force attacks</li> </ul> <p>Audit and Monitoring:</p> <ul> <li>Agents SHOULD log security-relevant events (authentication failures, authorization denials, suspicious requests)</li> <li>Agents SHOULD implement monitoring for unusual patterns (rapid task creation, excessive cancellations)</li> <li>Agents SHOULD provide audit trails for sensitive operations</li> <li>Logs MUST NOT include sensitive information (credentials, personal data) unless required and properly protected</li> </ul> <p>Rate Limiting and Abuse Prevention:</p> <ul> <li>Agents SHOULD implement rate limiting on all operations</li> <li>Agents SHOULD return appropriate error responses when rate limits are exceeded</li> <li>Agents MAY implement different rate limits for different operations or user tiers</li> </ul> <p>Data Privacy:</p> <ul> <li>Agents MUST comply with applicable data protection regulations</li> <li>Agents SHOULD provide mechanisms for users to request deletion of their data</li> <li>Agents SHOULD implement appropriate data retention policies</li> <li>Agents SHOULD minimize logging of sensitive or personal information</li> </ul> <p>Custom Binding Security:</p> <ul> <li>Custom protocol bindings MUST address security considerations in their specification</li> <li>Custom bindings SHOULD follow the same security principles as standard bindings</li> <li>Custom bindings MUST document authentication integration and credential transmission</li> </ul> <p>See also: Section 12.6 Authentication and Authorization (Custom Bindings).</p>"},{"location":"specification/#14-iana-considerations","title":"14. IANA Considerations","text":"<p>This section provides registration templates for the A2A protocol's media type, HTTP headers, and well-known URI, intended for submission to the Internet Assigned Numbers Authority (IANA).</p>"},{"location":"specification/#141-media-type-registration","title":"14.1. Media Type Registration","text":""},{"location":"specification/#1411-applicationa2ajson","title":"14.1.1. application/a2a+json","text":"<p>Type name: <code>application</code></p> <p>Subtype name: <code>a2a+json</code></p> <p>Required parameters: None</p> <p>Optional parameters:</p> <ul> <li>None</li> </ul> <p>Encoding considerations: Binary (UTF-8 encoding MUST be used for JSON text)</p> <p>Security considerations: This media type shares security considerations common to all JSON-based formats as described in RFC 8259, Section 12. Additionally:</p> <ul> <li>Content MUST be validated against the A2A protocol schema before processing</li> <li>Implementations MUST sanitize user-provided content to prevent injection attacks</li> <li>File references within A2A messages MUST be validated to prevent server-side request forgery (SSRF)</li> <li>Authentication and authorization MUST be enforced as specified in Section 7 of the A2A specification</li> <li>Sensitive information in task history and artifacts MUST be protected according to applicable data protection regulations</li> </ul> <p>Interoperability considerations: The A2A protocol supports multiple protocol bindings. This media type is intended for the HTTP+JSON/REST binding.</p> <p>Published specification: Agent2Agent (A2A) Protocol Specification, available at: https://a2a-protocol.org/latest/specification</p> <p>Applications that use this media type: AI agent platforms, agentic workflow systems, multi-agent collaboration tools, and enterprise automation systems that implement the A2A protocol for agent-to-agent communication.</p> <p>Fragment identifier considerations: None</p> <p>Additional information:</p> <ul> <li>Deprecated alias names for this type: None</li> <li>Magic number(s): None</li> <li>File extension(s): .a2a.json</li> <li>Macintosh file type code(s): TEXT</li> </ul> <p>Person &amp; email address to contact for further information: A2A Protocol Working Group, a2a-protocol@example.org</p> <p>Intended usage: COMMON</p> <p>Restrictions on usage: None</p> <p>Author: A2A Protocol Working Group</p> <p>Change controller: A2A Protocol Working Group</p> <p>Provisional registration: No</p>"},{"location":"specification/#142-http-header-field-registrations","title":"14.2. HTTP Header Field Registrations","text":"<p>Note: The following HTTP headers represent the HTTP-based protocol binding implementation of the abstract A2A service parameters defined in Section 3.2.6. These registrations are specific to HTTP/HTTPS transports.</p>"},{"location":"specification/#1421-a2a-version-header","title":"14.2.1. A2A-Version Header","text":"<p>Header field name: A2A-Version</p> <p>Applicable protocol: HTTP</p> <p>Status: Standard</p> <p>Author/Change controller: A2A Protocol Working Group</p> <p>Specification document: Section 3.2.5 of the A2A Protocol Specification</p> <p>Related information: The A2A-Version header field indicates the A2A protocol version that the client is using. The value MUST be in the format <code>Major.Minor</code> (e.g., \"0.3\"). If the version is not supported by the agent, the agent returns a <code>VersionNotSupportedError</code>.</p> <p>Example:</p> <pre><code>A2A-Version: 0.3\n</code></pre>"},{"location":"specification/#1422-a2a-extensions-header","title":"14.2.2. A2A-Extensions Header","text":"<p>Header field name: A2A-Extensions</p> <p>Applicable protocol: HTTP</p> <p>Status: Standard</p> <p>Author/Change controller: A2A Protocol Working Group</p> <p>Specification document: Section 3.2.5 of the A2A Protocol Specification</p> <p>Related information: The A2A-Extensions header field contains a comma-separated list of extension URIs that the client wants to use for the request. Extensions allow agents to provide additional functionality beyond the core A2A specification while maintaining backward compatibility.</p> <p>Example:</p> <pre><code>A2A-Extensions: https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1\n</code></pre>"},{"location":"specification/#143-well-known-uri-registration","title":"14.3. Well-Known URI Registration","text":"<p>URI suffix: agent-card.json</p> <p>Change controller: A2A Protocol Working Group</p> <p>Specification document: Section 8.2 of the A2A Protocol Specification</p> <p>Related information: The <code>.well-known/agent-card.json</code> URI provides a standardized location for discovering an A2A agent's capabilities, supported protocols, authentication requirements, and available skills. The resource at this URI MUST return an AgentCard object as defined in Section 4.4.1 of the A2A specification.</p> <p>Status: Permanent</p> <p>Security considerations:</p> <ul> <li>The Agent Card MAY contain public information about an agent's capabilities and SHOULD NOT include sensitive credentials or internal implementation details</li> <li>Implementations SHOULD support HTTPS to ensure authenticity and integrity of the Agent Card</li> <li>Agent Cards MAY be signed using JSON Web Signatures (JWS) as specified in the AgentCardSignature object (Section 4.4.7)</li> <li>Clients SHOULD verify signatures when present to ensure the Agent Card has not been tampered with</li> <li>Extended Agent Cards retrieved via authenticated endpoints (Section 3.1.11) MAY contain additional information and MUST enforce appropriate access controls</li> </ul> <p>Example:</p> <pre><code>https://agent.example.com/.well-known/agent-card.json\n</code></pre>"},{"location":"specification/#appendix-a-migration-legacy-compatibility","title":"Appendix A. Migration &amp; Legacy Compatibility","text":"<p>This appendix catalogs renamed protocol messages and objects, their legacy identifiers, and the planned deprecation/removal schedule. All legacy names and anchors MUST remain resolvable until the stated earliest removal version.</p> Legacy Name Current Name Earliest Removal Version Notes <code>MessageSendParams</code> <code>SendMessageRequest</code> &gt;= 0.5.0 Request payload rename for clarity (request vs params) <code>SendMessageSuccessResponse</code> <code>SendMessageResponse</code> &gt;= 0.5.0 Unified success response naming <code>SendStreamingMessageSuccessResponse</code> <code>StreamResponse</code> &gt;= 0.5.0 Shorter, binding-agnostic streaming response <code>SetTaskPushNotificationConfigRequest</code> <code>CreateTaskPushNotificationConfigRequest</code> &gt;= 0.5.0 Explicit creation intent <code>ListTaskPushNotificationConfigSuccessResponse</code> <code>ListTaskPushNotificationConfigResponse</code> &gt;= 0.5.0 Consistent response suffix removal <code>GetAuthenticatedExtendedCardRequest</code> <code>GetExtendedAgentCardRequest</code> &gt;= 0.5.0 Removed \"Authenticated\" from naming <p>Planned Lifecycle (example timeline; adjust per release strategy):</p> <ol> <li>0.3.x: New names introduced; legacy names documented; aliases added.</li> <li>0.4.x: Legacy names marked \"deprecated\" in SDKs and schemas; warning notes added.</li> <li>\u22650.5.0: Legacy names eligible for removal after review; migration appendix updated.</li> </ol>"},{"location":"specification/#a1-legacy-documentation-anchors","title":"A.1 Legacy Documentation Anchors","text":"<p>Hidden anchor spans preserve old inbound links:</p> <p> </p> <p> </p> <p>Each legacy span SHOULD be placed adjacent to the current object's heading (to be inserted during detailed object section edits). If an exact numeric-prefixed anchor existed (e.g., <code>#414-message</code>), add an additional span matching that historical form if known.</p>"},{"location":"specification/#a2-migration-guidance","title":"A.2 Migration Guidance","text":"<p>Client Implementations SHOULD:</p> <ul> <li>Prefer new names immediately for all new integrations.</li> <li>Implement dual-handling where schemas/types permit (e.g., union type or backward-compatible decoder).</li> <li>Log a warning when receiving legacy-named objects after the first deprecation announcement release.</li> </ul> <p>Server Implementations MAY:</p> <ul> <li>Accept both legacy and current request message forms during the overlap period.</li> <li>Emit only current form in responses (recommended) while providing explicit upgrade notes.</li> </ul>"},{"location":"specification/#a21-breaking-change-kind-discriminator-removed","title":"A.2.1 Breaking Change: Kind Discriminator Removed","text":"<p>Version 1.0 introduces a breaking change in how polymorphic objects are represented in the protocol. This affects <code>Part</code> types and streaming event types.</p> <p>Legacy Pattern (v0.3.x): Objects used an inline <code>kind</code> field as a discriminator to identify the object type:</p> <p>Example 1 - TextPart:</p> <pre><code>{\n  \"kind\": \"TextPart\",\n  \"text\": \"Hello, world!\"\n}\n</code></pre> <p>Example 2 - FilePart:</p> <pre><code>{\n  \"kind\": \"FilePart\",\n  \"mimeType\": \"image/png\",\n  \"name\": \"diagram.png\",\n  \"fileWithBytes\": \"iVBORw0KGgo...\"\n}\n</code></pre> <p>Current Pattern (v1.0): Objects now use the JSON member name itself to identify the type. The member name acts as the discriminator, and the value structure depends on the specific type:</p> <p>Example 1 - TextPart:</p> <pre><code>{\n  \"text\": \"Hello, world!\"\n}\n</code></pre> <p>Example 2 - FilePart:</p> <pre><code>{\n  \"file\": {\n    \"mediaType\": \"image/png\",\n    \"name\": \"diagram.png\",\n    \"fileWithBytes\": \"iVBORw0KGgo...\"\n  }\n}\n</code></pre> <p>Affected Types:</p> <ol> <li>Part Union Types:</li> <li>TextPart:<ul> <li>Legacy: <code>{ \"kind\": \"TextPart\", \"text\": \"...\" }</code></li> <li>Current: <code>{ \"text\": \"...\" }</code> (direct string value)</li> </ul> </li> <li>FilePart:<ul> <li>Legacy: <code>{ \"kind\": \"FilePart\", \"mimeType\": \"...\", \"name\": \"...\", \"fileWithBytes\": \"...\" }</code></li> <li>Current: <code>{ \"file\": { \"mediaType\": \"...\", \"name\": \"...\", \"fileWithBytes\": \"...\" } }</code></li> </ul> </li> <li> <p>DataPart:</p> <ul> <li>Legacy: <code>{ \"kind\": \"DataPart\", \"data\": {...} }</code></li> <li>Current: <code>{ \"data\": { \"data\": {...} } }</code></li> </ul> </li> <li> <p>Streaming Event Types:</p> </li> <li>TaskStatusUpdateEvent:<ul> <li>Legacy: <code>{ \"kind\": \"TaskStatusUpdateEvent\", \"taskId\": \"...\", \"status\": {...} }</code></li> <li>Current: <code>{ \"statusUpdate\": { \"taskId\": \"...\", \"status\": {...} } }</code></li> </ul> </li> <li>TaskArtifactUpdateEvent:<ul> <li>Legacy: <code>{ \"kind\": \"TaskArtifactUpdateEvent\", \"taskId\": \"...\", \"artifact\": {...} }</code></li> <li>Current: <code>{ \"artifactUpdate\": { \"taskId\": \"...\", \"artifact\": {...} } }</code></li> </ul> </li> </ol> <p>Migration Strategy:</p> <p>For Clients upgrading from pre-0.3.x:</p> <ol> <li>Update parsers to expect wrapper objects with member names as discriminators</li> <li>When constructing requests, use the new wrapper format</li> <li>Implement version detection based on the agent's <code>protocolVersions</code> in the <code>AgentCard</code></li> <li>Consider maintaining backward compatibility by detecting and handling both formats during a transition period</li> </ol> <p>For Servers upgrading from pre-0.3.x:</p> <ol> <li>Update serialization logic to emit wrapper objects</li> <li>Breaking: The <code>kind</code> field is no longer part of the protocol and should not be emitted</li> <li>Update deserialization to expect wrapper objects with member names</li> <li>Ensure the <code>AgentCard</code> declares the correct <code>protocolVersions</code> (e.g., [\"1.0\"] or later)</li> </ol> <p>Rationale:</p> <p>This change aligns with modern API design practices and Protocol Buffers' <code>oneof</code> semantics, where the field name itself serves as the type discriminator. This approach:</p> <ul> <li>Reduces redundancy (no need for both a field name and a <code>kind</code> value)</li> <li>Aligns JSON-RPC and gRPC representations more closely</li> <li>Simplifies code generation from schema definitions</li> <li>Eliminates the need for representing inheritance structures in schema languages</li> <li>Improves type safety in strongly-typed languages</li> </ul>"},{"location":"specification/#a22-breaking-change-extended-agent-card-field-relocated","title":"A.2.2 Breaking Change: Extended Agent Card Field Relocated","text":"<p>Version 1.0 relocates the extended agent card capability from a top-level field to the capabilities object for architectural consistency.</p> <p>Legacy Structure (pre-1.0):</p> <pre><code>{\n  \"supportsExtendedAgentCard\": true,\n  \"capabilities\": {\n    \"streaming\": true\n  }\n}\n</code></pre> <p>Current Structure (1.0+):</p> <pre><code>{\n  \"capabilities\": {\n    \"streaming\": true,\n    \"extendedAgentCard\": true\n  }\n}\n</code></pre> <p>Proto Changes:</p> <ul> <li>Removed: <code>AgentCard.supports_extended_agent_card</code> (field 13)</li> <li>Added: <code>AgentCapabilities.extended_agent_card</code> (field 5)</li> </ul> <p>Migration Steps:</p> <p>For Agent Implementations:</p> <ol> <li>Remove <code>supportsExtendedAgentCard</code> from top-level AgentCard</li> <li>Add <code>extendedAgentCard</code> to <code>capabilities</code> object</li> <li>Update validation: <code>agentCard.capabilities?.extendedAgentCard</code></li> </ol> <p>For Client Implementations:</p> <ol> <li>Update capability checks: <code>agentCard.capabilities?.extendedAgentCard</code></li> <li>Temporary fallback (transition period):</li> </ol> <pre><code>const supported = agentCard.capabilities?.extendedAgentCard ||\n                  agentCard.supportsExtendedAgentCard;\n</code></pre> <ol> <li>Remove fallback after agent ecosystem migrates</li> </ol> <p>For SDK Developers:</p> <ol> <li>Regenerate code from updated proto</li> <li>Update type definitions</li> <li>Document breaking change in release notes</li> </ol> <p>Rationale:</p> <p>All optional features enabling specific operations (<code>streaming</code>, <code>pushNotifications</code>, <code>stateTransitionHistory</code>) reside in <code>AgentCapabilities</code>. Moving <code>extendedAgentCard</code> achieves:</p> <ul> <li>Architectural consistency</li> <li>Improved discoverability</li> <li>Semantic correctness (it is a capability)</li> </ul>"},{"location":"specification/#a3-future-automation","title":"A.3 Future Automation","text":"<p>Once the proto\u2192schema generation pipeline lands, this appendix will be partially auto-generated (legacy mapping table sourced from a maintained manifest). Until then, edits MUST be manual and reviewed in PRs affecting <code>a2a.proto</code>.</p>"},{"location":"specification/#appendix-b-relationship-to-mcp-model-context-protocol","title":"Appendix B. Relationship to MCP (Model Context Protocol)","text":"<p>A2A and MCP are complementary protocols designed for different aspects of agentic systems:</p> <ul> <li>Model Context Protocol (MCP): Focuses on standardizing how AI models and agents connect to and interact with tools, APIs, data sources, and other external resources. It defines structured ways to describe tool capabilities (like function calling in LLMs), pass inputs, and receive structured outputs. Think of MCP as the \"how-to\" for an agent to use a specific capability or access a resource.</li> <li>Agent2Agent Protocol (A2A): Focuses on standardizing how independent, often opaque, AI agents communicate and collaborate with each other as peers. A2A provides an application-level protocol for agents to discover each other, negotiate interaction modalities, manage shared tasks, and exchange conversational context or complex results. It's about how agents partner or delegate work.</li> </ul> <p>How they work together: An A2A Client agent might request an A2A Server agent to perform a complex task. The Server agent, in turn, might use MCP to interact with several underlying tools, APIs, or data sources to gather information or perform actions necessary to fulfill the A2A task.</p> <p>For a more detailed comparison, see the A2A and MCP guide.</p>"},{"location":"sdk/","title":"A2A SDK","text":"<p>A2A currently hosts SDKs in five languages (Python, Go, JS, Java, .NET).</p> <p>The following table lists the supported languages and their stability.</p> Language Support Python Stable Go Stable Java Stable JavaScript Stable C#/.NET Stable <p>The A2A project provides numerous samples across supported languages in the a2a-samples repository.</p>"},{"location":"topics/a2a-and-mcp/","title":"A2A and MCP: Detailed Comparison","text":"<p>In AI agent development, two key protocol types emerge to facilitate interoperability. One connects agents to tools and resources. The other enables agent-to-agent collaboration. The Agent2Agent (A2A) Protocol and the Model Context Protocol (MCP) address these distinct but highly complementary needs.</p>"},{"location":"topics/a2a-and-mcp/#model-context-protocol","title":"Model Context Protocol","text":"<p>The Model Context Protocol (MCP) defines how an AI agent interacts with and utilizes individual tools and resources, such as a database or an API.</p> <p>This protocol offers the following capabilities:</p> <ul> <li>Standardizes how AI models and agents connect to and interact with tools,   APIs, and other external resources.</li> <li>Defines a structured way to describe tool capabilities, similar to function   calling in Large Language Models.</li> <li>Passes inputs to tools and receives structured outputs.</li> <li>Supports common use cases, such as an LLM calling an external API, an agent   querying a database, or an agent connecting to predefined functions.</li> </ul>"},{"location":"topics/a2a-and-mcp/#agent2agent-protocol","title":"Agent2Agent Protocol","text":"<p>The Agent2Agent Protocol focuses on enabling different agents to collaborate with one another to achieve a common goal.</p> <p>This protocol offers the following capabilities:</p> <ul> <li>Standardizes how independent, often opaque, AI agents communicate and   collaborate as peers.</li> <li>Provides an application-level protocol for agents to discover each other,   negotiate interactions, manage shared tasks, and exchange conversational   context and complex data.</li> <li>Supports typical use cases, including a customer service agent delegating an   inquiry to a billing agent, or a travel agent coordinating with flight,   hotel, and activity agents.</li> </ul>"},{"location":"topics/a2a-and-mcp/#why-different-protocols","title":"Why Different Protocols?","text":"<p>Both the MCP and A2A protocols are essential for building complex AI systems, and they address distinct but highly complementary needs. The distinction between A2A and MCP depends on what an agent interacts with.</p> <ul> <li>Tools and Resources (MCP Domain):<ul> <li>Characteristics: These are typically primitives with well-defined,     structured inputs and outputs. They perform specific, often stateless,     functions. Examples include a calculator, a database query API, or a     weather lookup service.</li> <li>Purpose: Agents use tools to gather information and perform discrete     functions.</li> </ul> </li> <li>Agents (A2A domain):<ul> <li>Characteristics: These are more autonomous systems. They reason,     plan, use multiple tools, maintain state over longer interactions, and     engage in complex, often multi-turn dialogues to achieve novel or     evolving tasks.</li> <li>Purpose: Agents collaborate with other agents to tackle broader, more     complex goals.</li> </ul> </li> </ul>"},{"location":"topics/a2a-and-mcp/#a2a-mcp-complementary-protocols-for-agentic-systems","title":"A2A \u2764\ufe0f MCP: Complementary Protocols for Agentic Systems","text":"<p>An agentic application might primarily use A2A to communicate with other agents. Each individual agent internally uses MCP to interact with its specific tools and resources.</p> <p></p> <p>An agentic application might use A2A to communicate with other agents, while each agent internally uses MCP to interact with its specific tools and resources.</p>"},{"location":"topics/a2a-and-mcp/#example-scenario-the-auto-repair-shop","title":"Example Scenario: The Auto Repair Shop","text":"<p>Consider an auto repair shop staffed by autonomous AI agent \"mechanics\". These mechanics use special-purpose tools, such as vehicle diagnostic scanners, repair manuals, and platform lifts, to diagnose and repair problems. The repair process can involve extensive conversations, research, and interaction with part suppliers.</p> <ul> <li> <p>Customer Interaction (User-to-Agent using A2A): A customer (or their     primary assistant agent) uses A2A to communicate with the \"Shop Manager\"     agent.</p> <p>For example, the customer might say, \"My car is making a rattling noise\".</p> </li> <li> <p>Multi-turn Diagnostic Conversation (Agent-to-Agent using A2A): The Shop     Manager agent uses A2A for a multi-turn diagnostic conversation.</p> <p>For example, the Manager might ask, \"Can you send a video of the noise?\" or \"I see some fluid leaking. How long has this been happening?\".</p> </li> <li> <p>Internal Tool Usage (Agent-to-Tool using MCP): The Mechanic agent,     assigned the task by the Shop Manager, needs to diagnose the issue. The     Mechanic agent uses MCP to interact with its specialized tools.</p> <p>For example:</p> <ul> <li>MCP call to a \"Vehicle Diagnostic Scanner\" tool:     <code>scan_vehicle_for_error_codes(vehicle_id='XYZ123')</code></li> <li>MCP call to a \"Repair Manual Database\" tool:     <code>get_repair_procedure(error_code='P0300', vehicle_make='Toyota',     vehicle_model='Camry')</code></li> <li>MCP call to a \"Platform Lift\" tool: <code>raise_platform(height_meters=2)</code></li> </ul> </li> <li> <p>Supplier Interaction (Agent-to-Agent using A2A): The Mechanic agent     determines that a specific part is needed. The Mechanic agent uses A2A to     communicate with a \"Parts Supplier\" agent to order a part.     For example, the     Mechanic agent might ask, \"Do you have part #12345 in stock for a Toyota Camry 2018?\"</p> </li> <li> <p>Order processing (Agent-to-Agent using A2A): The Parts Supplier agent,     which is also an A2A-compliant system, responds, potentially leading to an     order.</p> </li> </ul> <p>In this example:</p> <ul> <li>A2A facilitates the higher-level, conversational, and task-oriented     interactions between the customer and the shop, and between the shop's     agents and external supplier agents.</li> <li>MCP enables the mechanic agent to use its specific, structured tools to     perform its diagnostic and repair functions.</li> </ul> <p>An A2A server could expose some of its skills as MCP-compatible resources. However, A2A's primary strength lies in its support for more flexible, stateful, and collaborative interactions. These interactions go beyond a typical tool invocation. A2A focuses on agents partnering on tasks, whereas MCP focuses on agents using capabilities.</p>"},{"location":"topics/a2a-and-mcp/#representing-a2a-agents-as-mcp-resources","title":"Representing A2A Agents as MCP Resources","text":"<p>An A2A Server (a remote agent) could expose some of its skills as MCP-compatible resources, especially if those skills are well-defined and can be invoked in a more tool-like, stateless manner. In such a case, another agent might \"discover\" this A2A agent's specific skill through an MCP-style tool description (perhaps derived from its Agent Card).</p> <p>However, the primary strength of A2A lies in its support for more flexible, stateful, and collaborative interactions that go beyond typical tool invocation. A2A is about agents partnering on tasks, while MCP is more about agents using capabilities.</p> <p>By leveraging both A2A for inter-agent collaboration and MCP for tool integration, developers can build more powerful, flexible, and interoperable AI systems.</p>"},{"location":"topics/agent-discovery/","title":"Agent Discovery in A2A","text":"<p>To collaborate using the Agent2Agent (A2A) protocol, AI agents need to first find each other and understand their capabilities. A2A standardizes agent self-descriptions through the Agent Card. However, discovery methods for these Agent Cards vary by environment and requirements. The Agent Card defines what an agent offers. Various strategies exist for a client agent to discover these cards. The choice of strategy depends on the deployment environment and security requirements.</p>"},{"location":"topics/agent-discovery/#the-role-of-the-agent-card","title":"The Role of the Agent Card","text":"<p>The Agent Card is a JSON document that serves as a digital \"business card\" for an A2A Server (the remote agent). It is crucial for agent discovery and interaction. The key information included in an Agent Card is as follows:</p> <ul> <li>Identity: Includes <code>name</code>, <code>description</code>, and <code>provider</code> information.</li> <li>Service Endpoint: Specifies the <code>url</code> for the A2A service.</li> <li>A2A Capabilities: Lists supported features such as <code>streaming</code> or <code>pushNotifications</code>.</li> <li>Authentication: Details the required <code>schemes</code> (e.g., \"Bearer\", \"OAuth2\").</li> <li>Skills: Describes the agent's tasks using <code>AgentSkill</code> objects, including <code>id</code>, <code>name</code>, <code>description</code>, <code>inputModes</code>, <code>outputModes</code>, and <code>examples</code>.</li> </ul> <p>Client agents use the Agent Card to determine an agent's suitability, structure requests, and ensure secure communication.</p>"},{"location":"topics/agent-discovery/#discovery-strategies","title":"Discovery Strategies","text":"<p>The following sections detail common strategies used by client agents to discover remote Agent Cards:</p>"},{"location":"topics/agent-discovery/#1-well-known-uri","title":"1. Well-Known URI","text":"<p>This approach is recommended for public agents or agents intended for broad discovery within a specific domain.</p> <ul> <li> <p>Mechanism: A2A Servers make their Agent Card discoverable by hosting it at a standardized, <code>well-known</code> URI on their domain. The standard path is <code>https://{agent-server-domain}/.well-known/agent-card.json</code>, following the principles of RFC 8615.</p> </li> <li> <p>Process:</p> <ol> <li>A client agent knows or programmatically discovers the domain of a potential A2A Server (e.g., <code>smart-thermostat.example.com</code>).</li> <li>The client performs an HTTP GET request to <code>https://smart-thermostat.example.com/.well-known/agent-card.json</code>.</li> <li>If the Agent Card exists and is accessible, the server returns it as a JSON response.</li> </ol> </li> <li> <p>Advantages:</p> <ul> <li>Ease of implementation</li> <li>Adheres to standards</li> <li>Facilitates automated discovery</li> </ul> </li> <li> <p>Considerations:</p> <ul> <li>Best suited for open or domain-controlled discovery scenarios.</li> <li>Authentication is necessary at the endpoint serving the Agent Card if it contains sensitive details.</li> </ul> </li> </ul>"},{"location":"topics/agent-discovery/#2-curated-registries-catalog-based-discovery","title":"2. Curated Registries (Catalog-Based Discovery)","text":"<p>This approach is employed in enterprise environments or public marketplaces, where Agent Cards are often managed by a central registry. The curated registry acts as a central repository, allowing clients to query and discover agents based on criteria like \"skills\" or \"tags\".</p> <ul> <li> <p>Mechanism: An intermediary service (the registry) maintains a collection of Agent Cards. Clients query this registry to find agents based on various criteria (e.g., skills offered, tags, provider name, capabilities).</p> </li> <li> <p>Process:</p> <ol> <li>A2A Servers publish their Agent Cards to the registry.</li> <li>Client agents query the registry's API, and search by criteria such as \"specific skills\".</li> <li>The registry returns matching Agent Cards or references.</li> </ol> </li> <li> <p>Advantages:</p> <ul> <li>Centralized management and governance.</li> <li>Capability-based discovery (e.g., by skill).</li> <li>Support for access controls and trust frameworks.</li> <li>Applicable in both private and public marketplaces.</li> </ul> </li> <li>Considerations:<ul> <li>Requires deployment and maintenance of a registry service.</li> <li>The current A2A specification does not prescribe a standard API for curated registries.</li> </ul> </li> </ul>"},{"location":"topics/agent-discovery/#3-direct-configuration-private-discovery","title":"3. Direct Configuration / Private Discovery","text":"<p>This approach is used for tightly coupled systems, private agents, or development purposes, where clients are directly configured with Agent Card information or URLs.</p> <ul> <li>Mechanism: Client applications utilize hardcoded details, configuration files, environment variables, or proprietary APIs for discovery.</li> <li>Process: The process is specific to the application's deployment and configuration strategy.</li> <li>Advantages: This method is straightforward for establishing connections within known, static relationships.</li> <li>Considerations:<ul> <li>Inflexible for dynamic discovery scenarios.</li> <li>Changes to Agent Card information necessitate client reconfiguration.</li> <li>Proprietary API-based discovery also lacks standardization.</li> </ul> </li> </ul>"},{"location":"topics/agent-discovery/#securing-agent-cards","title":"Securing Agent Cards","text":"<p>Agent Cards include sensitive information, such as:</p> <ul> <li>URLs for internal or restricted agents.</li> <li>Descriptions of sensitive skills.</li> </ul>"},{"location":"topics/agent-discovery/#protection-mechanisms","title":"Protection Mechanisms","text":"<p>To mitigate risks, the following protection mechanisms should be considered:</p> <ul> <li>Authenticated Agent Cards: We recommend the use of authenticated extended agent cards for sensitive information or for serving a more detailed version of the card.</li> <li> <p>Secure Endpoints: Implement access controls on the HTTP endpoint serving the Agent Card (e.g., <code>/.well-known/agent-card.json</code> or registry API). The methods include:</p> <ul> <li>Mutual TLS (mTLS)</li> <li>Network restrictions (e.g., IP ranges)</li> <li>HTTP Authentication (e.g., OAuth 2.0)</li> </ul> </li> <li> <p>Registry Selective Disclosure: Registries return different Agent Cards based on the client's identity and permissions.</p> </li> </ul> <p>Any Agent Card containing sensitive data must be protected with authentication and authorization mechanisms. The A2A specification strongly recommends the use of out-of-band dynamic credentials rather than embedding static secrets within the Agent Card.</p>"},{"location":"topics/agent-discovery/#future-considerations","title":"Future Considerations","text":"<p>The A2A community explores standardizing registry interactions or advanced discovery protocols.</p>"},{"location":"topics/enterprise-ready/","title":"Enterprise Implementation of A2A","text":"<p>The Agent2Agent (A2A) protocol is designed with enterprise requirements at its core. Rather than inventing new, proprietary standards for security and operations, A2A aims to integrate seamlessly with existing enterprise infrastructure and widely adopted best practices. This approach allows organizations to use their existing investments and expertise in security, monitoring, governance, and identity management.</p> <p>A key principle of A2A is that agents are typically opaque because they don't share internal memory, tools, or direct resource access with each other. This opacity naturally aligns with standard client-server security paradigms, treating remote agents as standard HTTP-based enterprise applications.</p>"},{"location":"topics/enterprise-ready/#transport-level-security-tls","title":"Transport Level Security (TLS)","text":"<p>Ensuring the confidentiality and integrity of data in transit is fundamental for any enterprise application.</p> <ul> <li>HTTPS Mandate: All A2A communication in production environments must     occur over <code>HTTPS</code>.</li> <li>Modern TLS Standards: Implementations should use modern TLS versions.     TLS 1.2 or higher is recommended. Strong, industry-standard cipher suites     should be used to protect data from eavesdropping and tampering.</li> <li>Server Identity Verification: A2A clients should verify the A2A server's     identity by validating its TLS certificate against trusted certificate     authorities during the TLS handshake. This prevents man-in-the-middle     attacks.</li> </ul>"},{"location":"topics/enterprise-ready/#authentication","title":"Authentication","text":"<p>A2A delegates authentication to standard web mechanisms. It primarily relies on HTTP headers and established standards like OAuth2 and OpenID Connect. Authentication requirements are advertised by the A2A server in its Agent Card.</p> <ul> <li>No Identity in Payload: A2A protocol payloads, such as <code>JSON-RPC</code>     messages, don't carry user or client identity information directly. Identity     is established at the transport/HTTP layer.</li> <li>Agent Card Declaration: The A2A server's Agent Card describes the     authentication schemes it supports in its <code>security</code> field and aligns with     those defined in the OpenAPI Specification for authentication.</li> <li>Out-of-Band Credential Acquisition: The A2A Client obtains the necessary credentials,     such as OAuth 2.0 tokens or API keys, through processes external to the A2A protocol itself. Examples include OAuth flows or secure key distribution.</li> <li>HTTP Header Transmission: Credentials must be transmitted in standard     HTTP headers as per the requirements of the chosen authentication scheme.     Examples include <code>Authorization: Bearer &lt;TOKEN&gt;</code> or <code>API-Key: &lt;KEY_VALUE&gt;</code>.</li> <li>Server-Side Validation: The A2A server must authenticate every     incoming request using the credentials provided in the HTTP headers.<ul> <li>If authentication fails or credentials are missing, the server should     respond with a standard HTTP status code:<ul> <li><code>401 Unauthorized</code>: If the credentials are missing or invalid. This     response should include a <code>WWW-Authenticate</code> header to inform     the client about the supported authentication methods.</li> <li><code>403 Forbidden</code>: If the credentials are valid, but the authenticated     client does not have permission to perform the requested action.</li> </ul> </li> </ul> </li> <li>In-Task Authentication (Secondary Credentials): If an agent needs     additional credentials to access a different system or service during a     task (for example, to use a specific tool on the user's behalf), the A2A server     indicates to the client that more information is needed. The client     is then responsible for obtaining these secondary credentials through a     process outside of the A2A protocol itself (for example, an OAuth flow) and     providing them back to the A2A server to continue the task.</li> </ul>"},{"location":"topics/enterprise-ready/#authorization","title":"Authorization","text":"<p>Once a client is authenticated, the A2A server is responsible for authorizing the request. Authorization logic is specific to the agent's implementation, the data it handles, and applicable enterprise policies.</p> <ul> <li>Granular Control: Authorization should be applied based on the     authenticated identity, which could represent an end user, a client     application, or both.</li> <li>Skill-Based Authorization: Access can be controlled on a per-skill     basis, as advertised in the Agent Card. For example, specific OAuth scopes     should grant an authenticated client access to invoke certain skills but     not others.</li> <li>Data and Action-Level Authorization: Agents that interact with backend     systems, databases, or tools must enforce appropriate authorization before     performing sensitive actions or accessing sensitive data through those     underlying resources. The agent acts as a gatekeeper.</li> <li>Principle of Least Privilege: Agents must grant only the necessary     permissions required for a client or user to perform their intended     operations through the A2A interface.</li> </ul>"},{"location":"topics/enterprise-ready/#data-privacy-and-confidentiality","title":"Data Privacy and Confidentiality","text":"<p>Protecting sensitive data exchanged between agents is paramount, requiring strict adherence to privacy regulations and best practices.</p> <ul> <li>Sensitivity Awareness: Implementers must be acutely aware of the     sensitivity of data exchanged in Message and Artifact parts of A2A     interactions.</li> <li>Compliance: Ensure compliance with relevant data privacy regulations     such as GDPR, CCPA, and HIPAA, based on the domain and data involved.</li> <li>Data Minimization: Avoid including or requesting unnecessarily sensitive     information in A2A exchanges.</li> <li>Secure Handling: Protect data both in transit, using TLS as mandated,     and at rest if persisted by agents, according to enterprise data security     policies and regulatory requirements.</li> </ul>"},{"location":"topics/enterprise-ready/#tracing-observability-and-monitoring","title":"Tracing, Observability, and Monitoring","text":"<p>A2A's reliance on HTTP allows for straightforward integration with standard enterprise tracing, logging, and monitoring tools, providing critical visibility into inter-agent workflows.</p> <ul> <li>Distributed Tracing: A2A Clients and Servers should participate in     distributed tracing systems. For example, use OpenTelemetry to propagate     trace context, including trace IDs and span IDs, through standard HTTP     headers, such as W3C Trace Context headers. This enables end-to-end     visibility for debugging and performance analysis.</li> <li>Comprehensive Logging: Log details on both client and server, including     taskId, sessionId, correlation IDs, and trace context for troubleshooting     and auditing.</li> <li>Metrics: A2A servers should expose key operational metrics, such as     request rates, error rates, task processing latency, and resource     utilization, to enable performance monitoring, alerting, and capacity     planning.</li> <li>Auditing: Audit significant events, such as task creation, critical     state changes, and agent actions, especially when involving sensitive data     or high-impact operations.</li> </ul>"},{"location":"topics/enterprise-ready/#api-management-and-governance","title":"API Management and Governance","text":"<p>For A2A servers exposed externally, across organizational boundaries, or even within large enterprises, integration with API Management solutions is highly recommended, as this provides:</p> <ul> <li>Centralized Policy Enforcement: Consistent application of security     policies such as authentication and authorization, rate limiting, and quotas.</li> <li>Traffic Management: Load balancing, routing, and mediation.</li> <li>Analytics and Reporting: Insights into agent usage, performance, and     trends.</li> <li>Developer Portals: Facilitate discovery of A2A-enabled agents, provide documentation such as Agent Cards, and streamline onboarding for client developers.</li> </ul> <p>By adhering to these enterprise-grade practices, A2A implementations can be deployed securely, reliably, and manageably within complex organizational environments. This fosters trust and enables scalable inter-agent collaboration.</p>"},{"location":"topics/extensions/","title":"Extensions in A2A","text":"<p>The Agent2Agent (A2A) protocol provides a strong foundation for inter-agent communication. However, specific domains or advanced use cases often require additional structure, custom data, or new interaction patterns beyond the generic methods. Extensions are A2A's powerful mechanism for layering new capabilities onto the base protocol.</p> <p>Extensions allow for extending the A2A protocol with new data, requirements, RPC methods, and state machines. Agents declare their support for specific extensions in their Agent Card, and clients can then opt in to the behavior offered by an extension as part of requests they make to the agent. Extensions are identified by a URI and defined by their own specification. Anyone is able to define, publish, and implement an extension.</p> <p>The flexibility of extensions allows for customizing A2A without fragmenting the core standard, fostering innovation and domain-specific optimizations.</p>"},{"location":"topics/extensions/#scope-of-extensions","title":"Scope of Extensions","text":"<p>The exact set of possible ways to use extensions is intentionally broad, facilitating the ability to expand A2A beyond known use cases. However, some foreseeable applications include:</p> <ul> <li>Data-only Extensions: Exposing new, structured information in the Agent     Card that doesn't impact the request-response flow. For example, an     extension could add structured data about an agent's GDPR compliance.</li> <li>Profile Extensions: Overlaying additional structure and state change     requirements on the core request-response messages. This type effectively     acts as a profile on the core A2A protocol, narrowing the space of allowed     values (for example, requiring all messages to use <code>DataParts</code> adhering to     a specific schema). This can also include augmenting existing states in the     task state machine by using metadata. For example, an extension could define     a 'generating-image' substate when <code>TaskStatus.state</code> is 'working' and     <code>TaskStatus.message.metadata[\"generating-image\"]</code> is true.</li> <li>Method Extensions (Extended Skills): Adding entirely new RPC methods     beyond the core set defined by the protocol. An Extended Skill refers to a     capability or function an agent gains or exposes specifically through the     implementation of an extension that defines new RPC methods. For example, a     <code>task-history</code> extension might add a <code>tasks/search</code> RPC method to retrieve     a list of previous tasks, effectively providing the agent with a new,     extended skill.</li> <li>State Machine Extensions: Adding new states or transitions to the task   state machine.</li> </ul>"},{"location":"topics/extensions/#list-of-example-extensions","title":"List of Example Extensions","text":"Extension Description Secure Passport Extension Adds a trusted, contextual layer for immediate personalization and reduced overhead (v1). Hello World or Timestamp Extension A simple extension demonstrating how to augment base A2A types by adding timestamps to the <code>metadata</code> field of <code>Message</code> and <code>Artifact</code> objects (v1). Traceability Extension Explore the Python implementation and basic usage of the Traceability Extension (v1). Agent Gateway Protocol (AGP) Extension A Core Protocol Layer or Routing Extension that introduces Autonomous Squads (ASq) and routes Intent payloads based on declared Capabilities, enhancing scalability (v1)."},{"location":"topics/extensions/#limitations","title":"Limitations","text":"<p>There are some changes to the protocol that extensions don't allow, primarily to prevent breaking core type validations:</p> <ul> <li>Changing the Definition of Core Data Structures: For example, adding new     fields or removing required fields to protocol-defined data structures).     Extensions should place custom attributes in the <code>metadata</code> map present on     core data structures.</li> <li>Adding New Values to Enum Types: Extensions should use existing enum values     and annotate additional semantic meaning in the <code>metadata</code> field.</li> </ul>"},{"location":"topics/extensions/#extension-declaration","title":"Extension Declaration","text":"<p>Agents declare their support for extensions in their Agent Card by including <code>AgentExtension</code> objects within their <code>AgentCapabilities</code> object.</p> <pre><code>\n</code></pre> <p>The following is an example of an Agent Card with an extension:</p> <pre><code>{\n  \"name\": \"Magic 8-ball\",\n  \"description\": \"An agent that can tell your future... maybe.\",\n  \"version\": \"0.1.0\",\n  \"url\": \"https://example.com/agents/eightball\",\n  \"capabilities\": {\n    \"streaming\": true,\n    \"extensions\": [\n      {\n        \"uri\": \"https://example.com/ext/konami-code/v1\",\n        \"description\": \"Provide cheat codes to unlock new fortunes\",\n        \"required\": false,\n        \"params\": {\n          \"hints\": [\n            \"When your sims need extra cash fast\",\n            \"You might deny it, but we've seen the evidence of those cows.\"\n          ]\n        }\n      }\n    ]\n  },\n  \"defaultInputModes\": [\"text/plain\"],\n  \"defaultOutputModes\": [\"text/plain\"],\n  \"skills\": [\n    {\n      \"id\": \"fortune\",\n      \"name\": \"Fortune teller\",\n      \"description\": \"Seek advice from the mystical magic 8-ball\",\n      \"tags\": [\"mystical\", \"untrustworthy\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"topics/extensions/#required-extensions","title":"Required Extensions","text":"<p>While extensions generally offer optional functionality, some agents may have stricter requirements. When an Agent Card declares an extension as <code>required: true</code>, it signals to clients that some aspect of the extension impacts how requests are structured or processed, and that the client must abide by it. Agents shouldn't mark data-only extensions as required. If a client does not request activation of a required extension, or fails to follow its protocol, the agent should reject the incoming request with an appropriate error.</p>"},{"location":"topics/extensions/#extension-specification","title":"Extension Specification","text":"<p>The detailed behavior and structure of an extension are defined by its specification. While the exact format is not mandated, it should contain at least:</p> <ul> <li>The specific URI(s) that identify the extension.</li> <li>The schema and meaning of objects specified in the <code>params</code> field of the     <code>AgentExtension</code> object.</li> <li>Schemas of any additional data structures communicated between client and     agent.</li> <li>Details of new request-response flows, additional endpoints, or any other     logic required to implement the extension.</li> </ul>"},{"location":"topics/extensions/#extension-dependencies","title":"Extension Dependencies","text":"<p>Extensions might depend on other extensions. This can be a required dependency (where the extension cannot function without the dependent) or an optional one (where additional functionality is enabled if another extension is present). Extension specifications should document these dependencies. It is the client's responsibility to activate an extension and all its required dependencies as listed in the extension's specification.</p>"},{"location":"topics/extensions/#extension-activation","title":"Extension Activation","text":"<p>Extensions default to being inactive, providing a baseline experience for extension-unaware clients. Clients and agents perform negotiation to determine which extensions are active for a specific request.</p> <ol> <li>Client Request: A client requests extension activation by including the     <code>A2A-Extensions</code> header in the HTTP request to the agent. The value is a     comma-separated list of extension URIs the client intends to activate.</li> <li>Agent Processing: Agents are responsible for identifying supported     extensions in the request and performing the activation. Any requested     extensions not supported by the agent can be ignored.</li> <li>Response: Once the agent has identified all activated extensions, the     response SHOULD include the <code>A2A-Extensions</code> header, listing all     extensions that were successfully activated for that request.</li> </ol> <p></p> <p>Example request showing extension activation:</p> <pre><code>POST /agents/eightball HTTP/1.1\nHost: example.com\nContent-Type: application/json\nA2A-Extensions: https://example.com/ext/konami-code/v1\nContent-Length: 519\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"message/send\",\n  \"id\": \"1\",\n  \"params\": {\n    \"message\": {\n      \"kind\": \"message\",\n      \"messageId\": \"1\",\n      \"role\": \"user\",\n      \"parts\": [{\"kind\": \"text\", \"text\": \"Oh magic 8-ball, will it rain today?\"}]\n    },\n    \"metadata\": {\n      \"https://example.com/ext/konami-code/v1/code\": \"motherlode\"\n    }\n  }\n}\n</code></pre> <p>Corresponding response echoing activated extensions:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nA2A-Extensions: https://example.com/ext/konami-code/v1\nContent-Length: 338\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"result\": {\n    \"kind\": \"message\",\n    \"messageId\": \"2\",\n    \"role\": \"agent\",\n    \"parts\": [{\"kind\": \"text\", \"text\": \"That's a bingo!\"}]\n  }\n}\n</code></pre>"},{"location":"topics/extensions/#implementation-considerations","title":"Implementation Considerations","text":"<p>While the A2A protocol defines the functionality of extensions, this section provides guidance on their implementation\u2014best practices for authoring, versioning, and distributing extension implementations.</p> <ul> <li>Versioning: Extension specifications evolve. It is     crucial to have a clear versioning strategy to ensure that clients and     agents can negotiate compatible implementations.<ul> <li>Recommendation: Use the extension's URI as the primary version     identifier, ideally including a version number (for example,     <code>https://example.com/ext/my-extension/v1</code>).</li> <li>Breaking Changes: A new URI MUST be used when introducing a breaking     change to an extension's logic, data structures, or required parameters.</li> <li>Handling Mismatches: If a client requests a version not supported by     the agent, the agent SHOULD ignore the activation request for that     extension; it MUST NOT fall back to a different version.</li> </ul> </li> <li>Discoverability and Publication:<ul> <li>Specification Hosting: The extension specification document should be     hosted at the extension's URI.</li> <li>Permanent Identifiers: Authors are encouraged to use a permanent     identifier service, such as <code>w3id.org</code>, for their extension URIs to     prevent broken links.</li> <li>Community Registry (Future): The A2A community might establish a     central registry for discovering and browsing available extensions in     the future.</li> </ul> </li> <li> <p>Packaging and Reusability (A2A SDKs and Libraries):     To promote adoption, extension logic should be packaged into reusable         libraries that can be integrated into existing A2A client and         server applications.</p> <ul> <li>An extension implementation should be distributed as a     standard package for its language ecosystem (for example, a PyPI package     for Python, an npm package for TypeScript/JavaScript).</li> <li> <p>The objective is to provide a streamlined integration experience for     developers. A well-designed extension package should allow a developer     to add it to their server with minimal code, for example:</p> <pre><code>import logging\nimport os\n\nimport click\n\nfrom a2a.server.apps import A2AStarletteApplication\nfrom a2a.server.request_handlers import DefaultRequestHandler\nfrom a2a.server.tasks import InMemoryTaskStore\nfrom a2a.types import AgentCapabilities, AgentCard, AgentSkill\nfrom agent import ReimbursementAgent\nfrom agent_executor import ReimbursementAgentExecutor\nfrom dotenv import load_dotenv\nfrom timestamp_ext import TimestampExtension\n\n\nload_dotenv()\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass MissingAPIKeyError(Exception):\n    \"\"\"Exception for missing API key.\"\"\"\n\n\n@click.command()\n@click.option('--host', default='localhost')\n@click.option('--port', default=10002)\ndef main(host, port):\n    try:\n        # Check for API key only if Vertex AI is not configured\n        if not os.getenv('GOOGLE_GENAI_USE_VERTEXAI') == 'TRUE':\n            if not os.getenv('GEMINI_API_KEY'):\n                raise MissingAPIKeyError(\n                    'GEMINI_API_KEY environment variable not set and GOOGLE_GENAI_USE_VERTEXAI is not TRUE.'\n                )\n\n        hello_ext = TimestampExtension()\n        capabilities = AgentCapabilities(\n            streaming=True,\n            extensions=[\n                hello_ext.agent_extension(),\n            ],\n        )\n        skill = AgentSkill(\n            id='process_reimbursement',\n            name='Process Reimbursement Tool',\n            description='Helps with the reimbursement process for users given the amount and purpose of the reimbursement.',\n            tags=['reimbursement'],\n            examples=[\n                'Can you reimburse me $20 for my lunch with the clients?'\n            ],\n        )\n        agent_card = AgentCard(\n            name='Reimbursement Agent',\n            description='This agent handles the reimbursement process for the employees given the amount and purpose of the reimbursement.',\n            url=f'http://{host}:{port}/',\n            version='1.0.0',\n            default_input_modes=ReimbursementAgent.SUPPORTED_CONTENT_TYPES,\n            default_output_modes=ReimbursementAgent.SUPPORTED_CONTENT_TYPES,\n            capabilities=capabilities,\n            skills=[skill],\n        )\n        agent_executor = ReimbursementAgentExecutor()\n        # Use the decorator version of the extension for highest ease of use.\n        agent_executor = hello_ext.wrap_executor(agent_executor)\n        request_handler = DefaultRequestHandler(\n            agent_executor=agent_executor,\n            task_store=InMemoryTaskStore(),\n        )\n        server = A2AStarletteApplication(\n            agent_card=agent_card, http_handler=request_handler\n        )\n        import uvicorn\n\n        uvicorn.run(server.build(), host=host, port=port)\n    except MissingAPIKeyError as e:\n        logger.error(f'Error: {e}')\n        exit(1)\n    except Exception as e:\n        logger.error(f'An error occurred during server startup: {e}')\n        exit(1)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This example showcases how A2A SDKs or libraries such as <code>a2a.server</code> in Python facilitate the implementation of A2A agents and extensions.</p> </li> </ul> </li> <li> <p>Security: Extensions modify the core behavior of the A2A protocol, and therefore     introduce new security considerations:</p> <ul> <li>Input Validation: Any new data fields, parameters, or methods     introduced by an extension MUST be rigorously validated. Treat all     extension-related data from an external party as untrusted input.</li> <li>Scope of Required Extensions: Be mindful when marking an extension as     <code>required: true</code> in an Agent Card. This creates a hard dependency for     all clients and should only be used for extensions fundamental to the     agent's core function and security (for example, a message signing     extension).</li> <li>Authentication and Authorization: If an extension adds new methods,     the implementation MUST ensure these methods are subject to the same     authentication and authorization checks as the core A2A methods. An     extension MUST NOT provide a way to bypass the agent's primary security     controls.</li> </ul> </li> </ul> <p>For more information, see the A2A Extensions: Empowering Custom Agent Functionality blog post.</p>"},{"location":"topics/key-concepts/","title":"Core Concepts and Components in A2A","text":"<p>A2A uses a set of core concepts that define how agents interact. Understand these core building blocks to develop or integrate with A2A-compliant systems.</p> <p></p>"},{"location":"topics/key-concepts/#core-actors-in-a2a-interactions","title":"Core Actors in A2A Interactions","text":"<ul> <li>User: The end user, which can be a human operator or an automated     service. The user initiates a request or defines a goal that requires     assistance from one or more AI agents.</li> <li>A2A Client (Client Agent): An application, service, or another AI agent     that acts on behalf of the user. The client initiates communication using the     A2A protocol.</li> <li>A2A Server (Remote Agent): An AI agent or an agentic system that exposes     an HTTP endpoint implementing the A2A protocol. It receives requests from     clients, processes tasks, and returns results or status updates. From the client's perspective,     the remote agent operates as an opaque (black-box) system, meaning its internal workings, memory, or tools are not exposed.</li> </ul>"},{"location":"topics/key-concepts/#fundamental-communication-elements","title":"Fundamental Communication Elements","text":"<p>The following table describes the fundamental communication elements in A2A:</p> Element Description Key Purpose Agent Card A JSON metadata document describing an agent's identity, capabilities, endpoint, skills, and authentication requirements. Enables clients to discover agents and understand how to interact with them securely and effectively. Task A stateful unit of work initiated by an agent, with a unique ID and defined lifecycle. Facilitates tracking of long-running operations and enables multi-turn interactions and collaboration. Message A single turn of communication between a client and an agent, containing content and a role (\"user\" or \"agent\"). Conveys instructions, context, questions, answers, or status updates that are not necessarily formal artifacts. Part The fundamental content container (for example, TextPart, FilePart, DataPart) used within Messages and Artifacts. Provides flexibility for agents to exchange various content types within messages and artifacts. Artifact A tangible output generated by an agent during a task (for example, a document, image, or structured data). Delivers the concrete results of an agent's work, ensuring structured and retrievable outputs."},{"location":"topics/key-concepts/#interaction-mechanisms","title":"Interaction Mechanisms","text":"<p>The A2A Protocol supports various interaction patterns to accommodate different needs for responsiveness and persistence. These mechanisms ensure that agents can exchange information efficiently and reliably, regardless of the task's complexity or duration:</p> <ul> <li>Request/Response (Polling): Clients send a request and the server     responds. For long-running tasks, the client periodically polls the server     for updates.</li> <li>Streaming with Server-Sent Events (SSE): Clients initiate a stream to     receive real-time, incremental results or status updates from the server     over an open HTTP connection.</li> <li>Push Notifications: For very long-running tasks or disconnected     scenarios, the server can actively send asynchronous notifications to a     client-provided webhook when significant task updates occur.</li> </ul> <p>For a detailed exploration of streaming and push notifications, refer to the Streaming &amp; Asynchronous Operations document.</p>"},{"location":"topics/key-concepts/#agent-cards","title":"Agent Cards","text":"<p>The Agent Card is a JSON document that serves as a digital business card for initial discovery and interaction setup. It provides essential metadata about an agent. Clients parse this information to determine if an agent is suitable for a given task, how to structure requests, and how to communicate securely. Key information includes identity, service endpoint (URL), A2A capabilities, authentication requirements, and a list of skills.</p>"},{"location":"topics/key-concepts/#messages-and-parts","title":"Messages and Parts","text":"<p>A message represents a single turn of communication between a client and an agent. It includes a role (\"user\" or \"agent\") and a unique <code>messageId</code>. It contains one or more Part objects, which are granular containers for the actual content. This design allows A2A to be modality independent.</p> <p>The primary part kinds are:</p> <ul> <li><code>TextPart</code>: Contains plain textual content.</li> <li><code>FilePart</code>: Represents a file. It can be transmitted either inline (Base64    encoded) or through a URI. It includes metadata like \"name\" and \"mimeType\".</li> <li><code>DataPart</code>: Carries structured JSON data. This is useful for forms,    parameters, or any machine-readable information.</li> </ul>"},{"location":"topics/key-concepts/#artifacts","title":"Artifacts","text":"<p>An artifact represents a tangible output or a concrete result generated by a remote agent during task processing. Unlike general messages, artifacts are the actual deliverables. An artifact has a unique <code>artifactId</code>, a human-readable name, and consists of one or more part objects. Artifacts are closely tied to the task lifecycle and can be streamed incrementally to the client.</p>"},{"location":"topics/key-concepts/#agent-response-task-or-message","title":"Agent Response: Task or Message","text":"<p>The agent response can be a new <code>Task</code> (when the agent needs to perform a long-running operation) or a <code>Message</code> (when the agent can respond immediately).</p> <p>For more details, see Life of a Task.</p>"},{"location":"topics/key-concepts/#other-important-concepts","title":"Other Important Concepts","text":"<ul> <li>Context (<code>contextId</code>): A server-generated identifier that can be used to logically group multiple related <code>Task</code> objects, providing context across a series of interactions.</li> <li>Transport and Format: A2A communication occurs over HTTP(S). JSON-RPC 2.0 is used as the payload format for all requests and responses.</li> <li>Authentication &amp; Authorization: A2A relies on standard web security practices. Authentication requirements are declared in the Agent Card, and credentials (e.g., OAuth tokens, API keys) are typically passed through HTTP headers, separate from the A2A protocol messages themselves. For more information, see Enterprise-Ready Features.</li> <li>Agent Discovery: The process by which clients find Agent Cards to learn about available A2A Servers and their capabilities. For more information, see Agent Discovery.</li> <li>Extensions: A2A allows agents to declare custom protocol extensions as part of their AgentCard. For more information, see Extensions.</li> </ul>"},{"location":"topics/life-of-a-task/","title":"Life of a Task","text":"<p>In the Agent2Agent (A2A) Protocol, interactions can range from simple, stateless exchanges to complex, long-running processes. When an agent receives a message from a client, it can respond in one of two fundamental ways:</p> <ul> <li>Respond with a Stateless <code>Message</code>: This type of response is     typically used for immediate, self-contained interactions that conclude     without requiring further state management.</li> <li>Initiate a Stateful <code>Task</code>: If the response is a <code>Task</code>, the agent will     process it through a defined lifecycle, communicating progress and requiring     input as needed, until it reaches an interrupted state (e.g.,     <code>input-required</code>, <code>auth-required</code>) or a terminal state (e.g., <code>completed</code>,     <code>canceled</code>, <code>rejected</code>, <code>failed</code>).</li> </ul>"},{"location":"topics/life-of-a-task/#group-related-interactions","title":"Group Related Interactions","text":"<p>A <code>contextId</code> is a crucial identifier that logically groups multiple <code>Task</code> objects and independent <code>Message</code> objects, providing continuity across a series of interactions.</p> <ul> <li>When a client sends a message for the first time, the agent responds     with a new <code>contextId</code>. If a task is initiated, it will also have a <code>taskId</code>.</li> <li>Clients can send subsequent messages and include the same <code>contextId</code> to     indicate that they are continuing their previous interaction within the same     context.</li> <li>Clients optionally attach the <code>taskId</code> to a subsequent message to     indicate that it continues that specific task.</li> </ul> <p>The <code>contextId</code> enables collaboration towards a common goal or a shared contextual session across multiple, potentially concurrent tasks. Internally, an A2A agent (especially one using an LLM) uses the <code>contextId</code> to manage its internal conversational state or its LLM context.</p>"},{"location":"topics/life-of-a-task/#agent-response-message-or-task","title":"Agent Response: Message or Task","text":"<p>The choice between responding with a <code>Message</code> or a <code>Task</code> depends on the nature of the interaction and the agent's capabilities:</p> <ul> <li>Messages for Trivial Interactions: <code>Message</code> objects are suitable for     transactional interactions that don't require long-running     processing or complex state management. An agent might use messages to     negotiate the acceptance or scope of a task before committing to a <code>Task</code>     object.</li> <li>Tasks for Stateful Interactions: Once an agent maps the intent of an     incoming message to a supported capability that requires substantial,     trackable work over an extended period, the agent responds with a <code>Task</code>     object.</li> </ul> <p>Conceptually, agents operate at different levels of complexity:</p> <ul> <li>Message-only Agents: Always respond with <code>Message</code> objects. They     typically don't manage complex state or long-running executions, and use     <code>contextId</code> to tie messages together. These agents might directly wrap LLM     invocations and simple tools.</li> <li>Task-generating Agents: Always respond with <code>Task</code> objects, even for     responses, which are then modeled as completed tasks. Once a task is     created, the agent will only return <code>Task</code> objects in response to messages     sent, and once a task is complete, no more messages can be sent. This     approach avoids deciding between <code>Task</code> versus <code>Message</code>, but creates completed task objects     for even simple interactions.</li> <li>Hybrid Agents: Generate both <code>Message</code> and <code>Task</code> objects. These agents     use messages to negotiate agent capability and the scope of work for a task,     then send a <code>Task</code> object to track execution and manage states like     <code>input-required</code> or error handling. Once a task is created, the agent will     only return <code>Task</code> objects in response to messages sent, and once a task is     complete, no more messages can be sent. A hybrid agent uses messages to     negotiate the scope of a task, and then generate a task to track its     execution.     For more information about hybrid agents, see A2A protocol: Demystifying Tasks vs Messages.</li> </ul>"},{"location":"topics/life-of-a-task/#task-refinements","title":"Task Refinements","text":"<p>Clients often need to send new requests based on task results or refine the outputs of previous tasks. This is modeled by starting another interaction using the same <code>contextId</code> as the original task. Clients further hint the agent by providing references to the original task using <code>referenceTaskIds</code> in the <code>Message</code> object. The agent then responds with either a new <code>Task</code> or a <code>Message</code>.</p>"},{"location":"topics/life-of-a-task/#task-immutability","title":"Task Immutability","text":"<p>Once a task reaches a terminal state (completed, canceled, rejected, or failed), it cannot restart. Any subsequent interaction related to that task, such as a refinement, must initiate a new task within the same <code>contextId</code>. This principle offers several benefits:</p> <ul> <li>Task Immutability. Clients reliably reference tasks and their     associated state, artifacts, and messages, providing a clean mapping of     inputs to outputs. This is valuable for orchestration and traceability.</li> <li>Clear Unit of Work. Every new request, refinement, or follow-up becomes     a distinct task. This simplifies bookkeeping, allows for granular tracking     of an agent's work, and enables tracing each artifact to a specific unit of     work.</li> <li>Easier Implementation. This removes ambiguity for agent developers     regarding whether to create a new task or restart an existing one.</li> </ul>"},{"location":"topics/life-of-a-task/#parallel-follow-ups","title":"Parallel Follow-ups","text":"<p>A2A supports parallel work by enabling agents to create distinct, parallel tasks for each follow-up message sent within the same <code>contextId</code>. This allows clients to track individual tasks and create new dependent tasks as soon as a prerequisite task is complete.</p> <p>For example:</p> <ul> <li>Task 1: Book a flight to Helsinki.</li> <li>Task 2: Based on Task 1, book a hotel.</li> <li>Task 3: Based on Task 1, book a snowmobile activity.</li> <li>Task 4: Based on Task 2, add a spa reservation to the hotel booking.</li> </ul>"},{"location":"topics/life-of-a-task/#referencing-previous-artifacts","title":"Referencing Previous Artifacts","text":"<p>The serving agent infers the relevant artifact from a referenced task or from the <code>contextId</code>. As the domain expert, the serving agent is best suited to resolve ambiguity or identify missing information. If there is ambiguity, the agent asks the client for clarification by returning an <code>input-required</code> state. The client then specifies the artifact in its response, optionally populating artifact references (<code>artifactId</code>, <code>taskId</code>) in <code>Part</code> metadata.</p>"},{"location":"topics/life-of-a-task/#tracking-artifact-mutation","title":"Tracking Artifact Mutation","text":"<p>Follow-up or refinement tasks often lead to the creation of new artifacts based on older ones. Tracking these mutations is important to ensure that only the most recent version of an artifact is used in subsequent interactions. This could be conceptualized as a version history, where each new artifact is linked to its predecessor.</p> <p>However, the client is in the best position to manage this artifact linkage. The client determines what constitutes an acceptable result and has the ability to accept or reject new versions. Therefore, the serving agent shouldn't be responsible for tracking artifact mutations, and this linkage is not part of the A2A protocol specification. Clients should maintain this version history on their end and present the latest acceptable version to the user.</p> <p>To facilitate client-side tracking, serving agents should use a consistent <code>artifact-name</code> when generating a refined version of an existing artifact.</p> <p>When initiating follow-up or refinement tasks, the client should explicitly reference the specific artifact they intend to refine, ideally the \"latest\" version from their perspective. If the artifact reference is not provided, the serving agent can:</p> <ul> <li>Attempt to infer the intended artifact based on the current <code>contextId</code>.</li> <li>If there is ambiguity or insufficient context, the agent should respond with an <code>input-required</code> task state to request clarification from the client.</li> </ul>"},{"location":"topics/life-of-a-task/#example-follow-up-scenario","title":"Example Follow-up Scenario","text":"<p>The following example illustrates a typical task flow with a follow-up:</p> <ol> <li> <p>Client sends a message to the agent:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"method\": \"message.send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"text\": \"Generate an image of a sailboat on the ocean.\"\n        }\n      ],\n      \"messageId\": \"msg-user-001\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>Agent responds with a boat image (completed task):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"result\": {\n    \"id\": \"task-boat-gen-123\",\n    \"contextId\": \"ctx-conversation-abc\",\n    \"status\": {\n      \"state\": \"completed\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"artifact-boat-v1-xyz\",\n        \"name\": \"sailboat_image.png\",\n        \"description\": \"A generated image of a sailboat on the ocean.\",\n        \"parts\": [\n          {\n            \"file\": {\n              \"name\": \"sailboat_image.png\",\n              \"mediaType\": \"image/png\",\n              \"fileWithBytes\": \"base64_encoded_png_data_of_a_sailboat\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> </li> <li> <p>Client asks to color the boat red. This refinement request refers to the     previous <code>taskId</code> and uses the same <code>contextId</code>.</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"method\": \"message.send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"messageId\": \"msg-user-002\",\n      \"contextId\": \"ctx-conversation-abc\",\n      \"referenceTaskIds\": [\n        \"task-boat-gen-123\"\n      ],\n      \"parts\": [\n        {\n          \"text\": \"Please modify the sailboat to be red.\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> </li> <li> <p>Agent responds with a new image artifact (new task, same context, same     artifact name): The agent creates a new task within the same <code>contextId</code>. The     new boat image artifact retains the same name but has a new <code>artifactId</code>.</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"result\": {\n    \"id\": \"task-boat-color-456\",\n    \"contextId\": \"ctx-conversation-abc\",\n    \"status\": {\n      \"state\": \"completed\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"artifact-boat-v2-red-pqr\",\n        \"name\": \"sailboat_image.png\",\n        \"description\": \"A generated image of a red sailboat on the ocean.\",\n        \"parts\": [\n          {\n            \"file\": {\n              \"name\": \"sailboat_image.png\",\n              \"mediaType\": \"image/png\",\n              \"fileWithBytes\": \"base64_encoded_png_data_of_a_RED_sailboat\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> </li> </ol>"},{"location":"topics/streaming-and-async/","title":"Streaming and Asynchronous Operations for Long-Running Tasks","text":"<p>The Agent2Agent (A2A) protocol is explicitly designed to handle tasks that might not complete immediately. Many AI-driven operations are often long-running, involve multiple steps, produce incremental results, or require human intervention. A2A provides mechanisms for managing such asynchronous interactions, ensuring that clients receive updates effectively, whether they remain continuously connected or operate in a more disconnected fashion.</p>"},{"location":"topics/streaming-and-async/#streaming-with-server-sent-events-sse","title":"Streaming with Server-Sent Events (SSE)","text":"<p>For tasks that produce incremental results (like generating a long document or streaming media) or provide ongoing status updates, A2A supports real-time communication using Server-Sent Events (SSE). This approach is ideal when the client is able to maintain an active HTTP connection with the A2A Server.</p> <p>The following key features detail how SSE streaming is implemented and managed within the A2A protocol:</p> <ul> <li> <p>Server Capability: The A2A Server must indicate its support for streaming by setting <code>capabilities.streaming: true</code> in its Agent Card.</p> </li> <li> <p>Initiating a Stream: The client uses the <code>message/stream</code> RPC method to send an initial message (for example, a prompt or command) and simultaneously subscribe to updates for that task.</p> </li> <li> <p>Server Response and Connection: If the subscription is successful, the server responds with an HTTP 200 OK status and a <code>Content-Type: text/event-stream</code>. This HTTP connection remains open for the server to push events to the client.</p> </li> <li> <p>Event Structure and Types: The server sends events over this stream. Each event's <code>data</code> field contains a JSON-RPC 2.0 Response object, typically a <code>SendStreamingMessageResponse</code>. The <code>result</code> field of the <code>SendStreamingMessageResponse</code> contains:</p> <ul> <li><code>Task</code>: Represents the current state of the work.</li> <li><code>TaskStatusUpdateEvent</code>: Communicates changes in the task's lifecycle state (for example, from <code>working</code> to <code>input-required</code> or <code>completed</code>). It also provides intermediate messages from the agent.</li> <li><code>TaskArtifactUpdateEvent</code>: Delivers new or updated Artifacts generated by the task. This is used to stream large files or data structures in chunks, with fields like <code>append</code> and <code>lastChunk</code> to help reassemble.</li> </ul> </li> <li> <p>Stream Termination: When a task reaches a terminal or interrupted state (e.g., <code>COMPLETED</code>, <code>FAILED</code>, <code>CANCELED</code>, <code>REJECTED</code>, or <code>INPUT_REQUIRED</code>), the server closes the stream and sends no further updates.</p> </li> <li> <p>Resubscription: If a client's SSE connection breaks prematurely while a task is still active, the client is able to attempt to reconnect to the stream using the <code>tasks/resubscribe</code> RPC method.</p> </li> </ul>"},{"location":"topics/streaming-and-async/#when-to-use-streaming","title":"When to Use Streaming","text":"<p>Streaming with SSE is best suited for:</p> <ul> <li>Real-time progress monitoring of long-running tasks.</li> <li>Receiving large results (artifacts) incrementally.</li> <li>Interactive, conversational exchanges where immediate feedback or partial responses are beneficial.</li> <li>Applications requiring low-latency updates from the agent.</li> </ul>"},{"location":"topics/streaming-and-async/#protocol-specification-references","title":"Protocol Specification References","text":"<p>Refer to the Protocol Specification for detailed structures:</p> <ul> <li><code>message/stream</code></li> <li><code>tasks/subscribe</code></li> </ul>"},{"location":"topics/streaming-and-async/#push-notifications-for-disconnected-scenarios","title":"Push Notifications for Disconnected Scenarios","text":"<p>For very long-running tasks (for example, lasting minutes, hours, or even days) or when clients are unable to or prefer not to maintain persistent connections (like mobile clients or serverless functions), A2A supports asynchronous updates using push notifications. This allows the A2A Server to actively notify a client-provided webhook when a significant task update occurs.</p> <p>The following key features detail how push notifications are implemented and managed within the A2A protocol:</p> <ul> <li>Server Capability: The A2A Server must indicate its support for this feature by setting <code>capabilities.pushNotifications: true</code> in its Agent Card.</li> <li>Configuration: The client provides a <code>PushNotificationConfig</code> to the server. This configuration is supplied:<ul> <li>Within the initial <code>message/send</code> or <code>message/stream</code> request, or</li> <li>Separately, using the <code>tasks/pushNotificationConfig/set</code> RPC method for an existing task. The <code>PushNotificationConfig</code> includes a <code>url</code> (the HTTPS webhook URL), an optional <code>token</code> (for client-side validation), and optional <code>authentication</code> details (for the A2A Server to authenticate to the webhook).</li> </ul> </li> <li>Notification Trigger: The A2A Server decides when to send a push notification, typically when a task reaches a significant state change (for example, terminal state, <code>input-required</code>, or <code>auth-required</code>).</li> <li>Notification Payload: The A2A protocol defines the HTTP body payload as a <code>StreamResponse</code> object, matching the format used in streaming operations. The payload contains one of: <code>task</code>, <code>message</code>, <code>statusUpdate</code>, or <code>artifactUpdate</code>. See Push Notification Payload for detailed structure.</li> <li>Client Action: Upon receiving a push notification (and successfully verifying its authenticity), the client typically uses the <code>tasks/get</code> RPC method with the <code>taskId</code> from the notification to retrieve the complete, updated <code>Task</code> object, including any new artifacts.</li> </ul>"},{"location":"topics/streaming-and-async/#when-to-use-push-notifications","title":"When to Use Push Notifications","text":"<p>Push notifications are ideal for:</p> <ul> <li>Very long-running tasks that can take minutes, hours, or days to complete.</li> <li>Clients that cannot or prefer not to maintain persistent connections, such as mobile applications or serverless functions.</li> <li>Scenarios where clients only need to be notified of significant state changes rather than continuous updates.</li> </ul>"},{"location":"topics/streaming-and-async/#protocol-specification-references_1","title":"Protocol Specification References","text":"<p>Refer to the Protocol Specification for detailed structures:</p> <ul> <li><code>tasks/pushNotificationConfig/create</code></li> <li><code>tasks/get</code></li> </ul>"},{"location":"topics/streaming-and-async/#client-side-push-notification-service","title":"Client-Side Push Notification Service","text":"<p>The <code>url</code> specified in <code>PushNotificationConfig.url</code> points to a client-side Push Notification Service. This service is responsible for receiving the HTTP POST notification from the A2A Server. Its responsibilities include authenticating the incoming notification, validating its relevance, and relaying the notification or its content to the appropriate client application logic or system.</p>"},{"location":"topics/streaming-and-async/#security-considerations-for-push-notifications","title":"Security Considerations for Push Notifications","text":"<p>Security is paramount for push notifications due to their asynchronous and server-initiated outbound nature. Both the A2A Server (sending the notification) and the client's webhook receiver have critical responsibilities.</p>"},{"location":"topics/streaming-and-async/#a2a-server-security-when-sending-notifications-to-client-webhook","title":"A2A Server Security (when sending notifications to client webhook)","text":"<ul> <li>Webhook URL Validation: Servers SHOULD NOT blindly trust and send POST requests to any URL provided by a client. Malicious clients could provide URLs pointing to internal services or unrelated third-party systems, leading to Server-Side Request Forgery (SSRF) attacks or acting as Distributed Denial of Service (DDoS) amplifiers.<ul> <li>Mitigation strategies: Allowlisting of trusted domains, ownership verification (for example, challenge-response mechanisms), and network controls (e.g., egress firewalls).</li> </ul> </li> <li>Authenticating to the Client's Webhook: The A2A Server MUST authenticate itself to the client's webhook URL according to the scheme specified in <code>PushNotificationConfig.authentication</code>. Common schemes include Bearer Tokens (OAuth 2.0), API keys, HMAC signatures, or mutual TLS (mTLS).</li> </ul>"},{"location":"topics/streaming-and-async/#client-webhook-receiver-security-when-receiving-notifications-from-a2a-server","title":"Client Webhook Receiver Security (when receiving notifications from A2A server)","text":"<ul> <li>Authenticating the A2A Server: The webhook endpoint MUST rigorously verify the authenticity of incoming notification requests to ensure they originate from the legitimate A2A Server and not an imposter.<ul> <li>Verification methods: Verify signatures/tokens (for example, JWT signatures against the A2A Server's trusted public keys, HMAC signatures, or API key validation). Also, validate the <code>PushNotificationConfig.token</code> if provided.</li> </ul> </li> <li>Preventing Replay Attacks:<ul> <li>Timestamps: Notifications SHOULD include a timestamp. The webhook SHOULD reject notifications that are too old.</li> <li>Nonces/unique IDs: For critical notifications, consider using unique, single-use identifiers (for example, JWT's <code>jti</code> claim or event IDs) to prevent processing duplicate notifications.</li> </ul> </li> <li>Secure Key Management and Rotation: Implement secure key management practices, including regular key rotation, especially for cryptographic keys. Protocols like JWKS (JSON Web Key Set) facilitate key rotation for asymmetric keys.</li> </ul>"},{"location":"topics/streaming-and-async/#example-asymmetric-key-flow-jwt-jwks","title":"Example Asymmetric Key Flow (JWT + JWKS)","text":"<ol> <li>Client creates a <code>PushNotificationConfig</code> specifying <code>authentication.scheme: \"Bearer\"</code> and possibly an expected <code>issuer</code> or <code>audience</code> for the JWT.</li> <li>A2A Server, when sending a notification:<ul> <li>Generates a JWT, signing it with its private key. The JWT includes claims like <code>iss</code> (issuer), <code>aud</code> (audience), <code>iat</code> (issued at), <code>exp</code> (expires), <code>jti</code> (JWT ID), and <code>taskId</code>.</li> <li>The JWT header indicates the signing algorithm and key ID (<code>kid</code>).</li> <li>The A2A Server makes its public keys available through a JWKS endpoint.</li> </ul> </li> <li>Client Webhook, upon receiving the notification:<ul> <li>Extracts the JWT from the Authorization header.</li> <li>Inspects the <code>kid</code> (key ID) in the JWT header.</li> <li>Fetches the corresponding public key from the A2A Server's JWKS endpoint (caching keys is recommended).</li> <li>Verifies the JWT signature using the public key.</li> <li>Validates claims (<code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>, <code>jti</code>).</li> <li>Checks the <code>PushNotificationConfig.token</code> if provided.</li> </ul> </li> </ol> <p>This comprehensive, layered approach to security for push notifications helps ensure that messages are authentic, integral, and timely, protecting both the sending A2A Server and the receiving client webhook infrastructure.</p>"},{"location":"topics/what-is-a2a/","title":"What is A2A?","text":"<p>The A2A protocol is an open standard that enables seamless communication and collaboration between AI agents. It provides a common language for agents built using diverse frameworks and by different vendors, fostering interoperability and breaking down silos. Agents are autonomous problem-solvers that act independently within their environment. A2A allows agents from different developers, built on different frameworks, and owned by different organizations to unite and work together.</p>"},{"location":"topics/what-is-a2a/#why-use-the-a2a-protocol","title":"Why Use the A2A Protocol","text":"<p>A2A addresses key challenges in AI agent collaboration. It provides a standardized approach for agents to interact. This section explains the problems A2A solves and the benefits it offers.</p>"},{"location":"topics/what-is-a2a/#problems-that-a2a-solves","title":"Problems that A2A Solves","text":"<p>Consider a user request for an AI assistant to plan an international trip. This task involves orchestrating multiple specialized agents, such as:</p> <ul> <li>A flight booking agent</li> <li>A hotel reservation agent</li> <li>An agent for local tour recommendations</li> <li>A currency conversion agent</li> </ul> <p>Without A2A, integrating these diverse agents presents several challenges:</p> <ul> <li>Agent Exposure: Developers often wrap agents as tools to expose them to     other agents, similar to how tools are exposed in a Multi-agent Control     Platform (Model Context Protocol). However, this approach is inefficient because agents are     designed to negotiate directly. Wrapping agents as tools limits their capabilities.     A2A allows agents to be exposed as they are, without requiring this wrapping.</li> <li>Custom Integrations: Each interaction requires custom, point-to-point     solutions, creating significant engineering overhead.</li> <li>Slow Innovation: Bespoke development for each new integration slows     innovation.</li> <li>Scalability Issues: Systems become difficult to scale and maintain as     the number of agents and interactions grows.</li> <li>Interoperability: This approach limits interoperability,     preventing the organic formation of complex AI ecosystems.</li> <li>Security Gaps: Ad hoc communication often lacks consistent security     measures.</li> </ul> <p>The A2A protocol addresses these challenges by establishing interoperability for AI agents to interact reliably and securely.</p>"},{"location":"topics/what-is-a2a/#a2a-example-scenario","title":"A2A Example Scenario","text":"<p>This section provides an example scenario to illustrate the benefits of using an A2A (Agent2Agent) protocol for complex interactions between AI agents.</p>"},{"location":"topics/what-is-a2a/#a-users-complex-request","title":"A User's Complex Request","text":"<p>A user interacts with an AI assistant, giving it a complex prompt like \"Plan an international trip.\"</p> <pre><code>graph LR\n    User --&gt; Prompt --&gt; AI_Assistant[AI Assistant]</code></pre>"},{"location":"topics/what-is-a2a/#the-need-for-collaboration","title":"The Need for Collaboration","text":"<p>The AI assistant receives the prompt and realizes it needs to call upon multiple specialized agents to fulfill the request. These agents include a Flight Booking Agent, a Hotel Reservation Agent, a Currency Conversion Agent, and a Local Tours Agent.</p> <pre><code>graph LR\n    subgraph \"Specialized Agents\"\n        FBA[\u2708\ufe0f Flight Booking Agent]\n        HRA[\ud83c\udfe8 Hotel Reservation Agent]\n        CCA[\ud83d\udcb1 Currency Conversion Agent]\n        LTA[\ud83d\ude8c Local Tours Agent]\n    end\n\n    AI_Assistant[\ud83e\udd16 AI Assistant] --&gt; FBA\n    AI_Assistant --&gt; HRA\n    AI_Assistant --&gt; CCA\n    AI_Assistant --&gt; LTA</code></pre>"},{"location":"topics/what-is-a2a/#the-interoperability-challenge","title":"The Interoperability Challenge","text":"<p>The core problem: The agents are unable to work together because each has its own bespoke development and deployment.</p> <p>The consequence of a lack of a standardized protocol is that these agents cannot collaborate with each other let alone discover what they can do. The individual agents (Flight, Hotel, Currency, and Tours) are isolated.</p>"},{"location":"topics/what-is-a2a/#the-with-a2a-solution","title":"The \"With A2A\" Solution","text":"<p>The A2A Protocol provides standard methods and data structures for agents to communicate with one another, regardless of their underlying implementation, so the same agents can be used as an interconnected system, communicating seamlessly through the standardized protocol.</p> <p>The AI assistant, now acting as an orchestrator, receives the cohesive information from all the A2A-enabled agents. It then presents a single, complete travel plan as a seamless response to the user's initial prompt.</p> <p></p>"},{"location":"topics/what-is-a2a/#core-benefits-of-a2a","title":"Core Benefits of A2A","text":"<p>Implementing the A2A protocol offers significant advantages across the AI ecosystem:</p> <ul> <li>Secure collaboration: Without a standard, it's difficult to ensure     secure communication between agents. A2A uses HTTPS for secure communication     and maintains opaque operations, so agents can't see the inner workings of     other agents during collaboration.</li> <li>Interoperability: A2A breaks down silos between different AI     agent ecosystems, enabling agents from various vendors and frameworks to work     together seamlessly.</li> <li>Agent autonomy: A2A allows agents to retain their individual capabilities     and act as autonomous entities while collaborating with other agents.</li> <li>Reduced integration complexity: The protocol standardizes agent     communication, enabling teams to focus on the unique value their agents     provide.</li> <li>Support for LRO: The protocol supports long-running operations (LRO) and     streaming with Server-Sent Events (SSE) and asynchronous execution.</li> </ul>"},{"location":"topics/what-is-a2a/#key-design-principles-of-a2a","title":"Key Design Principles of A2A","text":"<p>A2A development follows principles that prioritize broad adoption, enterprise-grade capabilities, and future-proofing.</p> <ul> <li>Simplicity: A2A leverages existing standards like HTTP, JSON-RPC, and     Server-Sent Events (SSE). This avoids reinventing core technologies and     accelerates developer adoption.</li> <li>Enterprise Readiness: A2A addresses critical enterprise needs. It aligns     with standard web practices for robust authentication, authorization,     security, privacy, tracing, and monitoring.</li> <li>Asynchronous: A2A natively supports long-running tasks. It handles     scenarios where agents or users might not remain continuously connected. It     uses mechanisms like streaming and push notifications.</li> <li>Modality Independent: The protocol allows agents to communicate using a     wide variety of content types. This enables rich and flexible interactions     beyond plain text.</li> <li>Opaque Execution: Agents collaborate effectively without exposing their     internal logic, memory, or proprietary tools. Interactions rely on declared     capabilities and exchanged context. This preserves intellectual property and     enhances security.</li> </ul>"},{"location":"topics/what-is-a2a/#understanding-the-agent-stack-a2a-mcp-agent-frameworks-and-models","title":"Understanding the Agent Stack: A2A, MCP, Agent Frameworks and Models","text":"<p>A2A is situated within a broader agent stack, which includes:</p> <ul> <li>A2A: Standardizes communication among agents deployed in different organizations and developed using diverse frameworks.</li> <li>MCP: Connects models to data and external resources.</li> <li>Frameworks (like ADK): Provide toolkits for constructing agents.</li> <li>Models: Fundamental to an agent's reasoning, these can be any Large Language Model (LLM).</li> </ul> <p></p>"},{"location":"topics/what-is-a2a/#a2a-and-mcp","title":"A2A and MCP","text":"<p>In the broader ecosystem of AI communication, you might be familiar with protocols designed to facilitate interactions between agents, models, and tools. Notably, the Model Context Protocol (MCP) is an emerging standard focused on connecting Large Language Models (LLMs) with data and external resources.</p> <p>The Agent2Agent (A2A) protocol is designed to standardize communication between AI agents, particularly those deployed in external systems. A2A is positioned to complement MCP, addressing a distinct yet related aspect of agent interaction.</p> <ul> <li>MCP's Focus: Reducing the complexity involved in connecting agents with tools and data. Tools are typically stateless and perform specific, predefined functions (e.g., a calculator, a database query).</li> <li>A2A's Focus: Enabling agents to collaborate within their native modalities, allowing them to communicate as agents (or as users) rather than being constrained to tool-like interactions. This enables complex, multi-turn interactions where agents reason, plan, and delegate tasks to other agents. For example, this facilitates multi-turn interactions, such as those involving negotiation or clarification when placing an order.</li> </ul> <p></p> <p>The practice of encapsulating an agent as a simple tool is fundamentally limiting, as it fails to capture the agent's full capabilities. This critical distinction is explored in the post, Why Agents Are Not Tools.</p> <p>For a more in-depth comparison, refer to the A2A and MCP Comparison document.</p>"},{"location":"topics/what-is-a2a/#a2a-and-adk","title":"A2A and ADK","text":"<p>The Agent Development Kit (ADK) is an open-source agent development toolkit developed by Google. A2A is a communication protocol for agents that enables inter-agent communication, regardless of the framework used for their construction (e.g., ADK, LangGraph, or Crew AI). ADK is a flexible and modular framework for developing and deploying AI agents. While optimized for Gemini AI and the Google ecosystem, ADK is model-agnostic, deployment-agnostic, and built for compatibility with other frameworks.</p>"},{"location":"topics/what-is-a2a/#a2a-request-lifecycle","title":"A2A Request Lifecycle","text":"<p>The A2A request lifecycle is a sequence that details the four main steps a request follows: agent discovery, authentication, <code>sendMessage</code> API, and <code>sendMessageStream</code> API. The following diagram provides a deeper look into the operational flow, illustrating the interactions between the client, A2A server, and auth server.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant A2A Server\n    participant Auth Server\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 1. Agent Discovery\n    Client-&gt;&gt;A2A Server: GET agent card eg: (/.well-known/agent-card)\n    A2A Server--&gt;&gt;Client: Returns Agent Card\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, Auth Server: 2. Authentication\n    Client-&gt;&gt;Client: Parse Agent Card for securitySchemes\n    alt securityScheme is \"openIdConnect\"\n        Client-&gt;&gt;Auth Server: Request token based on \"authorizationUrl\" and \"tokenUrl\".\n        Auth Server--&gt;&gt;Client: Returns JWT\n    end\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 3. sendMessage API\n    Client-&gt;&gt;Client: Parse Agent Card for \"url\" param to send API requests to.\n    Client-&gt;&gt;A2A Server: POST /sendMessage (with JWT)\n    A2A Server-&gt;&gt;A2A Server: Process message and create task\n    A2A Server--&gt;&gt;Client: Returns Task Response\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 4. sendMessageStream API\n    Client-&gt;&gt;A2A Server: POST /sendMessageStream (with JWT)\n    A2A Server--&gt;&gt;Client: Stream: Task (Submitted)\n    A2A Server--&gt;&gt;Client: Stream: TaskStatusUpdateEvent (Working)\n    A2A Server--&gt;&gt;Client: Stream: TaskArtifactUpdateEvent (artifact A)\n    A2A Server--&gt;&gt;Client: Stream: TaskArtifactUpdateEvent (artifact B)\n    A2A Server--&gt;&gt;Client: Stream: TaskStatusUpdateEvent (Completed)\n    end</code></pre>"},{"location":"topics/what-is-a2a/#whats-next","title":"What's Next","text":"<p>Learn about the Key Concepts that form the foundation of the A2A protocol.</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#python","title":"Python","text":"Tutorial Description Difficulty A2A and Python Quickstart Learn to build a simple Python-based \"echo\" A2A server and client. Easy ADK facts Build and test a simple Personal Assistant agent using the Agent Development Kit (ADK) that can provide interesting facts. Easy ADK agent on Cloud Run Deploy, manage, and observe an ADK-based agent as a scalable, serverless service on Google Cloud Run. Easy Multi-agent collaboration using A2A Learn how to set up an orchestrator (host agent) that routes and manages requests among several specialized A2A-compatible agents. Easy Airbnb and weather multi-agent Build a complex multi-agent system where agents collaborate using A2A to plan a trip, finding both Airbnb accommodations and weather information. Medium A2A Client-Server example using remote ADK agent Learn how a local A2A client agent discovers and consumes the capabilities of a separate, remote ADK-based agent (for example, a prime number checker). Easy Colab Notebook Use Colab Notebook to deploy A2A agents to Cloud Run from your browser, and then evaluate their performance with Vertex AI. Easy"},{"location":"tutorials/#java","title":"Java","text":"Tutorial Description Difficulty Weather Agent Build a weather information agent using an MCP server.To make use of this agent in a multi-language, multi-agent system, check out the weather_and_airbnb_planner sample. Easy Content Writer Agent Build a content writer agent that generates engaging pieces of content from outlines.To make use of this agent in a content creation multi-language, multi-agent system, check out the content_creation sample. Easy Content Editor Agent Build a content editor agent that proof-reads and polishes content.To make use of this agent in a content creation multi-language, multi-agent system, check out the content_creation sample. Easy Dice Agent (Multi-Transport) Build a multi-transport agent that rolls dice and checks for prime numbers. Medium Magic 8 Ball Agent (Security) Build a Magic 8 Ball agent to learn how to secure A2A servers with Keycloak using bearer token authentication and configure an A2A client to obtain and pass the required token. Medium"},{"location":"tutorials/#javascript","title":"JavaScript","text":"Tutorial Description Movie research agent using JavaScript Build an A2A agent with Node.js that uses the TMDB (The Movie Database) API to handle movie searches and queries."},{"location":"tutorials/#cnet","title":"C#/.NET","text":"Tutorial Description All .NET samples Repository of foundational samples showing how to build A2A clients and servers, including an Echo Agent, using the C#/.NET SDK."},{"location":"tutorials/python/1-introduction/","title":"Python Quickstart Tutorial: Building an A2A Agent","text":"<p>Welcome to the Agent2Agent (A2A) Python Quickstart Tutorial!</p> <p>In this tutorial, you will explore a simple \"echo\" A2A server using the Python SDK. This will introduce you to the fundamental concepts and components of an A2A server. You will then look at a more advanced example that integrates a Large Language Model (LLM).</p> <p>This hands-on guide will help you understand:</p> <ul> <li>The basic concepts behind the A2A protocol.</li> <li>How to set up a Python environment for A2A development using the SDK.</li> <li>How Agent Skills and Agent Cards describe an agent.</li> <li>How an A2A server handles tasks.</li> <li>How to interact with an A2A server using a client.</li> <li>How streaming capabilities and multi-turn interactions work.</li> <li>How an LLM can be integrated into an A2A agent.</li> </ul> <p>By the end of this tutorial, you will have a functional understanding of A2A agents and a solid foundation for building or integrating A2A-compliant applications.</p>"},{"location":"tutorials/python/1-introduction/#tutorial-sections","title":"Tutorial Sections","text":"<p>The tutorial is broken down into the following steps:</p> <ol> <li>Introduction (This Page)</li> <li>Setup: Prepare your Python environment and the A2A SDK.</li> <li>Agent Skills &amp; Agent Card: Define what your agent can do and how it describes itself.</li> <li>The Agent Executor: Understand how the agent logic is implemented.</li> <li>Starting the Server: Run the Helloworld A2A server.</li> <li>Interacting with the Server: Send requests to your agent.</li> <li>Streaming &amp; Multi-Turn Interactions: Explore advanced capabilities with the LangGraph example.</li> <li>Next Steps: Explore further possibilities with A2A.</li> </ol> <p>Let's get started!</p>"},{"location":"tutorials/python/2-setup/","title":"2. Setup Your Environment","text":""},{"location":"tutorials/python/2-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher.</li> <li>Access to a terminal or command prompt.</li> <li>Git, for cloning the repository.</li> <li>A code editor (e.g., Visual Studio Code) is recommended.</li> </ul>"},{"location":"tutorials/python/2-setup/#clone-the-repository","title":"Clone the Repository","text":"<p>If you haven't already, clone the A2A Samples repository:</p> <pre><code>git clone https://github.com/a2aproject/a2a-samples.git -b main --depth 1\ncd a2a-samples\n</code></pre>"},{"location":"tutorials/python/2-setup/#python-environment-sdk-installation","title":"Python Environment &amp; SDK Installation","text":"<p>We recommend using a virtual environment for Python projects. The A2A Python SDK uses <code>uv</code> for dependency management, but you can use <code>pip</code> with <code>venv</code> as well.</p> <ol> <li> <p>Create and activate a virtual environment:</p> <p>Using <code>venv</code> (standard library):</p> Mac/LinuxWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate\n</code></pre> </li> <li> <p>Install needed Python dependencies along with the A2A SDK and its dependencies:</p> <pre><code>pip install -r samples/python/requirements.txt\n</code></pre> </li> </ol>"},{"location":"tutorials/python/2-setup/#verify-installation","title":"Verify Installation","text":"<p>After installation, you should be able to import the <code>a2a</code> package in a Python interpreter:</p> <pre><code>python -c \"import a2a; print('A2A SDK imported successfully')\"\n</code></pre> <p>If this command runs without error and prints the success message, your environment is set up correctly.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/","title":"3. Agent Skills &amp; Agent Card","text":"<p>Before an A2A agent can do anything, it needs to define what it can do (its skills) and how other agents or clients can find out about these capabilities (its Agent Card).</p> <p>We'll use the <code>helloworld</code> example located in <code>a2a-samples/samples/python/agents/helloworld/</code>.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/#agent-skills","title":"Agent Skills","text":"<p>An Agent Skill describes a specific capability or function the agent can perform. It's a building block that tells clients what kinds of tasks the agent is good for.</p> <p>Key attributes of an <code>AgentSkill</code> (defined in <code>a2a.types</code>):</p> <ul> <li><code>id</code>: A unique identifier for the skill.</li> <li><code>name</code>: A human-readable name.</li> <li><code>description</code>: A more detailed explanation of what the skill does.</li> <li><code>tags</code>: Keywords for categorization and discovery.</li> <li><code>examples</code>: Sample prompts or use cases.</li> <li><code>inputModes</code> / <code>outputModes</code>: Supported Media Types for input and output (e.g., \"text/plain\", \"application/json\").</li> </ul> <p>In <code>__main__.py</code>, you can see how a skill for the Helloworld agent is defined:</p> <pre><code>skill = AgentSkill(\n    id='hello_world',\n    name='Returns hello world',\n    description='just returns hello world',\n    tags=['hello world'],\n    examples=['hi', 'hello world'],\n)\n</code></pre> <p>This skill is very simple: it's named \"Returns hello world\" and primarily deals with text.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/#agent-card","title":"Agent Card","text":"<p>The Agent Card is a JSON document that an A2A Server makes available, typically at a <code>.well-known/agent-card.json</code> endpoint. It's like a digital business card for the agent.</p> <p>Key attributes of an <code>AgentCard</code> (defined in <code>a2a.types</code>):</p> <ul> <li><code>name</code>, <code>description</code>, <code>version</code>: Basic identity information.</li> <li><code>url</code>: The endpoint where the A2A service can be reached.</li> <li><code>capabilities</code>: Specifies supported A2A features like <code>streaming</code> or <code>pushNotifications</code>.</li> <li><code>defaultInputModes</code> / <code>defaultOutputModes</code>: Default Media Types for the agent.</li> <li><code>skills</code>: A list of <code>AgentSkill</code> objects that the agent offers.</li> </ul> <p>The <code>helloworld</code> example defines its Agent Card like this:</p> <pre><code># This will be the public-facing agent card\npublic_agent_card = AgentCard(\n    name='Hello World Agent',\n    description='Just a hello world agent',\n    url='http://localhost:9999/',\n    version='1.0.0',\n    default_input_modes=['text'],\n    default_output_modes=['text'],\n    capabilities=AgentCapabilities(streaming=True),\n    skills=[skill],  # Only the basic skill for the public card\n    supports_authenticated_extended_card=True,\n)\n</code></pre> <p>This card tells us the agent is named \"Hello World Agent\", runs at <code>http://localhost:9999/</code>, supports text interactions, and has the <code>hello_world</code> skill. It also indicates public authentication, meaning no specific credentials are required.</p> <p>Understanding the Agent Card is crucial because it's how a client discovers an agent and learns how to interact with it.</p>"},{"location":"tutorials/python/4-agent-executor/","title":"4. The Agent Executor","text":"<p>The core logic of how an A2A agent processes requests and generates responses/events is handled by an Agent Executor. The A2A Python SDK provides an abstract base class <code>a2a.server.agent_execution.AgentExecutor</code> that you implement.</p>"},{"location":"tutorials/python/4-agent-executor/#agentexecutor-interface","title":"<code>AgentExecutor</code> Interface","text":"<p>The <code>AgentExecutor</code> class defines two primary methods:</p> <ul> <li><code>async def execute(self, context: RequestContext, event_queue: EventQueue)</code>: Handles incoming requests that expect a response or a stream of events. It processes the user's input (available via <code>context</code>) and uses the <code>event_queue</code> to send back <code>Message</code>, <code>Task</code>, <code>TaskStatusUpdateEvent</code>, or <code>TaskArtifactUpdateEvent</code> objects.</li> <li><code>async def cancel(self, context: RequestContext, event_queue: EventQueue)</code>: Handles requests to cancel an ongoing task.</li> </ul> <p>The <code>RequestContext</code> provides information about the incoming request, such as the user's message and any existing task details. The <code>EventQueue</code> is used by the executor to send events back to the client.</p>"},{"location":"tutorials/python/4-agent-executor/#helloworld-agent-executor","title":"Helloworld Agent Executor","text":"<p>Let's look at <code>agent_executor.py</code>. It defines <code>HelloWorldAgentExecutor</code>.</p> <ol> <li> <p>The Agent (<code>HelloWorldAgent</code>):     This is a simple helper class that encapsulates the actual \"business logic\".</p> <pre><code>class HelloWorldAgent:\n    \"\"\"Hello World Agent.\"\"\"\n\n    async def invoke(self) -&gt; str:\n        return 'Hello World'\n</code></pre> <p>It has a simple <code>invoke</code> method that returns the string \"Hello World\".</p> </li> <li> <p>The Executor (<code>HelloWorldAgentExecutor</code>):     This class implements the <code>AgentExecutor</code> interface.</p> <ul> <li> <p><code>__init__</code>:</p> <pre><code>class HelloWorldAgentExecutor(AgentExecutor):\n    \"\"\"Test AgentProxy Implementation.\"\"\"\n\n    def __init__(self):\n        self.agent = HelloWorldAgent()\n</code></pre> <p>It instantiates the <code>HelloWorldAgent</code>.</p> </li> <li> <p><code>execute</code>:</p> <pre><code>async def execute(\n    self,\n    context: RequestContext,\n    event_queue: EventQueue,\n) -&gt; None:\n    result = await self.agent.invoke()\n    await event_queue.enqueue_event(new_agent_text_message(result))\n</code></pre> <p>When a <code>message/send</code> or <code>message/stream</code> request comes in (both are handled by <code>execute</code> in this simplified executor):</p> <ol> <li>It calls <code>self.agent.invoke()</code> to get the \"Hello World\" string.</li> <li>It creates an A2A <code>Message</code> object using the <code>new_agent_text_message</code> utility function.</li> <li>It enqueues this message onto the <code>event_queue</code>. The underlying <code>DefaultRequestHandler</code> will then process this queue to send the response(s) to the client. For a single message like this, it will result in a single response for <code>message/send</code> or a single event for <code>message/stream</code> before the stream closes.</li> </ol> </li> <li> <p><code>cancel</code>:     The Hello World example's <code>cancel</code> method simply raises an exception, indicating that cancellation is not supported for this basic agent.</p> <pre><code>async def cancel(\n    self, context: RequestContext, event_queue: EventQueue\n) -&gt; None:\n    raise Exception('cancel not supported')\n</code></pre> </li> </ul> </li> </ol> <p>The <code>AgentExecutor</code> acts as the bridge between the A2A protocol (managed by the request handler and server application) and your agent's specific logic. It receives context about the request and uses an event queue to communicate results or updates back.</p>"},{"location":"tutorials/python/5-start-server/","title":"5. Starting the Server","text":"<p>Now that we have an Agent Card and an Agent Executor, we can set up and start the A2A server.</p> <p>The A2A Python SDK provides an <code>A2AStarletteApplication</code> class that simplifies running an A2A-compliant HTTP server. It uses Starlette for the web framework and is typically run with an ASGI server like Uvicorn.</p>"},{"location":"tutorials/python/5-start-server/#server-setup-in-helloworld","title":"Server Setup in Helloworld","text":"<p>Let's look at <code>__main__.py</code> again to see how the server is initialized and started.</p> <pre><code>import uvicorn\n\nfrom a2a.server.apps import A2AStarletteApplication\nfrom a2a.server.request_handlers import DefaultRequestHandler\nfrom a2a.server.tasks import InMemoryTaskStore\nfrom a2a.types import (\n    AgentCapabilities,\n    AgentCard,\n    AgentSkill,\n)\nfrom agent_executor import (\n    HelloWorldAgentExecutor,  # type: ignore[import-untyped]\n)\n\n\nif __name__ == '__main__':\n    skill = AgentSkill(\n        id='hello_world',\n        name='Returns hello world',\n        description='just returns hello world',\n        tags=['hello world'],\n        examples=['hi', 'hello world'],\n    )\n\n    extended_skill = AgentSkill(\n        id='super_hello_world',\n        name='Returns a SUPER Hello World',\n        description='A more enthusiastic greeting, only for authenticated users.',\n        tags=['hello world', 'super', 'extended'],\n        examples=['super hi', 'give me a super hello'],\n    )\n\n    # This will be the public-facing agent card\n    public_agent_card = AgentCard(\n        name='Hello World Agent',\n        description='Just a hello world agent',\n        url='http://localhost:9999/',\n        version='1.0.0',\n        default_input_modes=['text'],\n        default_output_modes=['text'],\n        capabilities=AgentCapabilities(streaming=True),\n        skills=[skill],  # Only the basic skill for the public card\n        supports_authenticated_extended_card=True,\n    )\n\n    # This will be the authenticated extended agent card\n    # It includes the additional 'extended_skill'\n    specific_extended_agent_card = public_agent_card.model_copy(\n        update={\n            'name': 'Hello World Agent - Extended Edition',  # Different name for clarity\n            'description': 'The full-featured hello world agent for authenticated users.',\n            'version': '1.0.1',  # Could even be a different version\n            # Capabilities and other fields like url, default_input_modes, default_output_modes,\n            # supports_authenticated_extended_card are inherited from public_agent_card unless specified here.\n            'skills': [\n                skill,\n                extended_skill,\n            ],  # Both skills for the extended card\n        }\n    )\n\n    request_handler = DefaultRequestHandler(\n        agent_executor=HelloWorldAgentExecutor(),\n        task_store=InMemoryTaskStore(),\n    )\n\n    server = A2AStarletteApplication(\n        agent_card=public_agent_card,\n        http_handler=request_handler,\n        extended_agent_card=specific_extended_agent_card,\n    )\n\n    uvicorn.run(server.build(), host='0.0.0.0', port=9999)\n</code></pre> <p>Let's break this down:</p> <ol> <li> <p><code>DefaultRequestHandler</code>:</p> <ul> <li>The SDK provides <code>DefaultRequestHandler</code>. This handler takes your <code>AgentExecutor</code> implementation (here, <code>HelloWorldAgentExecutor</code>) and a <code>TaskStore</code> (here, <code>InMemoryTaskStore</code>).</li> <li>It routes incoming A2A RPC calls to the appropriate methods on your executor (like <code>execute</code> or <code>cancel</code>).</li> <li>The <code>TaskStore</code> is used by the <code>DefaultRequestHandler</code> to manage the lifecycle of tasks, especially for stateful interactions, streaming, and resubscription. Even if your agent executor is simple, the handler needs a task store.</li> </ul> </li> <li> <p><code>A2AStarletteApplication</code>:</p> <ul> <li>The <code>A2AStarletteApplication</code> class is instantiated with the <code>agent_card</code> and the <code>request_handler</code> (referred to as <code>http_handler</code> in its constructor).</li> <li>The <code>agent_card</code> is crucial because the server will expose it at the <code>/.well-known/agent-card.json</code> endpoint (by default).</li> <li>The <code>request_handler</code> is responsible for processing all incoming A2A method calls by interacting with your <code>AgentExecutor</code>.</li> </ul> </li> <li> <p><code>uvicorn.run(server_app_builder.build(), ...)</code>:</p> <ul> <li>The <code>A2AStarletteApplication</code> has a <code>build()</code> method that constructs the actual Starlette application.</li> <li>This application is then run using <code>uvicorn.run()</code>, making your agent accessible over HTTP.</li> <li><code>host='0.0.0.0'</code> makes the server accessible on all network interfaces on your machine.</li> <li><code>port=9999</code> specifies the port to listen on. This matches the <code>url</code> in the <code>AgentCard</code>.</li> </ul> </li> </ol>"},{"location":"tutorials/python/5-start-server/#running-the-helloworld-server","title":"Running the Helloworld Server","text":"<p>Navigate to the <code>a2a-samples</code> directory in your terminal (if you're not already there) and ensure your virtual environment is activated.</p> <p>To run the Helloworld server:</p> <pre><code># from the a2a-samples directory\npython samples/python/agents/helloworld/__main__.py\n</code></pre> <p>You should see output similar to this, indicating the server is running:</p> <pre><code>INFO:     Started server process [xxxxx]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:9999 (Press CTRL+C to quit)\n</code></pre> <p>Your A2A Helloworld agent is now live and listening for requests! In the next step, we'll interact with it.</p>"},{"location":"tutorials/python/6-interact-with-server/","title":"6. Interacting with the Server","text":"<p>With the Helloworld A2A server running, let's send some requests to it. The SDK includes a client (<code>A2AClient</code>) that simplifies these interactions.</p>"},{"location":"tutorials/python/6-interact-with-server/#the-helloworld-test-client","title":"The Helloworld Test Client","text":"<p>The <code>test_client.py</code> script demonstrates how to:</p> <ol> <li>Fetch the Agent Card from the server.</li> <li>Create an <code>A2AClient</code> instance.</li> <li>Send both non-streaming (<code>message/send</code>) and streaming (<code>message/stream</code>) requests.</li> </ol> <p>Open a new terminal window, activate your virtual environment, and navigate to the <code>a2a-samples</code> directory.</p> <p>Activate virtual environment (Be sure to do this in the same directory where you created the virtual environment):</p> Mac/LinuxWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>Run the test client:</p> <pre><code># from the a2a-samples directory\npython samples/python/agents/helloworld/test_client.py\n</code></pre>"},{"location":"tutorials/python/6-interact-with-server/#understanding-the-client-code","title":"Understanding the Client Code","text":"<p>Let's look at key parts of <code>test_client.py</code>:</p> <ol> <li> <p>Fetching the Agent Card &amp; Initializing the Client:</p> <pre><code>base_url = 'http://localhost:9999'\n\nasync with httpx.AsyncClient() as httpx_client:\n    # Initialize A2ACardResolver\n    resolver = A2ACardResolver(\n        httpx_client=httpx_client,\n        base_url=base_url,\n        # agent_card_path uses default, extended_agent_card_path also uses default\n    )\n</code></pre> <p>The <code>A2ACardResolver</code> class is a convenience. It first fetches the <code>AgentCard</code> from the server's <code>/.well-known/agent-card.json</code> endpoint (based on the provided base URL) and then initializes the client with it.</p> </li> <li> <p>Sending a Non-Streaming Message (<code>send_message</code>):</p> <pre><code>client = A2AClient(\n    httpx_client=httpx_client, agent_card=final_agent_card_to_use\n)\nlogger.info('A2AClient initialized.')\n\nsend_message_payload: dict[str, Any] = {\n    'message': {\n        'role': 'user',\n        'parts': [\n            {'kind': 'text', 'text': 'how much is 10 USD in INR?'}\n        ],\n        'messageId': uuid4().hex,\n    },\n}\nrequest = SendMessageRequest(\n    id=str(uuid4()), params=MessageSendParams(**send_message_payload)\n)\n\nresponse = await client.send_message(request)\nprint(response.model_dump(mode='json', exclude_none=True))\n</code></pre> <ul> <li>The <code>send_message_payload</code> constructs the data for <code>MessageSendParams</code>.</li> <li>This is wrapped in a <code>SendMessageRequest</code>.</li> <li>It includes a <code>message</code> object with the <code>role</code> set to \"user\" and the content in <code>parts</code>.</li> <li>The Helloworld agent's <code>execute</code> method will enqueue a single \"Hello World\" message. The <code>DefaultRequestHandler</code> will retrieve this and send it as the response.</li> <li>The <code>response</code> will be a <code>SendMessageResponse</code> object, which contains either a <code>SendMessageSuccessResponse</code> (with the agent's <code>Message</code> as the result) or a <code>JSONRPCErrorResponse</code>.</li> </ul> </li> <li> <p>Handling Task IDs (Illustrative Note for Helloworld):</p> <p>The Helloworld client (<code>test_client.py</code>) doesn't attempt <code>get_task</code> or <code>cancel_task</code> directly because the simple Helloworld agent's <code>execute</code> method, when called via <code>message/send</code>, results in the <code>DefaultRequestHandler</code> returning a direct <code>Message</code> response rather than a <code>Task</code> object. More complex agents that explicitly manage tasks (like the LangGraph example) would return a <code>Task</code> object from <code>message/send</code>, and its <code>id</code> could then be used for <code>get_task</code> or <code>cancel_task</code>.</p> </li> <li> <p>Sending a Streaming Message (<code>send_message_streaming</code>):</p> <pre><code>streaming_request = SendStreamingMessageRequest(\n    id=str(uuid4()), params=MessageSendParams(**send_message_payload)\n)\n\nstream_response = client.send_message_streaming(streaming_request)\n\nasync for chunk in stream_response:\n    print(chunk.model_dump(mode='json', exclude_none=True))\n</code></pre> <ul> <li>This method calls the agent's <code>message/stream</code> endpoint. The <code>DefaultRequestHandler</code> will invoke the <code>HelloWorldAgentExecutor.execute</code> method.</li> <li>The <code>execute</code> method enqueues one \"Hello World\" message, and then the event queue is closed.</li> <li>The client will receive this single message as one <code>SendStreamingMessageResponse</code> event, and then the stream will terminate.</li> <li>The <code>stream_response</code> is an <code>AsyncGenerator</code>.</li> </ul> </li> </ol>"},{"location":"tutorials/python/6-interact-with-server/#expected-output","title":"Expected Output","text":"<p>When you run <code>test_client.py</code>, you'll see JSON outputs for:</p> <ul> <li>The non-streaming response (a single \"Hello World\" message).</li> <li>The streaming response (a single \"Hello World\" message as one chunk, after which the stream ends).</li> </ul> <p>The <code>id</code> fields in the output will vary with each run.</p> <pre><code>// Non-streaming response\n{\"jsonrpc\":\"2.0\",\"id\":\"xxxxxxxx\",\"result\":{\"type\":\"message\",\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Hello World\"}],\"messageId\":\"yyyyyyyy\"}}\n// Streaming response (one chunk)\n{\"jsonrpc\":\"2.0\",\"id\":\"zzzzzzzz\",\"result\":{\"type\":\"message\",\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Hello World\"}],\"messageId\":\"wwwwwwww\"}}\n</code></pre> <p>(Actual IDs like <code>xxxxxxxx</code>, <code>yyyyyyyy</code>, <code>zzzzzzzz</code>, <code>wwwwwwww</code> will be different UUIDs/request IDs)</p> <p>This confirms your server is correctly handling basic A2A interactions with the updated SDK structure!</p> <p>Now you can shut down the server by typing Ctrl+C in the terminal window where <code>__main__.py</code> is running.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/","title":"7. Streaming &amp; Multi-Turn Interactions (LangGraph Example)","text":"<p>The Hello World example demonstrates the basic mechanics of A2A. For more advanced features like robust streaming, task state management, and multi-turn conversations powered by an LLM, we'll turn to the LangGraph example located in <code>a2a-samples/samples/python/agents/langgraph/</code>.</p> <p>This example features a \"Currency Agent\" that uses the Gemini model via LangChain and LangGraph to answer currency conversion questions.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#setting-up-the-langgraph-example","title":"Setting up the LangGraph Example","text":"<ol> <li> <p>Create a Gemini API Key, if you don't already have one.</p> </li> <li> <p>Environment Variable:</p> <p>Create a <code>.env</code> file in the <code>a2a-samples/samples/python/agents/langgraph/</code> directory:</p> <pre><code>echo \"GOOGLE_API_KEY=YOUR_API_KEY_HERE\" &gt; .env\n</code></pre> <p>Replace <code>YOUR_API_KEY_HERE</code> with your actual Gemini API key.</p> </li> <li> <p>Install Dependencies (if not already covered):</p> <p>The <code>langgraph</code> example has its own <code>pyproject.toml</code> which includes dependencies like <code>langchain-google-genai</code> and <code>langgraph</code>. When you installed the SDK from the <code>a2a-samples</code> root using <code>pip install -e .[dev]</code>, this should have also installed the dependencies for the workspace examples, including <code>langgraph-example</code>. If you encounter import errors, ensure your primary SDK installation from the root directory was successful.</p> </li> </ol>"},{"location":"tutorials/python/7-streaming-and-multiturn/#running-the-langgraph-server","title":"Running the LangGraph Server","text":"<p>Navigate to the <code>a2a-samples/samples/python/agents/langgraph/app</code> directory in your terminal and ensure your virtual environment (from the SDK root) is activated.</p> <p>Start the LangGraph agent server:</p> <pre><code>python __main__.py\n</code></pre> <p>This will start the server, usually on <code>http://localhost:10000</code>.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#interacting-with-the-langgraph-agent","title":"Interacting with the LangGraph Agent","text":"<p>Open a new terminal window, activate your virtual environment, and navigate to <code>a2a-samples/samples/python/agents/langgraph/app</code>.</p> <p>Run its test client:</p> <pre><code>python test_client.py\n</code></pre> <p>Now, you can shut down the server by typing Ctrl+C in the terminal window where <code>__main__.py</code> is running.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The <code>langgraph</code> example showcases several important A2A concepts:</p> <ol> <li> <p>LLM Integration:</p> <ul> <li><code>agent.py</code> defines <code>CurrencyAgent</code>. It uses <code>ChatGoogleGenerativeAI</code> and LangGraph's <code>create_react_agent</code> to process user queries.</li> <li>This demonstrates how a real LLM can power the agent's logic.</li> </ul> </li> <li> <p>Task State Management:</p> <ul> <li> <p><code>samples/langgraph/__main__.py</code> initializes a <code>DefaultRequestHandler</code> with an <code>InMemoryTaskStore</code>.</p> <pre><code>httpx_client = httpx.AsyncClient()\npush_config_store = InMemoryPushNotificationConfigStore()\npush_sender = BasePushNotificationSender(httpx_client=httpx_client,\n                config_store=push_config_store)\nrequest_handler = DefaultRequestHandler(\n    agent_executor=CurrencyAgentExecutor(),\n    task_store=InMemoryTaskStore(),\n    push_config_store=push_config_store,\n    push_sender= push_sender\n)\nserver = A2AStarletteApplication(\n    agent_card=agent_card, http_handler=request_handler\n)\n\nuvicorn.run(server.build(), host=host, port=port)\n</code></pre> </li> <li> <p>The <code>CurrencyAgentExecutor</code> (in <code>samples/langgraph/agent_executor.py</code>), when its <code>execute</code> method is called by the <code>DefaultRequestHandler</code>, interacts with the <code>RequestContext</code> which contains the current task (if any).</p> </li> <li>For <code>message/send</code>, the <code>DefaultRequestHandler</code> uses the <code>TaskStore</code> to persist and retrieve task state across interactions. The response to <code>message/send</code> will be a full <code>Task</code> object if the agent's execution flow involves multiple steps or results in a persistent task.</li> <li>The <code>test_client.py</code>'s <code>run_single_turn_test</code> demonstrates getting a <code>Task</code> object back and then querying it using <code>get_task</code>.</li> </ul> </li> <li> <p>Streaming with <code>TaskStatusUpdateEvent</code> and <code>TaskArtifactUpdateEvent</code>:</p> <ul> <li>The <code>execute</code> method in <code>CurrencyAgentExecutor</code> is responsible for handling both non-streaming and streaming requests, orchestrated by the <code>DefaultRequestHandler</code>.</li> <li>As the LangGraph agent processes the request (which might involve calling tools like <code>get_exchange_rate</code>), the <code>CurrencyAgentExecutor</code> enqueues different types of events onto the <code>EventQueue</code>:<ul> <li><code>TaskStatusUpdateEvent</code>: For intermediate updates (e.g., \"Looking up exchange rates...\", \"Processing the exchange rates..\").</li> <li><code>TaskArtifactUpdateEvent</code>: When the final answer is ready, it's enqueued as an artifact. The <code>lastChunk</code> flag is <code>True</code>.</li> <li>A final <code>TaskStatusUpdateEvent</code> with <code>state=TaskState.completed</code> is sent to signify the end of the task, closing the stream.</li> </ul> </li> <li>The <code>test_client.py</code>'s <code>run_streaming_test</code> function will print these individual event chunks as they are received from the server.</li> </ul> </li> <li> <p>Multi-Turn Conversation (<code>TaskState.input_required</code>):</p> <ul> <li>The <code>CurrencyAgent</code> can ask for clarification if a query is ambiguous (e.g., user asks \"how much is 100 USD?\").</li> <li>When this happens, the <code>CurrencyAgentExecutor</code> will enqueue a <code>TaskStatusUpdateEvent</code> where <code>status.state</code> is <code>TaskState.input_required</code> and <code>status.message</code> contains the agent's question (e.g., \"To which currency would you like to convert?\"). The stream closes after this event.</li> <li>The <code>test_client.py</code>'s <code>run_multi_turn_test</code> function demonstrates this:<ul> <li>It sends an initial ambiguous query.</li> <li>The agent responds (via the <code>DefaultRequestHandler</code> processing the enqueued events) with a <code>Task</code> whose status is <code>input_required</code>.</li> <li>The client then sends a second message, including the <code>taskId</code> and <code>contextId</code> from the first turn's <code>Task</code> response, to provide the missing information (\"in GBP\"). This continues the same task.</li> </ul> </li> </ul> </li> </ol>"},{"location":"tutorials/python/7-streaming-and-multiturn/#exploring-the-code","title":"Exploring the Code","text":"<p>Take some time to look through these files:</p> <ul> <li><code>__main__.py</code>: Server setup using <code>A2AStarletteApplication</code> and <code>DefaultRequestHandler</code>. Note the <code>AgentCard</code> definition includes <code>capabilities.streaming=True</code>.</li> <li><code>agent.py</code>: The <code>CurrencyAgent</code> with LangGraph, LLM model, and tool definitions.</li> <li><code>agent_executor.py</code>: The <code>CurrencyAgentExecutor</code> implementing the <code>execute</code> (and <code>cancel</code>) method. It uses the <code>RequestContext</code> to understand the ongoing task and the <code>EventQueue</code> to send back various events (<code>TaskStatusUpdateEvent</code>, <code>TaskArtifactUpdateEvent</code>, new <code>Task</code> object implicitly via the first event if no task exists).</li> <li><code>test_client.py</code>: Demonstrates various interaction patterns, including retrieving task IDs and using them for multi-turn conversations.</li> </ul> <p>This example provides a much richer illustration of how A2A facilitates complex, stateful, and asynchronous interactions between agents.</p>"},{"location":"tutorials/python/8-next-steps/","title":"Next Steps","text":"<p>Congratulations on completing the A2A Python SDK Tutorial! You've learned how to:</p> <ul> <li>Set up your environment for A2A development.</li> <li>Define Agent Skills and Agent Cards using the SDK's types.</li> <li>Implement a basic HelloWorld A2A server and client.</li> <li>Understand and implement streaming capabilities.</li> <li>Integrate a more complex agent using LangGraph, demonstrating task state management and tool use.</li> </ul> <p>You now have a solid foundation for building and integrating your own A2A-compliant agents.</p>"},{"location":"tutorials/python/8-next-steps/#where-to-go-from-here","title":"Where to Go From Here?","text":"<p>Here are some ideas and resources to continue your A2A journey:</p> <ul> <li>Explore Other Examples:<ul> <li>Check out the other examples in the a2a-samples GitHub repository for more complex agent integrations and features.</li> </ul> </li> <li>Deepen Your Protocol Understanding:<ul> <li>\ud83d\udcda Read the complete A2A Protocol Documentation site for a comprehensive overview.</li> <li>\ud83d\udcdd Review the detailed A2A Protocol Specification to understand the nuances of all data structures and RPC methods.</li> </ul> </li> <li>Review Key A2A Topics:<ul> <li>A2A and MCP: Understand how A2A complements the Model Context Protocol for tool usage.</li> <li>Enterprise-Ready Features: Learn about security, observability, and other enterprise considerations.</li> <li>Streaming &amp; Asynchronous Operations: Get more details on SSE and push notifications.</li> <li>Agent Discovery: Explore different ways agents can find each other.</li> </ul> </li> <li>Build Your Own Agent:<ul> <li>Try creating a new A2A agent using your favorite Python agent framework (like LangChain, CrewAI, AutoGen, Semantic Kernel, or a custom solution).</li> <li>Implement the <code>a2a.server.AgentExecutor</code> interface to bridge your agent's logic with the A2A protocol.</li> <li>Think about what unique skills your agent could offer and how its Agent Card would represent them.</li> </ul> </li> <li>Experiment with Advanced Features:<ul> <li>Implement robust task management with a persistent <code>TaskStore</code> if your agent handles long-running or multi-session tasks.</li> <li>Explore implementing push notifications if your agent's tasks are very long-lived.</li> <li>Consider more complex input and output modalities (e.g., handling file uploads/downloads, or structured data via <code>DataPart</code>).</li> </ul> </li> <li>Contribute to the A2A Community:<ul> <li>Join the discussions on the A2A GitHub Discussions page.</li> <li>Report issues or suggest improvements via GitHub Issues.</li> <li>Consider contributing code, examples, or documentation. See the CONTRIBUTING.md guide.</li> </ul> </li> </ul> <p>The A2A protocol aims to foster an ecosystem of interoperable AI agents. By building and sharing A2A-compliant agents, you can be a part of this exciting development!</p>"}]}