{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Agent2Agent (A2A) Protocol"},{"location":"#what-is-a2a-protocol","title":"What is A2A Protocol?","text":"<p>The Agent2Agent (A2A) Protocol is an open standard developed by Google and donated to the Linux Foundation designed to enable seamless communication and collaboration between AI agents.</p> <p>In a world where agents are built using diverse frameworks and by different vendors, A2A provides a common language, breaking down silos and fostering interoperability.</p> <p>Build with  ADK (or any framework), equip with  MCP (or any tool), and communicate with  A2A, to remote agents, local agents, and humans.</p>"},{"location":"#get-started-with-agent2agent-a2a-protocol","title":"Get started with Agent2Agent (A2A) Protocol","text":"<ul> <li> <p> Video Intro in &lt;8 min</p> <p></p> </li> <li> <p> Read the Introduction</p> <p>Understand the core ideas behind A2A.</p> <p> What is A2A?</p> <p> Key Concepts</p> </li> <li> <p> Dive into the Specification</p> <p>Explore the detailed technical definition of the A2A protocol.</p> <p> Protocol Specification</p> </li> <li> <p> Follow the Tutorials</p> <p>Build your first A2A-compliant agent with our step-by-step Python quickstart.</p> <p> Python Tutorial</p> </li> <li> <p> Explore Code Samples</p> <p>See A2A in action with sample clients, servers, and agent framework integrations.</p> <p> GitHub Samples</p> </li> <li> <p> Download the SDK</p> <p> Python</p> <p> JavaScript</p> <p> Java</p> <p> C#/.NET</p> <p> Golang</p> </li> </ul>"},{"location":"#why-use-the-a2a-protocol","title":"Why use the A2A Protocol","text":"<pre><code>graph LR\n    User(\ud83e\uddd1\u200d\ud83d\udcbb User) &lt;--&gt; ClientAgent(\ud83e\udd16 Client Agent)\n    ClientAgent --&gt; A2A1(**\u2194\ufe0f A2A**) --&gt; RemoteAgent1(\ud83e\udd16 Remote Agent 1)\n    ClientAgent --&gt; A2A2(**\u2194\ufe0f A2A**) --&gt; RemoteAgent2(\ud83e\udd16 Remote Agent 2)\n\n    style User fill:#fdebd0,stroke:#e67e22,stroke-width:2px\n    style ClientAgent fill:#d6eaf8,stroke:#3498db,stroke-width:2px\n    style RemoteAgent1 fill:#d6eaf8,stroke:#3498db,stroke-width:2px\n    style RemoteAgent2 fill:#d6eaf8,stroke:#3498db,stroke-width:2px\n    style A2A1 fill:#ebedef,stroke:#909497,stroke-width:2px\n    style A2A2 fill:#ebedef,stroke:#909497,stroke-width:2px</code></pre> <ul> <li> <p> Interoperability</p> <p>Connect agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions) to create powerful, composite AI systems.</p> </li> <li> <p> Complex Workflows</p> <p>Enable agents to delegate sub-tasks, exchange information, and coordinate actions to solve complex problems that a single agent cannot.</p> </li> <li> <p> Secure &amp; Opaque</p> <p>Agents interact without needing to share internal memory, tools, or proprietary logic, ensuring security and preserving intellectual property.</p> </li> </ul>"},{"location":"#how-does-a2a-work-with-mcp","title":"How does A2A work with MCP?","text":"<p>A2A and Model Context Protocol (MCP) are complementary standards for building robust agentic applications:</p> <ul> <li>Model Context Protocol (MCP): Provides agent-to-tool communication. It's a complementary standard that standardizes how an agent connects to its tools, APIs, and resources to get information.</li> <li>IBM ACP: Incorporated into the A2A Protocol</li> <li>Cisco agntcy: A framework for building the internal logic of a single, complex agent system, often with a supervisor/expert structure.</li> <li>A2A: Provides agent-to-agent communication. As a universal, decentralized standard, A2A acts as the public internet that allows ai agents\u2014including those using MCP, or built with frameworks like agntcy\u2014to interoperate, collaborate, and share their findings.</li> </ul>"},{"location":"community/","title":"Welcome to the A2A Community","text":"<p>The Agent2Agent (A2A) protocol is generating significant buzz across the tech world, and for good reason! This open interoperability protocol is designed to enable seamless collaboration between AI agents across diverse frameworks and vendors. By standardizing communication, A2A aims to unlock complex workflows, enhance productivity, and foster a new era of \"Agent Interoperability\". Don't just take our word for it \u2013 see what the community is saying!</p>"},{"location":"community/#integrations","title":"Integrations","text":"<p>These agentic frameworks have built-in A2A integration:</p> <ul> <li>Agent Development Kit (ADK)</li> <li>BeeAI Framework</li> <li>LangGraph</li> <li>Pydantic AI</li> </ul>"},{"location":"community/#the-word-on-the-street-social-highlights","title":"The Word on the Street: Social Highlights","text":"<p>The launch of A2A has sparked lively discussions and positive reactions on various social platforms. Here's a glimpse of the excitement:</p> <ul> <li> <p>Rapid Interest and Adoption: The A2A GitHub repository has seen an explosive surge in popularity. This rapid interest underscores the industry's eagerness for a standardized agent communication protocol, with many companies collaborating and contributing.</p> </li> <li> <p>Microsoft's interest via Semantic Kernel: Asha Sharma, Head of AI Platform Product at Microsoft, announced on LinkedIn that \"Semantic Kernel now speaks A2A: a lightweight JSON-RPC protocol that lets agents swap context, not code or credentials, over plain HTTP. Drop it into your Foundry stack for instant, secure, async interoperability with any A2A-compliant agent, regardless of modality\". The post received numerous positive reactions, including \"A2A support in Semantic Kernel is a key unlock \u2014 context-level interoperability without sharing code or creds is how agent ecosystems scale securely across clouds\".</p> </li> <li> <p>Matt Pocock's Diagramming Intent: Matt Pocock, a well-known developer educator, shared on X \"I've just been reading the Agent2Agent technical docs - Google's new protocol for agent to agent communication. You know what that means. Let's diagram them:\". This tweet, liked and reposted hundreds of times, includes some great diagrams explaining the A2A protocol.</p> </li> <li> <p>Craig McLuckie's \"Hot Take\": Craig McLuckie shared his initial thoughts on LinkedIn \"Hot take on Agent2Agent vs MCP\". His post highlighted Google's careful positioning of A2A as focused on interactions between agentic systems, rather than agents interacting with resources (the focus of MCP). This distinction is crucial for improving models' ability to understand expectations from other agents. McLuckie also pointed out the potential for A2A to enable systems to advertise specific capabilities and specialities, which is seen as \"sensible\".</p> </li> </ul>"},{"location":"community/#community-deep-dive-videos","title":"Community deep dive videos","text":"<ul> <li>Zachary Huang explains in his YouTube video, A2A \"complements\" MCP. While MCP acts as a \"USB-C port for AI applications\" connecting agents to tools, A2A acts as a communication standard between the intelligent agents themselves. This layered approach allows for building powerful systems where agents use A2A to coordinate and MCP to access necessary tools.</li> <li>Jack Herrington on his YouTube video walks through some of the provided examples and closes with his opinion that \"Having a specific protocol for agents to talk to other agents is valuable\" and reiterates, \"LLM plus tools are agents. MCP gives agents those tools. So that's why A2A and MCP play really nicely together\".</li> <li>Cole Medin suggested on his YouTube video that \"A2A was released very recently but it's already looking like it's going to follow a similar path\" to MCP in terms of growing interest. He also demonstrates the samples step by step and provides a summary of core concepts.</li> <li>Sam Witteveen covered A2A on his YouTube video immediately after Google Cloud Next, discussing the value of making protocols open and not ending up with conflicting protocols.</li> </ul>"},{"location":"community/#community-contributions-to-a2a","title":"Community Contributions to A2A","text":"<ul> <li>Python Quickstart Tutorial PR#202</li> <li>LlamaIndex submitted a sample implementation PR#179</li> <li>Autogen sample server PR#232</li> <li>AG2 + MCP example PR#230</li> <li>PydanticAI example PR#127</li> <li>Go example PR#52</li> <li>Daytona sandbox running agent PR#170</li> </ul>"},{"location":"community/#what-is-driving-this-excitement","title":"What is Driving This Excitement?","text":"<p>The enthusiasm surrounding A2A stems from its potential to address key challenges in building sophisticated AI applications:</p> <ul> <li> <p>Breaking Down Silos: A2A aims to overcome the limitations of siloed AI systems by providing a universal framework for agents built on different platforms to communicate and collaborate securely.</p> </li> <li> <p>Enabling Complex Collaboration: For tasks that require the expertise of multiple specialized agents, A2A provides a standardized way for them to delegate tasks, exchange information, and coordinate actions. This mirrors how human teams work together, distributing responsibilities for greater efficiency.</p> </li> <li> <p>Dynamic Agent Discovery: A key feature of A2A is the ability for agents to discover the capabilities of other agents through standardized \"Agent Cards\". This dynamic discovery allows for more flexible and adaptable multi-agent systems.</p> </li> <li> <p>Complementary to MCP: As stated on our A2A \u2764\ufe0f MCP topic page and affirmed by many community, A2A \"complements\" MCP. MCP acts as a communication standard between models and resources, providing tools for agents. A2A acts as a communication standard between the intelligent agents themselves. This layered approach allows for building powerful systems where agents use A2A to coordinate and MCP to access necessary tools.</p> </li> <li> <p>Open and Community-Driven: Google has released A2A as open source, inviting contributions from the broader community to refine and expand its functionality. This commitment to open collaboration fosters innovation and broad adoption.</p> </li> </ul>"},{"location":"community/#the-future-is-interoperable","title":"The Future is Interoperable","text":"<p>The social media buzz surrounding Google's A2A protocol clearly indicates a strong interest and belief in its potential to revolutionize the development of multi-agent AI systems. By providing a standardized way for AI agents to communicate and collaborate, A2A is poised to unlock new levels of automation, efficiency, and innovation. As enterprises increasingly adopt AI agents for a wide range of tasks, A2A represents a crucial step towards realizing the full power of interconnected AI ecosystems.</p> <p>Stay tuned for more updates and join the growing community building the future of AI interoperability with A2A!</p>"},{"location":"partners/","title":"Partners","text":"<p>Below is a list of partners (and a link to their A2A announcement or blog post, if available) who are part of the A2A community and are helping build, codify, and adopt A2A as the standard protocol for AI agents to communicate and collaborate effectively with each other and with users.</p> <p>Note</p> <p>If you're interested in becoming a partner of A2A and getting your listing added to or updated on this page, let us know by submitting this form, and we'll contact you soon!</p> <ul> <li>Accelirate Inc</li> <li>Accenture</li> <li>Activeloop</li> <li>Adobe</li> <li>AI21 Labs</li> <li>AI71</li> <li>Aisera</li> <li>Almawave.it</li> <li>AliCloud</li> <li>ArcBlock</li> <li>Arize</li> <li>Articul8</li> <li>ask-ai.com</li> <li>Atlassian</li> <li>Auth0</li> <li>Autodesk</li> <li>AWS</li> <li>Beekeeper</li> <li>BCG</li> <li>Block Inc</li> <li>Bloomberg LP</li> <li>BLUEISH Inc</li> <li>BMC Software Inc</li> <li>Boomi</li> <li>Box</li> <li>Bridge2Things Automation Process GmbH</li> <li>Cafe 24</li> <li>C3 AI</li> <li>Capgemini</li> <li>Chronosphere</li> <li>Cisco</li> <li>Codimite PTE LTD</li> <li>Cognigy</li> <li>Cognizant</li> <li>Cohere</li> <li>Collibra</li> <li>Confluent</li> <li>Contextual</li> <li>Cotality (fka Corelogic)</li> <li>Crubyt</li> <li>Cyderes</li> <li>Datadog</li> <li>DataRobot</li> <li>DataStax</li> <li>Decagon.ai</li> <li>Deloitte</li> <li>Devnagri</li> <li>Deutsche Telekom</li> <li>Dexter Tech Labs</li> <li>Distyl.ai</li> <li>Elastic</li> <li>Ema.co</li> <li>EPAM</li> <li>Eviden (Atos Group)</li> <li>fractal.ai</li> <li>GenAI Nebula9.ai Solutions Pvt Ltd</li> <li>Glean</li> <li>Global Logic</li> <li>Gravitee</li> <li>GrowthLoop</li> <li>Guru</li> <li>Harness</li> <li>HCLTech</li> <li>Headwaters</li> <li>Hellotars</li> <li>Hexaware</li> <li>HUMAN</li> <li>Incorta</li> <li>Infinitus</li> <li>InfoSys</li> <li>Intuit</li> <li>Iron Mountain</li> <li>JetBrains</li> <li>JFrog</li> <li>Kakao</li> <li>King's College London</li> <li>KPMG</li> <li>Kyndryl</li> <li>LabelBox</li> <li>LangChain</li> <li>LG CNS</li> <li>Livex.ai</li> <li>LlamaIndex</li> <li>LTIMindTtree</li> <li>Lumeris</li> <li>Lyzr.ai</li> <li>Magyar Telekom</li> <li>Microsoft</li> <li>MindsDB</li> <li>McKinsey</li> <li>MongoDB</li> <li>Monite</li> <li>Neo4j</li> <li>New Relic</li> <li>Nisum</li> <li>Noorle Inc</li> <li>Optimizely Inc</li> <li>Oracle / NetSuite</li> <li>Palo Alto Networks</li> <li>PancakeAI</li> <li>Pendo</li> <li>PerfAI.ai</li> <li>Personal AI</li> <li>Poppulo</li> <li>Productive Edge</li> <li>Proofs</li> <li>Publicis Sapient</li> <li>PWC</li> <li>Quantiphi</li> <li>Radix</li> <li>RagaAI Inc</li> <li>Red Hat</li> <li>Reltio Inc</li> <li>S&amp;P</li> <li>Sage</li> <li>Salesforce</li> <li>SAP</li> <li>Sayone Technologies</li> <li>ServiceNow</li> <li>Siemens AG</li> <li>SoftBank Corp</li> <li>Solace</li> <li>Solo.io</li> <li>Stacklok, Inc</li> <li>Supertab</li> <li>Suzega</li> <li>TCS</li> <li>Tech Mahindra</li> <li>Telefonica</li> <li>Test Innovation Technology</li> <li>the artinet project</li> <li>Think41</li> <li>Thoughtworks</li> <li>Tredence</li> <li>Two Tall Totems Ltd. DBA TTT Studios</li> <li>Typeface</li> <li>UKG</li> <li>UiPath</li> <li>Upwork, Inc.</li> <li>Ushur, Inc.</li> <li>Valle AI</li> <li>Valtech</li> <li>Vervelo</li> <li>VoltAgent</li> <li>Weights &amp; Biases</li> <li>Wipro</li> <li>Workday</li> <li>Writer</li> <li>Zenity</li> <li>Zeotap</li> <li>Zocket Technologies , Inc.</li> <li>Zoom</li> <li>zyprova</li> </ul>"},{"location":"roadmap/","title":"A2A protocol roadmap","text":"<p>Last updated: Jul 16, 2025</p>"},{"location":"roadmap/#near-term-initiatives","title":"Near-term initiatives","text":"<ul> <li>Release <code>0.3</code> version of the protocol which we intend to keep supported and without breaking changes for a significant amount of time with backward compatibility of the SDKs starting at version <code>0.3</code>. As part of this release there are a few known breaking changes including:<ul> <li>Update the <code>/.well-known/agent.json</code> path for hosting Agent Cards to <code>/.well-known/agent-card.json</code> based on feedback from IANA.</li> <li>Refactor class fields to be more Pythonic and adopt <code>snake_case</code>. PR 199</li> </ul> </li> <li>Solidify the support for A2A extensions with SDK support (starting with the Python SDK) and publishing sample extensions.</li> <li>Introduce support for signed Agent Cards Discussion 199 to allow verifying the integrity of Agent Card content.</li> <li>Enhance the client side support in SDK (starting with Python) to expose ready-to-use A2A clients, streamlined auth handling and improved handling of tasks.</li> </ul> <p>To review recent protocol changes see Release Notes.</p>"},{"location":"roadmap/#longer-term-3-6-month-period-roadmap","title":"Longer term (3-6 month period) roadmap","text":""},{"location":"roadmap/#governance","title":"Governance","text":"<p>The protocol has been donated to the Linux Foundation. The TSC is working on implementing a governance structure that prioritizes community-led development with standardized processes for contributing to the specification, SDKs and tooling. As part of the effort there will be dedicated working groups created for specific areas of the protocol.</p>"},{"location":"roadmap/#agent-registry","title":"Agent Registry","text":"<p>Agent Registry enables the discovery of agents and is a critical component of a multi-agent system. There is an active and ongoing discussion in the community around the latest Discussion 741.</p>"},{"location":"roadmap/#validation","title":"Validation","text":"<p>As the A2A ecosystem matures, it becomes critical for the A2A community to have tools to validate their agents. The community has launched two efforts to help with validation which the group will continue to enhance in the coming months. Learn more about A2A Inspector and the A2A Protocol Technology Compatibility Kit (TCK).</p>"},{"location":"roadmap/#sdks","title":"SDKs","text":"<p>A2A Project currently hosts SDKs in four languages (Python, JS, Java, .NET) and contributors are adding more including Go (in progress).</p>"},{"location":"roadmap/#community-best-practices","title":"Community best practices","text":"<p>As companies and individuals deploy A2A systems at an increasing pace, we are looking to accelerate the learning of the community by collecting and sharing the best practices and success stories that A2A enabled.</p>"},{"location":"specification/","title":"Agent2Agent (A2A) Protocol Official Specification","text":"<p>Version: <code>0.3.0</code></p> <p>See Release Notes for changes made between versions.</p>"},{"location":"specification/#1-introduction","title":"1. Introduction","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to facilitate communication and interoperability between independent, potentially opaque AI agent systems. In an ecosystem where agents might be built using different frameworks, languages, or by different vendors, A2A provides a common language and interaction model.</p> <p>This document provides the detailed technical specification for the A2A protocol. Its primary goal is to enable agents to:</p> <ul> <li>Discover each other's capabilities.</li> <li>Negotiate interaction modalities (text, files, structured data).</li> <li>Manage collaborative tasks.</li> <li>Securely exchange information to achieve user goals without needing access to each other's internal state, memory, or tools.</li> </ul>"},{"location":"specification/#11-key-goals-of-a2a","title":"1.1. Key Goals of A2A","text":"<ul> <li>Interoperability: Bridge the communication gap between disparate agentic systems.</li> <li>Collaboration: Enable agents to delegate tasks, exchange context, and work together on complex user requests.</li> <li>Discovery: Allow agents to dynamically find and understand the capabilities of other agents.</li> <li>Flexibility: Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.</li> <li>Security: Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.</li> <li>Asynchronicity: Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.</li> </ul>"},{"location":"specification/#12-guiding-principles","title":"1.2. Guiding Principles","text":"<ul> <li>Simple: Reuse existing, well-understood standards (HTTP, JSON-RPC 2.0, Server-Sent Events).</li> <li>Enterprise Ready: Address authentication, authorization, security, privacy, tracing, and monitoring by aligning with established enterprise practices.</li> <li>Async First: Designed for (potentially very) long-running tasks and human-in-the-loop interactions.</li> <li>Modality Agnostic: Support exchange of diverse content types including text, audio/video (via file references), structured data/forms, and potentially embedded UI components (e.g., iframes referenced in parts).</li> <li>Opaque Execution: Agents collaborate based on declared capabilities and exchanged information, without needing to share their internal thoughts, plans, or tool implementations.</li> </ul> <p>For a broader understanding of A2A's purpose and benefits, see What is A2A?.</p>"},{"location":"specification/#2-core-concepts-summary","title":"2. Core Concepts Summary","text":"<p>A2A revolves around several key concepts. For detailed explanations, please refer to the Key Concepts guide.</p> <ul> <li>A2A Client: An application or agent that initiates requests to an A2A Server on behalf of a user or another system.</li> <li>A2A Server (Remote Agent): An agent or agentic system that exposes an A2A-compliant HTTP endpoint, processing tasks and providing responses.</li> <li>Agent Card: A JSON metadata document published by an A2A Server, describing its identity, capabilities, skills, service endpoint, and authentication requirements.</li> <li>Message: A communication turn between a client and a remote agent, having a <code>role</code> (\"user\" or \"agent\") and containing one or more <code>Parts</code>.</li> <li>Task: The fundamental unit of work managed by A2A, identified by a unique ID. Tasks are stateful and progress through a defined lifecycle.</li> <li>Part: The smallest unit of content within a Message or Artifact (e.g., <code>TextPart</code>, <code>FilePart</code>, <code>DataPart</code>).</li> <li>Artifact: An output (e.g., a document, image, structured data) generated by the agent as a result of a task, composed of <code>Parts</code>.</li> <li>Streaming (SSE): Real-time, incremental updates for tasks (status changes, artifact chunks) delivered via Server-Sent Events.</li> <li>Push Notifications: Asynchronous task updates delivered via server-initiated HTTP POST requests to a client-provided webhook URL, for long-running or disconnected scenarios.</li> <li>Context: An optional, server-generated identifier to logically group related tasks.</li> <li>Extension: A mechanism for agents to provide additional functionality or data beyond the core A2A specification.</li> </ul>"},{"location":"specification/#3-transport-and-format","title":"3. Transport and Format","text":""},{"location":"specification/#31-transport-layer-requirements","title":"3.1. Transport Layer Requirements","text":"<p>A2A supports multiple transport protocols, all operating over HTTP(S). Agents have flexibility in choosing which transport protocols to implement based on their specific requirements and use cases:</p> <ul> <li>A2A communication MUST occur over HTTP(S).</li> <li>The A2A Server exposes its service at one or more URLs defined in its <code>AgentCard</code>.</li> <li>Agents MUST implement at least one of the three core transport protocols defined in this specification.</li> <li>All supported transport protocols are considered equal in status and capability.</li> </ul>"},{"location":"specification/#32-supported-transport-protocols","title":"3.2. Supported Transport Protocols","text":"<p>A2A defines three core transport protocols. A2A-compliant agents SHOULD implement at least one of these transport protocols. They MAY be compliant implementing a transport extension as defined in 3.2.4 All three protocols are considered equal in status, and agents may choose to implement any combination of them based on their requirements.</p>"},{"location":"specification/#321-json-rpc-20-transport","title":"3.2.1. JSON-RPC 2.0 Transport","text":"<p>Agents MAY support JSON-RPC 2.0 transport. If implemented, it MUST conform to these requirements:</p> <ul> <li>The primary data format is JSON-RPC 2.0 for all requests and responses (excluding SSE stream wrapper).</li> <li>Client requests and server responses MUST adhere to the JSON-RPC 2.0 specification.</li> <li>The <code>Content-Type</code> header for HTTP requests and responses containing JSON-RPC payloads MUST be <code>application/json</code>.</li> <li>Method names follow the pattern <code>{category}/{action}</code> (e.g., <code>\"message/send\"</code>, <code>\"tasks/get\"</code>).</li> </ul>"},{"location":"specification/#322-grpc-transport","title":"3.2.2. gRPC Transport","text":"<p>Agents MAY support gRPC transport. If implemented, it MUST conform to these requirements:</p> <ul> <li>Protocol Definition: MUST use the normative Protocol Buffers definition in <code>specification/grpc/a2a.proto</code>.</li> <li>Message Serialization: MUST use Protocol Buffers version 3 for message serialization.</li> <li>Service Definition: MUST implement the <code>A2AService</code> gRPC service as defined in the proto file.</li> <li>Method Coverage: MUST provide all methods with functionally equivalent behavior to other supported transports.</li> <li>Field Mapping: MUST use the <code>json_name</code> annotations for HTTP/JSON transcoding compatibility.</li> <li>Error Handling: MUST map A2A error codes to appropriate gRPC status codes as defined in the proto annotations.</li> <li>Transport Security: MUST support TLS encryption (gRPC over HTTP/2 with TLS).</li> </ul>"},{"location":"specification/#323-httpjsonrest-transport","title":"3.2.3. HTTP+JSON/REST Transport","text":"<p>Agents MAY support REST-style HTTP+JSON transport. If implemented, it MUST conform to these requirements:</p> <ul> <li>HTTP Methods: MUST use appropriate HTTP verbs (GET for queries, POST for actions, PUT for updates, DELETE for removal).</li> <li>URL Patterns: MUST follow the URL patterns documented in each method section (e.g., <code>/v1/message:send</code>, <code>/v1/tasks/{id}</code>).</li> <li>Content-Type: MUST use <code>application/json</code> for request and response bodies.</li> <li>HTTP Status Codes: MUST use appropriate HTTP status codes (200, 400, 401, 403, 404, 500, etc.) that correspond to A2A error types.</li> <li>Request/Response Format: MUST use JSON objects that are structurally equivalent to the core A2A data structures.</li> <li>Method Coverage: MUST provide all methods with functionally equivalent behavior to other supported transports.</li> <li>Error Format: MUST return error responses in a consistent JSON format that maps to A2A error types.</li> </ul>"},{"location":"specification/#324-transport-extensions","title":"3.2.4. Transport Extensions","text":"<p>Additional transport protocols MAY be defined as extensions to the core A2A specification. Such extensions:</p> <ul> <li>MUST maintain functional equivalence with the core transports</li> <li>MUST use clear namespace identifiers to avoid conflicts</li> <li>MUST be clearly documented and specified</li> <li>SHOULD provide migration paths from core transports</li> </ul>"},{"location":"specification/#33-streaming-transport-server-sent-events","title":"3.3. Streaming Transport (Server-Sent Events)","text":"<p>Streaming capabilities are transport-specific:</p>"},{"location":"specification/#331-json-rpc-20-streaming","title":"3.3.1. JSON-RPC 2.0 Streaming","text":"<p>When streaming is used for methods like <code>message/stream</code> or <code>tasks/resubscribe</code>:</p> <ul> <li>The server responds with an HTTP <code>200 OK</code> status and a <code>Content-Type</code> header of <code>text/event-stream</code>.</li> <li>The body of this HTTP response contains a stream of Server-Sent Events (SSE) as defined by the W3C.</li> <li>Each SSE <code>data</code> field contains a complete JSON-RPC 2.0 Response object (specifically, a <code>SendStreamingMessageResponse</code>).</li> </ul>"},{"location":"specification/#332-grpc-streaming","title":"3.3.2. gRPC Streaming","text":"<p>gRPC transport uses server streaming RPCs for streaming operations as defined in the Protocol Buffers specification.</p>"},{"location":"specification/#333-httpjsonrest-streaming","title":"3.3.3. HTTP+JSON/REST Streaming","text":"<p>If REST transport is supported it MUST implement streaming using Server-Sent Events similar to JSON-RPC.</p>"},{"location":"specification/#34-transport-compliance-and-interoperability","title":"3.4. Transport Compliance and Interoperability","text":""},{"location":"specification/#341-functional-equivalence-requirements","title":"3.4.1. Functional Equivalence Requirements","text":"<p>When an agent supports multiple transports, all supported transports MUST:</p> <ul> <li>Identical Functionality: Provide the same set of operations and capabilities.</li> <li>Consistent Behavior: Return semantically equivalent results for the same requests.</li> <li>Same Error Handling: Map errors consistently across transports using the error codes defined in Section 8.</li> <li>Equivalent Authentication: Support the same authentication schemes declared in the <code>AgentCard</code>.</li> </ul>"},{"location":"specification/#342-transport-selection-and-negotiation","title":"3.4.2. Transport Selection and Negotiation","text":"<ul> <li>Agent Declaration: Agents MUST declare all supported transports in their <code>AgentCard</code> using the <code>preferredTransport</code> and <code>additionalInterfaces</code> fields.</li> <li>Client Choice: Clients MAY choose any transport declared by the agent.</li> <li>No Transport Negotiation: A2A does not define a dynamic transport negotiation protocol. Clients select a transport based on the static <code>AgentCard</code> information.</li> <li>Fallback Behavior: Clients SHOULD implement fallback logic to try alternative transports if their preferred transport fails. The specific fallback strategy is implementation-dependent.</li> </ul>"},{"location":"specification/#343-transport-specific-extensions","title":"3.4.3. Transport-Specific Extensions","text":"<p>Transports MAY provide transport-specific optimizations or extensions that do not compromise functional equivalence:</p> <ul> <li>gRPC: May leverage gRPC-specific features like bidirectional streaming, metadata, or custom status codes.</li> <li>REST: May provide additional HTTP caching headers or support HTTP conditional requests.</li> <li>JSON-RPC: May include additional fields in the JSON-RPC request/response objects that do not conflict with the core specification.</li> </ul> <p>Such extensions MUST be backward-compatible and MUST NOT break interoperability with clients that do not support the extensions.</p>"},{"location":"specification/#35-method-mapping-and-naming-conventions","title":"3.5. Method Mapping and Naming Conventions","text":"<p>To ensure consistency and predictability across different transports, A2A defines normative method mapping rules.</p>"},{"location":"specification/#351-json-rpc-method-naming","title":"3.5.1. JSON-RPC Method Naming","text":"<p>JSON-RPC methods MUST follow the pattern: <code>{category}/{action}</code> where:</p> <ul> <li><code>category</code> represents the resource type (e.g., \"message\", \"tasks\", \"agent\")</li> <li><code>action</code> represents the operation (e.g., \"send\", \"get\", \"cancel\")</li> <li>Nested actions use forward slashes (e.g., \"tasks/pushNotificationConfig/set\")</li> </ul>"},{"location":"specification/#352-grpc-method-naming","title":"3.5.2. gRPC Method Naming","text":"<p>gRPC methods MUST follow Protocol Buffers service conventions using PascalCase:</p> <ul> <li>Convert JSON-RPC category/action to PascalCase compound words</li> <li>Use standard gRPC method prefixes (Get, Set, List, Create, Delete, Cancel)</li> </ul>"},{"location":"specification/#353-httpjsonrest-method-naming","title":"3.5.3. HTTP+JSON/REST Method Naming","text":"<p>REST endpoints MUST follow RESTful URL patterns with appropriate HTTP verbs:</p> <ul> <li>Use resource-based URLs: <code>/v1/{resource}[/{id}][:{action}]</code></li> <li>Use standard HTTP methods aligned with REST semantics</li> <li>Use colon notation for non-CRUD actions</li> </ul>"},{"location":"specification/#354-method-mapping-compliance","title":"3.5.4. Method Mapping Compliance","text":"<p>When implementing multiple transports, agents MUST:</p> <ul> <li>Use standard mappings: Follow the method mappings defined in sections 3.5.2 and 3.5.3.</li> <li>Maintain functional equivalence: Each transport-specific method MUST provide identical functionality across all supported transports.</li> <li>Consistent parameters: Use equivalent parameter structures across transports (accounting for transport-specific serialization differences).</li> <li>Equivalent responses: Return semantically equivalent responses across all transports for the same operation.</li> </ul>"},{"location":"specification/#355-extension-method-naming","title":"3.5.5. Extension Method Naming","text":"<p>For custom or extension methods not defined in the core A2A specification:</p> <ul> <li>JSON-RPC: Follow the <code>{category}/{action}</code> pattern with a clear namespace (e.g., <code>myorg.extension/action</code>)</li> <li>gRPC: Use appropriate service and method names following Protocol Buffers conventions</li> <li>REST: Use clear resource-based URLs with appropriate HTTP methods</li> </ul> <p>Extension methods MUST be clearly documented and MUST NOT conflict with core A2A method names or semantics.</p>"},{"location":"specification/#356-method-mapping-reference-table","title":"3.5.6. Method Mapping Reference Table","text":"<p>For quick reference, the following table summarizes the method mappings across all transports:</p> JSON-RPC Method gRPC Method REST Endpoint Description <code>message/send</code> <code>SendMessage</code> <code>POST /v1/message:send</code> Send message to agent <code>message/stream</code> <code>SendStreamingMessage</code> <code>POST /v1/message:stream</code> Send message with streaming <code>tasks/get</code> <code>GetTask</code> <code>GET /v1/tasks/{id}</code> Get task status <code>tasks/list</code> <code>ListTask</code> <code>GET /v1/tasks</code> List tasks (gRPC/REST only) <code>tasks/cancel</code> <code>CancelTask</code> <code>POST /v1/tasks/{id}:cancel</code> Cancel task <code>tasks/resubscribe</code> <code>TaskSubscription</code> <code>POST /v1/tasks/{id}:subscribe</code> Resume task streaming <code>tasks/pushNotificationConfig/set</code> <code>CreateTaskPushNotification</code> <code>POST /v1/tasks/{id}/pushNotificationConfigs</code> Set push notification config <code>tasks/pushNotificationConfig/get</code> <code>GetTaskPushNotification</code> <code>GET /v1/tasks/{id}/pushNotificationConfigs/{configId}</code> Get push notification config <code>tasks/pushNotificationConfig/list</code> <code>ListTaskPushNotification</code> <code>GET /v1/tasks/{id}/pushNotificationConfigs</code> List push notification configs <code>tasks/pushNotificationConfig/delete</code> <code>DeleteTaskPushNotification</code> <code>DELETE /v1/tasks/{id}/pushNotificationConfigs/{configId}</code> Delete push notification config <code>agent/getAuthenticatedExtendedCard</code> <code>GetAgentCard</code> <code>GET /v1/card</code> Get authenticated agent card"},{"location":"specification/#4-authentication-and-authorization","title":"4. Authentication and Authorization","text":"<p>A2A treats agents as standard enterprise applications, relying on established web security practices. Identity information is not transmitted within A2A JSON-RPC payloads; it is handled at the HTTP transport layer.</p> <p>For a comprehensive guide on enterprise security aspects, see Enterprise-Ready Features.</p>"},{"location":"specification/#41-transport-security","title":"4.1. Transport Security","text":"<p>As stated in section 3.1, production deployments MUST use HTTPS. Implementations SHOULD use modern TLS configurations (TLS 1.3+ recommended) with strong cipher suites.</p>"},{"location":"specification/#42-server-identity-verification","title":"4.2. Server Identity Verification","text":"<p>A2A Clients SHOULD verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.</p>"},{"location":"specification/#43-clientuser-identity-authentication-process","title":"4.3. Client/User Identity &amp; Authentication Process","text":"<ol> <li>Discovery of Requirements: The client discovers the server's required authentication schemes via the <code>authentication</code> field in the <code>AgentCard</code>. Scheme names often align with OpenAPI Authentication methods (e.g., \"Bearer\" for OAuth 2.0 tokens, \"Basic\" for Basic Auth, \"ApiKey\" for API keys).</li> <li>Credential Acquisition (Out-of-Band): The client obtains the necessary credentials (e.g., API keys, OAuth tokens, JWTs) through an out-of-band process specific to the required authentication scheme and the identity provider. This process is outside the scope of the A2A protocol itself.</li> <li>Credential Transmission: The client includes these credentials in the appropriate HTTP headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>, <code>X-API-Key: &lt;value&gt;</code>) of every A2A request sent to the server.</li> </ol>"},{"location":"specification/#44-server-responsibilities-for-authentication","title":"4.4. Server Responsibilities for Authentication","text":"<p>The A2A Server:</p> <ul> <li>MUST authenticate every incoming request based on the provided HTTP credentials and its declared authentication requirements from its Agent Card.</li> <li>SHOULD use standard HTTP status codes like <code>401 Unauthorized</code> or <code>403 Forbidden</code> for authentication challenges or rejections.</li> <li>SHOULD include relevant HTTP headers (e.g., <code>WWW-Authenticate</code>) with <code>401 Unauthorized</code> responses to indicate the required authentication scheme(s), guiding the client.</li> <li>SHOULD verify the Client's webhook server identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.</li> </ul>"},{"location":"specification/#45-in-task-authentication-secondary-credentials","title":"4.5. In-Task Authentication (Secondary Credentials)","text":"<p>If an agent, during the execution of a task, requires additional credentials for a different system or resource (e.g., to access a specific tool on behalf of the user that requires its own auth):</p> <ol> <li>It SHOULD transition the A2A task to the <code>auth-required</code> state (see <code>TaskState</code>).</li> <li>The accompanying <code>TaskStatus.message</code> (often a <code>DataPart</code>) SHOULD provide details about the required secondary authentication, potentially using an <code>PushNotificationAuthenticationInfo</code>-like structure to describe the need.</li> <li>The A2A Client then obtains these new credentials out-of-band and provides them in a subsequent <code>message/send</code> or <code>message/stream</code> request. How these credentials are used (e.g., passed as data within the A2A message if the agent is proxying, or used by the client to interact directly with the secondary system) depends on the specific scenario.</li> </ol>"},{"location":"specification/#46-authorization","title":"4.6. Authorization","text":"<p>Once a client is authenticated, the A2A Server is responsible for authorizing the request based on the authenticated client/user identity and its own policies. Authorization logic is implementation-specific and MAY be enforced based on:</p> <ul> <li>The specific skills requested (e.g., as identified by <code>AgentSkill.id</code> from the Agent Card).</li> <li>The actions attempted within the task.</li> <li>Data access policies relevant to the resources the agent manages.</li> <li>OAuth scopes associated with the presented token, if applicable.</li> </ul> <p>Servers should implement the principle of least privilege.</p>"},{"location":"specification/#5-agent-discovery-the-agent-card","title":"5. Agent Discovery: The Agent Card","text":""},{"location":"specification/#51-purpose","title":"5.1. Purpose","text":"<p>A2A Servers MUST make an Agent Card available. The Agent Card is a JSON document that describes the server's identity, capabilities, skills, service endpoint URL, and how clients should authenticate and interact with it. Clients use this information for discovering suitable agents and for configuring their interactions.</p> <p>For more on discovery strategies, see the Agent Discovery guide.</p>"},{"location":"specification/#52-discovery-mechanisms","title":"5.2. Discovery Mechanisms","text":"<p>Clients can find Agent Cards through various methods, including but not limited to:</p> <ul> <li>Well-Known URI: Accessing a predefined path on the agent's domain (see Section 5.3).</li> <li>Registries/Catalogs: Querying curated catalogs or registries of agents (which might be enterprise-specific, public, or domain-specific).</li> <li>Direct Configuration: Clients may be pre-configured with the Agent Card URL or the card content itself.</li> </ul>"},{"location":"specification/#53-recommended-location","title":"5.3. Recommended Location","text":"<p>If using the well-known URI strategy, the recommended location for an agent's Agent Card is: <code>https://{server_domain}/.well-known/agent-card.json</code> This follows the principles of RFC 8615 for well-known URIs.</p>"},{"location":"specification/#54-security-of-agent-cards","title":"5.4. Security of Agent Cards","text":"<p>Agent Cards themselves might contain information that is considered sensitive.</p> <ul> <li>If an Agent Card contains sensitive information, the endpoint serving the card MUST be protected by appropriate access controls (e.g., mTLS, network restrictions, authentication required to fetch the card).</li> <li>It is generally NOT RECOMMENDED to include plaintext secrets (like static API keys) directly in an Agent Card. Prefer authentication schemes where clients obtain dynamic credentials out-of-band.</li> </ul>"},{"location":"specification/#55-agentcard-object-structure","title":"5.5. <code>AgentCard</code> Object Structure","text":"JSON-RPCgRPC <pre><code>/**\n * The AgentCard is a self-describing manifest for an agent. It provides essential\n * metadata including the agent's identity, capabilities, skills, supported\n * communication methods, and security requirements.\n */\nexport interface AgentCard {\n  /**\n   * The version of the A2A protocol this agent supports.\n   * @default \"0.3.0\"\n   */\n  protocolVersion: string;\n  /**\n   * A human-readable name for the agent.\n   *\n   * @TJS-examples [\"Recipe Agent\"]\n   */\n  name: string;\n  /**\n   * A human-readable description of the agent, assisting users and other agents\n   * in understanding its purpose.\n   *\n   * @TJS-examples [\"Agent that helps users with recipes and cooking.\"]\n   */\n  description: string;\n  /**\n   * The preferred endpoint URL for interacting with the agent.\n   * This URL MUST support the transport specified by 'preferredTransport'.\n   *\n   * @TJS-examples [\"https://api.example.com/a2a/v1\"]\n   */\n  url: string;\n  /**\n   * The transport protocol for the preferred endpoint (the main 'url' field).\n   * If not specified, defaults to 'JSONRPC'.\n   *\n   * IMPORTANT: The transport specified here MUST be available at the main 'url'.\n   * This creates a binding between the main URL and its supported transport protocol.\n   * Clients should prefer this transport and URL combination when both are supported.\n   *\n   * @default \"JSONRPC\"\n   * @TJS-examples [\"JSONRPC\", \"GRPC\", \"HTTP+JSON\"]\n   */\n  preferredTransport?: TransportProtocol | string;\n  /**\n   * A list of additional supported interfaces (transport and URL combinations).\n   * This allows agents to expose multiple transports, potentially at different URLs.\n   *\n   * Best practices:\n   * - SHOULD include all supported transports for completeness\n   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'\n   * - MAY reuse URLs if multiple transports are available at the same endpoint\n   * - MUST accurately declare the transport available at each URL\n   *\n   * Clients can select any interface from this list based on their transport capabilities\n   * and preferences. This enables transport negotiation and fallback scenarios.\n   */\n  additionalInterfaces?: AgentInterface[];\n  /** An optional URL to an icon for the agent. */\n  iconUrl?: string;\n  /** Information about the agent's service provider. */\n  provider?: AgentProvider;\n  /**\n   * The agent's own version number. The format is defined by the provider.\n   *\n   * @TJS-examples [\"1.0.0\"]\n   */\n  version: string;\n  /** An optional URL to the agent's documentation. */\n  documentationUrl?: string;\n  /** A declaration of optional capabilities supported by the agent. */\n  capabilities: AgentCapabilities;\n  /**\n   * A declaration of the security schemes available to authorize requests. The key is the\n   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.\n   */\n  securitySchemes?: { [scheme: string]: SecurityScheme };\n  /**\n   * A list of security requirement objects that apply to all agent interactions. Each object\n   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.\n   * This list can be seen as an OR of ANDs. Each object in the list describes one possible\n   * set of security requirements that must be present on a request. This allows specifying,\n   * for example, \"callers must either use OAuth OR an API Key AND mTLS.\"\n   *\n   * @TJS-examples [[{\"oauth\": [\"read\"]}, {\"api-key\": [], \"mtls\": []}]]\n   */\n  security?: { [scheme: string]: string[] }[];\n  /**\n   * Default set of supported input MIME types for all skills, which can be\n   * overridden on a per-skill basis.\n   */\n  defaultInputModes: string[];\n  /**\n   * Default set of supported output MIME types for all skills, which can be\n   * overridden on a per-skill basis.\n   */\n  defaultOutputModes: string[];\n  /** The set of skills, or distinct capabilities, that the agent can perform. */\n  skills: AgentSkill[];\n  /**\n   * If true, the agent can provide an extended agent card with additional details\n   * to authenticated users. Defaults to false.\n   */\n  supportsAuthenticatedExtendedCard?: boolean;\n  /** JSON Web Signatures computed for this AgentCard. */\n  signatures?: AgentCardSignature[];\n}\n</code></pre> <pre><code>// AgentCard conveys key information:\n// - Overall details (version, name, description, uses)\n// - Skills; a set of actions/solutions the agent can perform\n// - Default modalities/content types supported by the agent.\n// - Authentication requirements\n// Next ID: 19\nmessage AgentCard {\n  // The version of the A2A protocol this agent supports.\n  string protocol_version = 16;\n  // A human readable name for the agent.\n  // Example: \"Recipe Agent\"\n  string name = 1;\n  // A description of the agent's domain of action/solution space.\n  // Example: \"Agent that helps users with recipes and cooking.\"\n  string description = 2;\n  // A URL to the address the agent is hosted at. This represents the\n  // preferred endpoint as declared by the agent.\n  string url = 3;\n  // The transport of the preferred endpoint. If empty, defaults to JSONRPC.\n  string preferred_transport = 14;\n  // Announcement of additional supported transports. Client can use any of\n  // the supported transports.\n  repeated AgentInterface additional_interfaces = 15;\n  // The service provider of the agent.\n  AgentProvider provider = 4;\n  // The version of the agent.\n  // Example: \"1.0.0\"\n  string version = 5;\n  // A url to provide additional documentation about the agent.\n  string documentation_url = 6;\n  // A2A Capability set supported by the agent.\n  AgentCapabilities capabilities = 7;\n  // The security scheme details used for authenticating with this agent.\n  map&lt;string, SecurityScheme&gt; security_schemes = 8;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // Security requirements for contacting the agent.\n  // This list can be seen as an OR of ANDs. Each object in the list describes\n  // one possible set of security requirements that must be present on a\n  // request. This allows specifying, for example, \"callers must either use\n  // OAuth OR an API Key AND mTLS.\"\n  // Example:\n  // security {\n  //   schemes { key: \"oauth\" value { list: [\"read\"] } }\n  // }\n  // security {\n  //   schemes { key: \"api-key\" }\n  //   schemes { key: \"mtls\" }\n  // }\n  repeated Security security = 9;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n  // The set of interaction modes that the agent supports across all skills.\n  // This can be overridden per skill. Defined as mime types.\n  repeated string default_input_modes = 10;\n  // The mime types supported as outputs from this agent.\n  repeated string default_output_modes = 11;\n  // Skills represent a unit of ability an agent can perform. This may\n  // somewhat abstract but represents a more focused set of actions that the\n  // agent is highly likely to succeed at.\n  repeated AgentSkill skills = 12;\n  // Whether the agent supports providing an extended agent card when\n  // the user is authenticated, i.e. is the card from .well-known\n  // different than the card from GetAgentCard.\n  bool supports_authenticated_extended_card = 13;\n  // JSON Web Signatures computed for this AgentCard.\n  repeated AgentCardSignature signatures = 17;\n  // An optional URL to an icon for the agent.\n  string icon_url = 18;\n}\n</code></pre>"},{"location":"specification/#551-agentprovider-object","title":"5.5.1. <code>AgentProvider</code> Object","text":"<p>Information about the organization or entity providing the agent.</p> JSON-RPCgRPC <pre><code>/**\n * Represents the service provider of an agent.\n *\n * @TJS-examples [{ \"organization\": \"Google\", \"url\": \"https://ai.google.dev\" }]\n */\nexport interface AgentProvider {\n  /** The name of the agent provider's organization. */\n  organization: string;\n  /** A URL for the agent provider's website or relevant documentation. */\n  url: string;\n}\n</code></pre> <pre><code>// Represents information about the service provider of an agent.\nmessage AgentProvider {\n  // The providers reference url\n  // Example: \"https://ai.google.dev\"\n  string url = 1;\n  // The providers organization name\n  // Example: \"Google\"\n  string organization = 2;\n}\n</code></pre>"},{"location":"specification/#552-agentcapabilities-object","title":"5.5.2. <code>AgentCapabilities</code> Object","text":"<p>Specifies optional A2A protocol features supported by the agent.</p> JSON-RPCgRPC <pre><code>/**\n * Defines optional capabilities supported by an agent.\n */\nexport interface AgentCapabilities {\n  /** Indicates if the agent supports Server-Sent Events (SSE) for streaming responses. */\n  streaming?: boolean;\n  /** Indicates if the agent supports sending push notifications for asynchronous task updates. */\n  pushNotifications?: boolean;\n  /** Indicates if the agent provides a history of state transitions for a task. */\n  stateTransitionHistory?: boolean;\n  /** A list of protocol extensions supported by the agent. */\n  extensions?: AgentExtension[];\n}\n</code></pre> <pre><code>// Defines the A2A feature set supported by the agent\nmessage AgentCapabilities {\n  // If the agent will support streaming responses\n  bool streaming = 1;\n  // If the agent can send push notifications to the clients webhook\n  bool push_notifications = 2;\n  // Extensions supported by this agent.\n  repeated AgentExtension extensions = 3;\n}\n</code></pre>"},{"location":"specification/#5521-agentextension-object","title":"5.5.2.1. <code>AgentExtension</code> Object","text":"<p>Specifies an extension to the A2A protocol supported by the agent.</p> JSON-RPCgRPC <pre><code>/**\n * A declaration of a protocol extension supported by an Agent.\n *\n * @TJS-examples [{\"uri\": \"https://developers.google.com/identity/protocols/oauth2\", \"description\": \"Google OAuth 2.0 authentication\", \"required\": false}]\n */\nexport interface AgentExtension {\n  /** The unique URI identifying the extension. */\n  uri: string;\n  /** A human-readable description of how this agent uses the extension. */\n  description?: string;\n  /**\n   * If true, the client must understand and comply with the extension's requirements\n   * to interact with the agent.\n   */\n  required?: boolean;\n  /** Optional, extension-specific configuration parameters. */\n  params?: { [key: string]: any };\n}\n</code></pre> <pre><code>// A declaration of an extension supported by an Agent.\nmessage AgentExtension {\n  // The URI of the extension.\n  // Example: \"https://developers.google.com/identity/protocols/oauth2\"\n  string uri = 1;\n  // A description of how this agent uses this extension.\n  // Example: \"Google OAuth 2.0 authentication\"\n  string description = 2;\n  // Whether the client must follow specific requirements of the extension.\n  // Example: false\n  bool required = 3;\n  // Optional configuration for the extension.\n  google.protobuf.Struct params = 4;\n}\n</code></pre>"},{"location":"specification/#553-securityscheme-object","title":"5.5.3. <code>SecurityScheme</code> Object","text":"<p>Describes the authentication requirements for accessing the agent's <code>url</code> endpoint. Refer Sample Agent Card for an example.</p> JSON-RPCgRPC <pre><code>/**\n * Defines a security scheme that can be used to secure an agent's endpoints.\n * This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.\n *\n * @see {@link https://swagger.io/specification/#security-scheme-object}\n */\nexport type SecurityScheme =\n  | APIKeySecurityScheme\n  | HTTPAuthSecurityScheme\n  | OAuth2SecurityScheme\n  | OpenIdConnectSecurityScheme\n  | MutualTLSSecurityScheme;\n</code></pre> <pre><code>message SecurityScheme {\n  oneof scheme {\n    APIKeySecurityScheme api_key_security_scheme = 1;\n    HTTPAuthSecurityScheme http_auth_security_scheme = 2;\n    OAuth2SecurityScheme oauth2_security_scheme = 3;\n    OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4;\n    MutualTlsSecurityScheme mtls_security_scheme = 5;\n  }\n}\n</code></pre>"},{"location":"specification/#554-agentskill-object","title":"5.5.4. <code>AgentSkill</code> Object","text":"<p>Describes a specific capability, function, or area of expertise the agent can perform or address.</p> JSON-RPCgRPC <pre><code>/**\n * Represents a distinct capability or function that an agent can perform.\n */\nexport interface AgentSkill {\n  /** A unique identifier for the agent's skill. */\n  id: string;\n  /** A human-readable name for the skill. */\n  name: string;\n  /**\n   * A detailed description of the skill, intended to help clients or users\n   * understand its purpose and functionality.\n   */\n  description: string;\n  /**\n   * A set of keywords describing the skill's capabilities.\n   *\n   * @TJS-examples [[\"cooking\", \"customer support\", \"billing\"]]\n   */\n  tags: string[];\n  /**\n   * Example prompts or scenarios that this skill can handle. Provides a hint to\n   * the client on how to use the skill.\n   *\n   * @TJS-examples [[\"I need a recipe for bread\"]]\n   */\n  examples?: string[];\n  /**\n   * The set of supported input MIME types for this skill, overriding the agent's defaults.\n   */\n  inputModes?: string[];\n  /**\n   * The set of supported output MIME types for this skill, overriding the agent's defaults.\n   */\n  outputModes?: string[];\n  /**\n   * Security schemes necessary for the agent to leverage this skill.\n   * As in the overall AgentCard.security, this list represents a logical OR of security\n   * requirement objects. Each object is a set of security schemes that must be used together\n   * (a logical AND).\n   *\n   * @TJS-examples [[{\"google\": [\"oidc\"]}]]\n   */\n  security?: { [scheme: string]: string[] }[];\n}\n</code></pre> <pre><code>// AgentSkill represents a unit of action/solution that the agent can perform.\n// One can think of this as a type of highly reliable solution that an agent\n// can be tasked to provide. Agents have the autonomy to choose how and when\n// to use specific skills, but clients should have confidence that if the\n// skill is defined that unit of action can be reliably performed.\nmessage AgentSkill {\n  // Unique identifier of the skill within this agent.\n  string id = 1;\n  // A human readable name for the skill.\n  string name = 2;\n  // A human (or llm) readable description of the skill\n  // details and behaviors.\n  string description = 3;\n  // A set of tags for the skill to enhance categorization/utilization.\n  // Example: [\"cooking\", \"customer support\", \"billing\"]\n  repeated string tags = 4;\n  // A set of example queries that this skill is designed to address.\n  // These examples should help the caller to understand how to craft requests\n  // to the agent to achieve specific goals.\n  // Example: [\"I need a recipe for bread\"]\n  repeated string examples = 5;\n  // Possible input modalities supported.\n  repeated string input_modes = 6;\n  // Possible output modalities produced\n  repeated string output_modes = 7;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // Security schemes necessary for the agent to leverage this skill.\n  // As in the overall AgentCard.security, this list represents a logical OR of\n  // security requirement objects. Each object is a set of security schemes\n  // that must be used together (a logical AND).\n  repeated Security security = 8;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n}\n</code></pre>"},{"location":"specification/#555-agentinterface-object","title":"5.5.5. <code>AgentInterface</code> Object","text":"<p>Provides a declaration of a combination of the target URL and the supported transport to interact with the agent. This enables agents to expose the same functionality through multiple transport protocols.</p> <pre><code>/**\n * Supported A2A transport protocols.\n */\nexport enum TransportProtocol {\n  JSONRPC = \"JSONRPC\", // JSON-RPC 2.0 over HTTP (mandatory)\n  GRPC = \"GRPC\", // gRPC over HTTP/2 (optional)\n  HTTP_JSON = \"HTTP+JSON\", // REST-style HTTP with JSON (optional)\n}\n</code></pre> JSON-RPCgRPC <pre><code>/**\n * Declares a combination of a target URL and a transport protocol for interacting with the agent.\n * This allows agents to expose the same functionality over multiple transport mechanisms.\n */\nexport interface AgentInterface {\n  /**\n   * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.\n   * @TJS-examples [\"https://api.example.com/a2a/v1\", \"https://grpc.example.com/a2a\", \"https://rest.example.com/v1\"]\n   */\n  url: string;\n  /**\n   * The transport protocol supported at this URL.\n   *\n   * @TJS-examples [\"JSONRPC\", \"GRPC\", \"HTTP+JSON\"]\n   */\n  transport: TransportProtocol | string;\n}\n</code></pre> <pre><code>// Defines additional transport information for the agent.\nmessage AgentInterface {\n  // The url this interface is found at.\n  string url = 1;\n  // The transport supported this url. This is an open form string, to be\n  // easily extended for many transport protocols. The core ones officially\n  // supported are JSONRPC, GRPC and HTTP+JSON.\n  string transport = 2;\n}\n</code></pre> <p>The <code>transport</code> field SHOULD use one of the core A2A transport protocol values:</p> <ul> <li><code>\"JSONRPC\"</code>: JSON-RPC 2.0 over HTTP</li> <li><code>\"GRPC\"</code>: gRPC over HTTP/2</li> <li><code>\"HTTP+JSON\"</code>: REST-style HTTP with JSON</li> </ul> <p>Additional transport values MAY be used for future extensions, but such extensions MUST not conflict with core A2A protocol functionality.</p>"},{"location":"specification/#556-agentcardsignature-object","title":"5.5.6. <code>AgentCardSignature</code> Object","text":"<p>Represents a JSON Web Signature (JWS) used to verify the integrity of the AgentCard.</p> JSON-RPCgRPC <pre><code>/**\n * AgentCardSignature represents a JWS signature of an AgentCard.\n * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).\n */\nexport interface AgentCardSignature {\n  /**\n   * The protected JWS header for the signature. This is a Base64url-encoded\n   * JSON object, as per RFC 7515.\n   */\n  protected: string;\n  /** The computed signature, Base64url-encoded. */\n  signature: string;\n  /** The unprotected JWS header values. */\n  header?: { [key: string]: any };\n}\n</code></pre> <pre><code>// AgentCardSignature represents a JWS signature of an AgentCard.\n// This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).\nmessage AgentCardSignature {\n  // The protected JWS header for the signature. This is always a\n  // base64url-encoded JSON object. Required.\n  string protected = 1 [(google.api.field_behavior) = REQUIRED];\n  // The computed signature, base64url-encoded. Required.\n  string signature = 2 [(google.api.field_behavior) = REQUIRED];\n  // The unprotected JWS header values.\n  google.protobuf.Struct header = 3;\n}\n</code></pre>"},{"location":"specification/#56-transport-declaration-and-url-relationships","title":"5.6. Transport Declaration and URL Relationships","text":"<p>The AgentCard MUST properly declare the relationship between URLs and transport protocols:</p>"},{"location":"specification/#561-main-url-and-preferred-transport","title":"5.6.1. Main URL and Preferred Transport","text":"<ul> <li>Main URL requirement: The <code>url</code> field MUST specify the primary endpoint for the agent.</li> <li>Transport correspondence: The transport protocol available at the main <code>url</code> MUST match the <code>preferredTransport</code> field.</li> <li>Required declaration: The <code>preferredTransport</code> field is REQUIRED and MUST be present in every <code>AgentCard</code>.</li> <li>Transport availability: The main <code>url</code> MUST support the transport protocol declared in <code>preferredTransport</code>.</li> </ul>"},{"location":"specification/#562-additional-interfaces","title":"5.6.2. Additional Interfaces","text":"<ul> <li>URL uniqueness: Each <code>AgentInterface</code> in <code>additionalInterfaces</code> SHOULD specify a distinct URL for clarity, but MAY reuse URLs if multiple transport protocols are available at the same endpoint.</li> <li>Transport declaration: Each <code>AgentInterface</code> MUST accurately declare the transport protocol available at its specified URL.</li> <li>Completeness: The <code>additionalInterfaces</code> array SHOULD include all supported transports, including the main URL's transport for completeness.</li> </ul>"},{"location":"specification/#563-client-transport-selection-rules","title":"5.6.3. Client Transport Selection Rules","text":"<p>Clients MUST follow these rules when selecting a transport:</p> <ol> <li>Parse transport declarations: Extract available transports from both the main <code>url</code>/<code>preferredTransport</code> combination and all <code>additionalInterfaces</code>.</li> <li>Prefer declared preference: If the client supports the <code>preferredTransport</code>, it SHOULD use the main <code>url</code>.</li> <li>Fallback selection: If the preferred transport is not supported by the client, it MAY select any supported transport from <code>additionalInterfaces</code>.</li> <li>Graceful degradation: Clients SHOULD implement fallback logic to try alternative transports if their first choice fails.</li> <li>URL-transport matching: Clients MUST use the correct URL for the selected transport protocol as declared in the AgentCard.</li> </ol>"},{"location":"specification/#564-validation-requirements","title":"5.6.4. Validation Requirements","text":"<p>Agent Cards MUST satisfy these validation requirements:</p> <ul> <li>Transport consistency: The <code>preferredTransport</code> value MUST be present and MUST be available at the main <code>url</code>.</li> <li>Interface completeness: If <code>additionalInterfaces</code> is provided, it SHOULD include an entry corresponding to the main <code>url</code> and <code>preferredTransport</code>.</li> <li>No conflicts: The same URL MUST NOT declare conflicting transport protocols across different interface declarations.</li> <li>Minimum transport requirement: The agent MUST declare at least one supported transport protocol through either the main <code>url</code>/<code>preferredTransport</code> combination or <code>additionalInterfaces</code>.</li> </ul>"},{"location":"specification/#57-sample-agent-card","title":"5.7. Sample Agent Card","text":"<pre><code>{\n  \"protocolVersion\": \"0.2.9\",\n  \"name\": \"GeoSpatial Route Planner Agent\",\n  \"description\": \"Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.\",\n  \"url\": \"https://georoute-agent.example.com/a2a/v1\",\n  \"preferredTransport\": \"JSONRPC\",\n  \"additionalInterfaces\" : [\n    {\"url\": \"https://georoute-agent.example.com/a2a/v1\", \"transport\": \"JSONRPC\"},\n    {\"url\": \"https://georoute-agent.example.com/a2a/grpc\", \"transport\": \"GRPC\"},\n    {\"url\": \"https://georoute-agent.example.com/a2a/json\", \"transport\": \"HTTP+JSON\"}\n  ],\n  \"provider\": {\n    \"organization\": \"Example Geo Services Inc.\",\n    \"url\": \"https://www.examplegeoservices.com\"\n  },\n  \"iconUrl\": \"https://georoute-agent.example.com/icon.png\",\n  \"version\": \"1.2.0\",\n  \"documentationUrl\": \"https://docs.examplegeoservices.com/georoute-agent/api\",\n  \"capabilities\": {\n    \"streaming\": true,\n    \"pushNotifications\": true,\n    \"stateTransitionHistory\": false\n  },\n  \"securitySchemes\": {\n    \"google\": {\n      \"type\": \"openIdConnect\",\n      \"openIdConnectUrl\": \"https://accounts.google.com/.well-known/openid-configuration\"\n    }\n  },\n  \"security\": [{ \"google\": [\"openid\", \"profile\", \"email\"] }],\n  \"defaultInputModes\": [\"application/json\", \"text/plain\"],\n  \"defaultOutputModes\": [\"application/json\", \"image/png\"],\n  \"skills\": [\n    {\n      \"id\": \"route-optimizer-traffic\",\n      \"name\": \"Traffic-Aware Route Optimizer\",\n      \"description\": \"Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).\",\n      \"tags\": [\"maps\", \"routing\", \"navigation\", \"directions\", \"traffic\"],\n      \"examples\": [\n        \"Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.\",\n        \"{\\\"origin\\\": {\\\"lat\\\": 37.422, \\\"lng\\\": -122.084}, \\\"destination\\\": {\\\"lat\\\": 37.7749, \\\"lng\\\": -122.4194}, \\\"preferences\\\": [\\\"avoid_ferries\\\"]}\"\n      ],\n      \"inputModes\": [\"application/json\", \"text/plain\"],\n      \"outputModes\": [\n        \"application/json\",\n        \"application/vnd.geo+json\",\n        \"text/html\"\n      ]\n    },\n    {\n      \"id\": \"custom-map-generator\",\n      \"name\": \"Personalized Map Generator\",\n      \"description\": \"Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.\",\n      \"tags\": [\"maps\", \"customization\", \"visualization\", \"cartography\"],\n      \"examples\": [\n        \"Generate a map of my upcoming road trip with all planned stops highlighted.\",\n        \"Show me a map visualizing all coffee shops within a 1-mile radius of my current location.\"\n      ],\n      \"inputModes\": [\"application/json\"],\n      \"outputModes\": [\n        \"image/png\",\n        \"image/jpeg\",\n        \"application/json\",\n        \"text/html\"\n      ]\n    }\n  ],\n  \"supportsAuthenticatedExtendedCard\": true,\n  \"signatures\": [\n    {\n      \"protected\": \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0\",\n      \"signature\": \"QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ\"\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#6-protocol-data-objects","title":"6. Protocol Data Objects","text":"<p>These objects define the structure of data exchanged within the JSON-RPC methods of the A2A protocol.</p>"},{"location":"specification/#61-task-object","title":"6.1. <code>Task</code> Object","text":"<p>Represents the stateful unit of work being processed by the A2A Server for an A2A Client. A task encapsulates the entire interaction related to a specific goal or request. A task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Tasks in completed state SHOULD use artifacts for returning the generated output to the clients. For more information, refer to the Life of a Task guide.</p> JSON-RPCgRPC <pre><code>/**\n * Represents a single, stateful operation or conversation between a client and an agent.\n */\nexport interface Task {\n  /** A unique identifier (e.g. UUID) for the task, generated by the server for a new task. */\n  id: string;\n  /**\n   * A server-generated unique identifier (e.g. UUID) for maintaining context across multiple related tasks or interactions.\n   */\n  contextId: string;\n  /** The current status of the task, including its state and a descriptive message. */\n  status: TaskStatus;\n  /** An array of messages exchanged during the task, representing the conversation history. */\n  history?: Message[];\n  /** A collection of artifacts generated by the agent during the execution of the task. */\n  artifacts?: Artifact[];\n  /** Optional metadata for extensions. The key is an extension-specific identifier. */\n  metadata?: {\n    [key: string]: any;\n  };\n  /** The type of this object, used as a discriminator. Always 'task' for a Task. */\n  readonly kind: \"task\";\n}\n</code></pre> <pre><code>// Task is the core unit of action for A2A. It has a current status\n// and when results are created for the task they are stored in the\n// artifact. If there are multiple turns for a task, these are stored in\n// history.\nmessage Task {\n  // Unique identifier (e.g. UUID) for the task, generated by the server for a\n  // new task.\n  string id = 1;\n  // Unique identifier (e.g. UUID) for the contextual collection of interactions\n  // (tasks and messages). Created by the A2A server.\n  string context_id = 2;\n  // The current status of a Task, including state and a message.\n  TaskStatus status = 3;\n  // A set of output artifacts for a Task.\n  repeated Artifact artifacts = 4;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // The history of interactions from a task.\n  repeated Message history = 5;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n  // A key/value object to store custom metadata about a task.\n  google.protobuf.Struct metadata = 6;\n}\n</code></pre>"},{"location":"specification/#62-taskstatus-object","title":"6.2. <code>TaskStatus</code> Object","text":"<p>Represents the current state and associated context (e.g., a message from the agent) of a <code>Task</code>.</p> JSON-RPCgRPC <pre><code>/**\n * Represents the status of a task at a specific point in time.\n */\nexport interface TaskStatus {\n  /** The current state of the task's lifecycle. */\n  state: TaskState;\n  /** An optional, human-readable message providing more details about the current status. */\n  message?: Message;\n  /**\n   * An ISO 8601 datetime string indicating when this status was recorded.\n   *\n   * @TJS-examples [\"2023-10-27T10:00:00Z\"]\n   */\n  timestamp?: string;\n}\n</code></pre> <pre><code>// A container for the status of a task\nmessage TaskStatus {\n  // The current state of this task\n  TaskState state = 1;\n  // A message associated with the status.\n  Message update = 2 [json_name = \"message\"];\n  // Timestamp when the status was recorded.\n  // Example: \"2023-10-27T10:00:00Z\"\n  google.protobuf.Timestamp timestamp = 3;\n}\n</code></pre>"},{"location":"specification/#63-taskstate-enum","title":"6.3. <code>TaskState</code> Enum","text":"<p>Defines the possible lifecycle states of a <code>Task</code>.</p> JSON-RPCgRPC <pre><code>/**\n * Defines the lifecycle states of a Task.\n */\nexport enum TaskState {\n  /** The task has been submitted and is awaiting execution. */\n  Submitted = \"submitted\",\n  /** The agent is actively working on the task. */\n  Working = \"working\",\n  /** The task is paused and waiting for input from the user. */\n  InputRequired = \"input-required\",\n  /** The task has been successfully completed. */\n  Completed = \"completed\",\n  /** The task has been canceled by the user. */\n  Canceled = \"canceled\",\n  /** The task failed due to an error during execution. */\n  Failed = \"failed\",\n  /** The task was rejected by the agent and was not started. */\n  Rejected = \"rejected\",\n  /** The task requires authentication to proceed. */\n  AuthRequired = \"auth-required\",\n  /** The task is in an unknown or indeterminate state. */\n  Unknown = \"unknown\",\n}\n</code></pre> <pre><code>// The set of states a Task can be in.\nenum TaskState {\n  TASK_STATE_UNSPECIFIED = 0;\n  // Represents the status that acknowledges a task is created\n  TASK_STATE_SUBMITTED = 1;\n  // Represents the status that a task is actively being processed\n  TASK_STATE_WORKING = 2;\n  // Represents the status a task is finished. This is a terminal state\n  TASK_STATE_COMPLETED = 3;\n  // Represents the status a task is done but failed. This is a terminal state\n  TASK_STATE_FAILED = 4;\n  // Represents the status a task was cancelled before it finished.\n  // This is a terminal state.\n  TASK_STATE_CANCELLED = 5;\n  // Represents the status that the task requires information to complete.\n  // This is an interrupted state.\n  TASK_STATE_INPUT_REQUIRED = 6;\n  // Represents the status that the agent has decided to not perform the task.\n  // This may be done during initial task creation or later once an agent\n  // has determined it can't or won't proceed. This is a terminal state.\n  TASK_STATE_REJECTED = 7;\n  // Represents the state that some authentication is needed from the upstream\n  // client. Authentication is expected to come out-of-band thus this is not\n  // an interrupted or terminal state.\n  TASK_STATE_AUTH_REQUIRED = 8;\n}\n</code></pre>"},{"location":"specification/#64-message-object","title":"6.4. <code>Message</code> Object","text":"<p>Represents a single communication turn or a piece of contextual information between a client and an agent. Messages are used for instructions, prompts, replies, and status updates.</p> JSON-RPCgRPC <pre><code>/**\n * Represents a single message in the conversation between a user and an agent.\n */\nexport interface Message {\n  /** Identifies the sender of the message. `user` for the client, `agent` for the service. */\n  readonly role: \"user\" | \"agent\";\n  /**\n   * An array of content parts that form the message body. A message can be\n   * composed of multiple parts of different types (e.g., text and files).\n   */\n  parts: Part[];\n  /** Optional metadata for extensions. The key is an extension-specific identifier. */\n  metadata?: {\n    [key: string]: any;\n  };\n  /** The URIs of extensions that are relevant to this message. */\n  extensions?: string[];\n  /**\n   * A list of other task IDs that this message references for additional context.\n   */\n  referenceTaskIds?: string[];\n  /**\n   * A unique identifier for the message, typically a UUID, generated by the sender.\n   */\n  messageId: string;\n  /**\n   * The ID of the task this message is part of. Can be omitted for the first message of a new task.\n   */\n  taskId?: string;\n  /**\n   * The context ID for this message, used to group related interactions.\n   */\n  contextId?: string;\n  /** The type of this object, used as a discriminator. Always 'message' for a Message. */\n  readonly kind: \"message\";\n}\n</code></pre> <pre><code>// Message is one unit of communication between client and server. It is\n// associated with a context and optionally a task. Since the server is\n// responsible for the context definition, it must always provide a context_id\n// in its messages. The client can optionally provide the context_id if it\n// knows the context to associate the message to. Similarly for task_id,\n// except the server decides if a task is created and whether to include the\n// task_id.\nmessage Message {\n  // The unique identifier (e.g. UUID)of the message. This is required and\n  // created by the message creator.\n  string message_id = 1;\n  // The context id of the message. This is optional and if set, the message\n  // will be associated with the given context.\n  string context_id = 2;\n  // The task id of the message. This is optional and if set, the message\n  // will be associated with the given task.\n  string task_id = 3;\n  // A role for the message.\n  Role role = 4;\n  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED\n  // Content is the container of the message content.\n  repeated Part content = 5;\n  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED\n  // Any optional metadata to provide along with the message.\n  google.protobuf.Struct metadata = 6;\n  // The URIs of extensions that are present or contributed to this Message.\n  repeated string extensions = 7;\n}\n</code></pre>"},{"location":"specification/#65-part-union-type","title":"6.5. <code>Part</code> Union Type","text":"<p>Represents a distinct piece of content within a <code>Message</code> or <code>Artifact</code>. A <code>Part</code> is a union type representing exportable content as either <code>TextPart</code>, <code>FilePart</code>, or <code>DataPart</code>. All <code>Part</code> types also include an optional <code>metadata</code> field (<code>Record&lt;string, any&gt;</code>) for part-specific metadata.</p> JSON-RPCgRPC <pre><code>/**\n * A discriminated union representing a part of a message or artifact, which can\n * be text, a file, or structured data.\n */\nexport type Part = TextPart | FilePart | DataPart;\n</code></pre> <pre><code>// Part represents a container for a section of communication content.\n// Parts can be purely textual, some sort of file (image, video, etc) or\n// a structured data blob (i.e. JSON).\nmessage Part {\n  oneof part {\n    string text = 1;\n    FilePart file = 2;\n    DataPart data = 3;\n  }\n  // Optional metadata associated with this part.\n  google.protobuf.Struct metadata = 4;\n}\n</code></pre> <pre><code>/**\n * Defines base properties common to all message or artifact parts.\n */\nexport interface PartBase {\n  /** Optional metadata associated with this part. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre> <p>It MUST be one of the following:</p>"},{"location":"specification/#651-textpart-object","title":"6.5.1. <code>TextPart</code> Object","text":"<p>For conveying plain textual content.</p> <pre><code>/**\n * Represents a text segment within a message or artifact.\n */\nexport interface TextPart extends PartBase {\n  /** The type of this part, used as a discriminator. Always 'text'. */\n  readonly kind: \"text\";\n  /** The string content of the text part. */\n  text: string;\n}\n</code></pre>"},{"location":"specification/#652-filepart-object","title":"6.5.2. <code>FilePart</code> Object","text":"<p>For conveying file-based content.</p> JSON-RPCgRPC <pre><code>/**\n * Represents a file segment within a message or artifact. The file content can be\n * provided either directly as bytes or as a URI.\n */\nexport interface FilePart extends PartBase {\n  /** The type of this part, used as a discriminator. Always 'file'. */\n  readonly kind: \"file\";\n  /** The file content, represented as either a URI or as base64-encoded bytes. */\n  file: FileWithBytes | FileWithUri;\n}\n</code></pre> <pre><code>// FilePart represents the different ways files can be provided. If files are\n// small, directly feeding the bytes is supported via file_with_bytes. If the\n// file is large, the agent should read the content as appropriate directly\n// from the file_with_uri source.\nmessage FilePart {\n  oneof file {\n    string file_with_uri = 1;\n    bytes file_with_bytes = 2;\n  }\n  string mime_type = 3;\n  string name = 4;\n}\n</code></pre>"},{"location":"specification/#653-datapart-object","title":"6.5.3. <code>DataPart</code> Object","text":"<p>For conveying structured JSON data. Useful for forms, parameters, or any machine-readable information.</p> JSON-RPCgRPC <pre><code>/**\n * Represents a structured data segment (e.g., JSON) within a message or artifact.\n */\nexport interface DataPart extends PartBase {\n  /** The type of this part, used as a discriminator. Always 'data'. */\n  readonly kind: \"data\";\n  /** The structured data content. */\n  data: {\n    [key: string]: any;\n  };\n}\n</code></pre> <pre><code>// DataPart represents a structured blob. This is most commonly a JSON payload.\nmessage DataPart {\n  google.protobuf.Struct data = 1;\n}\n</code></pre>"},{"location":"specification/#66-filebase-object","title":"6.6 <code>FileBase</code> Object","text":"<p>Base entity for File Contents.</p> <pre><code>/**\n * Defines base properties for a file.\n */\nexport interface FileBase {\n  /** An optional name for the file (e.g., \"document.pdf\"). */\n  name?: string;\n  /** The MIME type of the file (e.g., \"application/pdf\"). */\n  mimeType?: string;\n}\n</code></pre>"},{"location":"specification/#661-filewithbytes-object","title":"6.6.1 <code>FileWithBytes</code> Object","text":"<p>Represents the data for a file, used within a <code>FilePart</code>.</p> <pre><code>/**\n * Represents a file with its content provided directly as a base64-encoded string.\n */\nexport interface FileWithBytes extends FileBase {\n  /** The base64-encoded content of the file. */\n  bytes: string;\n  /** The `uri` property must be absent when `bytes` is present. */\n  uri?: never;\n}\n</code></pre>"},{"location":"specification/#662-filewithuri-object","title":"6.6.2 <code>FileWithUri</code> Object","text":"<p>Represents the URI for a file, used within a <code>FilePart</code>.</p> <pre><code>/**\n * Represents a file with its content located at a specific URI.\n */\nexport interface FileWithUri extends FileBase {\n  /** A URL pointing to the file's content. */\n  uri: string;\n  /** The `bytes` property must be absent when `uri` is present. */\n  bytes?: never;\n}\n</code></pre>"},{"location":"specification/#67-artifact-object","title":"6.7. <code>Artifact</code> Object","text":"<p>Represents a tangible output generated by the agent during a task. Artifacts are the results or products of the agent's work.</p> JSON-RPCgRPC <pre><code>/**\n * Represents a file, data structure, or other resource generated by an agent during a task.\n */\nexport interface Artifact {\n  /**\n   * A unique identifier (e.g. UUID) for the artifact within the scope of the task.\n   */\n  artifactId: string;\n  /** An optional, human-readable name for the artifact. */\n  name?: string;\n  /** An optional, human-readable description of the artifact. */\n  description?: string;\n  /** An array of content parts that make up the artifact. */\n  parts: Part[];\n  /** Optional metadata for extensions. The key is an extension-specific identifier. */\n  metadata?: {\n    [key: string]: any;\n  };\n  /** The URIs of extensions that are relevant to this artifact. */\n  extensions?: string[];\n}\n</code></pre> <pre><code>// Artifacts are the container for task completed results. These are similar\n// to Messages but are intended to be the product of a task, as opposed to\n// point-to-point communication.\nmessage Artifact {\n  // Unique identifier (e.g. UUID) for the artifact. It must be at least unique\n  // within a task.\n  string artifact_id = 1;\n  // A human readable name for the artifact.\n  string name = 3;\n  // A human readable description of the artifact, optional.\n  string description = 4;\n  // The content of the artifact.\n  repeated Part parts = 5;\n  // Optional metadata included with the artifact.\n  google.protobuf.Struct metadata = 6;\n  // The URIs of extensions that are present or contributed to this Artifact.\n  repeated string extensions = 7;\n}\n</code></pre>"},{"location":"specification/#68-pushnotificationconfig-object","title":"6.8. <code>PushNotificationConfig</code> Object","text":"<p>Configuration provided by the client to the server for sending asynchronous push notifications about task updates.</p> JSON-RPCgRPC <pre><code>/**\n * Defines the configuration for setting up push notifications for task updates.\n */\nexport interface PushNotificationConfig {\n  /**\n   * A unique identifier (e.g. UUID) for the push notification configuration, set by the client\n   * to support multiple notification callbacks.\n   */\n  id?: string;\n  /** The callback URL where the agent should send push notifications. */\n  url: string;\n  /** A unique token for this task or session to validate incoming push notifications. */\n  token?: string;\n  /** Optional authentication details for the agent to use when calling the notification URL. */\n  authentication?: PushNotificationAuthenticationInfo;\n}\n</code></pre> <pre><code>// Configuration for setting up push notifications for task updates.\nmessage PushNotificationConfig {\n  // A unique identifier (e.g. UUID) for this push notification.\n  string id = 1;\n  // Url to send the notification too\n  string url = 2;\n  // Token unique for this task/session\n  string token = 3;\n  // Information about the authentication to sent with the notification\n  AuthenticationInfo authentication = 4;\n}\n</code></pre>"},{"location":"specification/#69-pushnotificationauthenticationinfo-object","title":"6.9. <code>PushNotificationAuthenticationInfo</code> Object","text":"<p>A generic structure for specifying authentication requirements, typically used within <code>PushNotificationConfig</code> to describe how the A2A Server should authenticate to the client's webhook.</p> JSON-RPCgRPC <pre><code>/**\n * Defines authentication details for a push notification endpoint.\n */\nexport interface PushNotificationAuthenticationInfo {\n  /** A list of supported authentication schemes (e.g., 'Basic', 'Bearer'). */\n  schemes: string[];\n  /** Optional credentials required by the push notification endpoint. */\n  credentials?: string;\n}\n</code></pre> <pre><code>// Defines authentication details, used for push notifications.\nmessage AuthenticationInfo {\n  // Supported authentication schemes - e.g. Basic, Bearer, etc\n  repeated string schemes = 1;\n  // Optional credentials\n  string credentials = 2;\n}\n</code></pre>"},{"location":"specification/#610-taskpushnotificationconfig-object","title":"6.10. <code>TaskPushNotificationConfig</code> Object","text":"<p>Used as the <code>params</code> object for the <code>tasks/pushNotificationConfig/set</code> method and as the <code>result</code> object for the <code>tasks/pushNotificationConfig/get</code> method.</p> JSON-RPCgRPC <pre><code>/**\n * A container associating a push notification configuration with a specific task.\n */\nexport interface TaskPushNotificationConfig {\n  /**\n   * The unique identifier (e.g. UUID) of the task.\n   */\n  taskId: string;\n  /** The push notification configuration for this task. */\n  pushNotificationConfig: PushNotificationConfig;\n}\n</code></pre> <pre><code>message TaskPushNotificationConfig {\n  // The resource name of the config.\n  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}\n  string name = 1;\n  // The push notification configuration details.\n  PushNotificationConfig push_notification_config = 2;\n}\n</code></pre>"},{"location":"specification/#611-json-rpc-structures","title":"6.11. JSON-RPC Structures","text":"<p>A2A adheres to the standard JSON-RPC 2.0 structures for requests and responses.</p>"},{"location":"specification/#6111-jsonrpcrequest-object","title":"6.11.1. <code>JSONRPCRequest</code> Object","text":"<p>All A2A method calls are encapsulated in a JSON-RPC Request object.</p> <ul> <li><code>jsonrpc</code>: A String specifying the version of the JSON-RPC protocol. MUST be exactly <code>\"2.0\"</code>.</li> <li><code>method</code>: A String containing the name of the method to be invoked (e.g., <code>\"message/send\"</code>, <code>\"tasks/get\"</code>).</li> <li><code>params</code>: A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted if the method expects no parameters. A2A methods typically use an <code>object</code> for <code>params</code>.</li> <li><code>id</code>: An identifier established by the Client that MUST contain a String, Number, or <code>NULL</code> value if included. If it is not included it is assumed to be a notification. The value SHOULD NOT be <code>NULL</code> for requests expecting a response, and Numbers SHOULD NOT contain fractional parts. The Server MUST reply with the same value in the Response object if included. This member is used to correlate the context between the two objects. A2A methods typically expect a response or stream, so <code>id</code> will usually be present and non-null.</li> </ul>"},{"location":"specification/#6112-jsonrpcresponse-object","title":"6.11.2. <code>JSONRPCResponse</code> Object","text":"<p>Responses from the A2A Server are encapsulated in a JSON-RPC Response object.</p> <ul> <li><code>jsonrpc</code>: A String specifying the version of the JSON-RPC protocol. MUST be exactly <code>\"2.0\"</code>.</li> <li><code>id</code>: This member is REQUIRED. It MUST be the same as the value of the <code>id</code> member in the Request Object. If there was an error in detecting the <code>id</code> in the Request object (e.g. Parse error/Invalid Request), it MUST be <code>null</code>.</li> <li>EITHER <code>result</code>: This member is REQUIRED on success. This member MUST NOT exist if there was an error invoking the method. The value of this member is determined by the method invoked on the Server.</li> <li>OR <code>error</code>: This member is REQUIRED on failure. This member MUST NOT exist if there was no error triggered during invocation. The value of this member MUST be an <code>JSONRPCError</code> object.</li> <li>The members <code>result</code> and <code>error</code> are mutually exclusive: one MUST be present, and the other MUST NOT.</li> </ul>"},{"location":"specification/#612-jsonrpcerror-object","title":"6.12. <code>JSONRPCError</code> Object","text":"<p>When a JSON-RPC call encounters an error, the Response Object will contain an <code>error</code> member with a value of this structure.</p> <pre><code>/**\n * Represents a JSON-RPC 2.0 Error object, included in an error response.\n */\nexport interface JSONRPCError {\n  /**\n   * A number that indicates the error type that occurred.\n   */\n  code: number;\n  /**\n   * A string providing a short description of the error.\n   */\n  message: string;\n  /**\n   * A primitive or structured value containing additional information about the error.\n   * This may be omitted.\n   */\n  data?: any;\n}\n</code></pre>"},{"location":"specification/#7-protocol-rpc-methods","title":"7. Protocol RPC Methods","text":"<p>All A2A RPC methods are invoked by the A2A Client by sending an HTTP POST request to the A2A Server's <code>url</code> (as specified in its <code>AgentCard</code>). The body of the HTTP POST request MUST be a <code>JSONRPCRequest</code> object, and the <code>Content-Type</code> header MUST be <code>application/json</code>.</p> <p>The A2A Server's HTTP response body MUST be a <code>JSONRPCResponse</code> object (or, for streaming methods, an SSE stream where each event's data is a <code>JSONRPCResponse</code>). The <code>Content-Type</code> for JSON-RPC responses is <code>application/json</code>. For SSE streams, it is <code>text/event-stream</code>.</p>"},{"location":"specification/#71-messagesend","title":"7.1. <code>message/send</code>","text":"<p>Sends a message to an agent to initiate a new interaction or to continue an existing one. This method is suitable for synchronous request/response interactions or when client-side polling (using <code>tasks/get</code>) is acceptable for monitoring longer-running tasks. A task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Sending a message to such a task will result in an error. For more information, refer to the Life of a Task guide.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>message/send</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>MessageSendParams</code></li> <li>Response: <code>Task</code> | <code>Message</code> (A message object or the current or final state of the task after processing the message).</li> </ul> <ul> <li>URL: <code>SendMessage</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message SendMessageRequest {\n  Message msg = 1;\n  SendMessageConfiguration configuration = 2;\n}\n</code></pre></li> <li>Response: <pre><code>message SendMessageResponse {\n  oneof payload {\n    Task task = 1;\n    Message msg = 2;\n  }\n}\n</code></pre></li> </ul> <ul> <li>URL: <code>/v1/message:send</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  message: Message,\n  configuration?: MessageSendConfiguration,\n  metadata?: { [key: string]: any }\n}\n</code></pre></li> <li>Response: <pre><code>// Returns one of a message or a task\n{\n  message?: Message,\n  task?: Task\n}\n</code></pre></li> </ul> <p>The <code>error</code> response for all transports in case of failure is a <code>JSONRPCError</code> or equivalent.</p>"},{"location":"specification/#711-messagesendparams-object","title":"7.1.1. <code>MessageSendParams</code> Object","text":"JSON-RPCgRPCJSON-RPCgRPC <pre><code>/**\n * Defines the parameters for a request to send a message to an agent. This can be used\n * to create a new task, continue an existing one, or restart a task.\n */\nexport interface MessageSendParams {\n  /** The message object being sent to the agent. */\n  message: Message;\n  /** Optional configuration for the send request. */\n  configuration?: MessageSendConfiguration;\n  /** Optional metadata for extensions. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre> <pre><code>message SendMessageRequest {\n  // The message to send to the agent.\n  Message request = 1\n      [(google.api.field_behavior) = REQUIRED, json_name = \"message\"];\n  // Configuration for the send request.\n  SendMessageConfiguration configuration = 2;\n  // Optional metadata for the request.\n  google.protobuf.Struct metadata = 3;\n}\n</code></pre> <pre><code>/**\n * Defines configuration options for a `message/send` or `message/stream` request.\n */\nexport interface MessageSendConfiguration {\n  /** A list of output MIME types the client is prepared to accept in the response. */\n  acceptedOutputModes?: string[];\n  /** The number of most recent messages from the task's history to retrieve in the response. */\n  historyLength?: number;\n  /** Configuration for the agent to send push notifications for updates after the initial response. */\n  pushNotificationConfig?: PushNotificationConfig;\n  /** If true, the client will wait for the task to complete. The server may reject this if the task is long-running. */\n  blocking?: boolean;\n}\n</code></pre> <pre><code>// Configuration of a send message request.\nmessage SendMessageConfiguration {\n  // The output modes that the agent is expected to respond with.\n  repeated string accepted_output_modes = 1;\n  // A configuration of a webhook that can be used to receive updates\n  PushNotificationConfig push_notification = 2;\n  // The maximum number of messages to include in the history. if 0, the\n  // history will be unlimited.\n  int32 history_length = 3;\n  // If true, the message will be blocking until the task is completed. If\n  // false, the message will be non-blocking and the task will be returned\n  // immediately. It is the caller's responsibility to check for any task\n  // updates.\n  bool blocking = 4;\n}\n</code></pre>"},{"location":"specification/#72-messagestream","title":"7.2. <code>message/stream</code>","text":"<p>Sends a message to an agent to initiate/continue a task AND subscribes the client to real-time updates for that task via Server-Sent Events (SSE). This method requires the server to have <code>AgentCard.capabilities.streaming: true</code>. Just like <code>message/send</code>, a task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Sending a message to such a task will result in an error. For more information, refer to the Life of a Task guide.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>message/stream</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>MessageSendParams</code> (same as <code>message/send</code>)</li> <li>Response: A stream of Server-Sent Events. Each SSE <code>data</code> field contains a <code>SendStreamingMessageResponse</code></li> </ul> <ul> <li>URL: <code>SendStreamingMessage</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message SendMessageRequest {\n  Message msg = 1;\n  SendMessageConfiguration configuration = 2;\n}\n</code></pre></li> <li>Response: <pre><code>message StreamResponse {\n  oneof payload {\n    Task task;\n    Message msg;\n    TaskStatusUpdateEvent status_update;\n    TaskArtifactUpdateEvent artifact_update;\n  }\n}\n</code></pre></li> </ul> <ul> <li>URL: <code>/v1/message:stream</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  message: Message,\n  configuration?: MessageSendConfiguration,\n  metadata?: { [key: string]: any }\n}\n</code></pre></li> <li>Response: <pre><code>{\n  message?: Message\n  task?: Task\n  statusUpdate?: TaskStatusUpdateEvent\n  artifactUpdate?: TaskArtifactUpdateEvent\n}\n</code></pre></li> </ul>"},{"location":"specification/#721-sendstreamingmessageresponse-object","title":"7.2.1. <code>SendStreamingMessageResponse</code> Object","text":"<p>This is the structure of the JSON object found in the <code>data</code> field of each Server-Sent Event sent by the server for a <code>message/stream</code> request or <code>tasks/resubscribe</code> request.</p> <pre><code>/**\n * Represents a JSON-RPC response for the `message/stream` method.\n */\nexport type SendStreamingMessageResponse =\n  | SendStreamingMessageSuccessResponse\n  | JSONRPCErrorResponse;\n</code></pre> JSON-RPCgRPC <pre><code>/**\n * Represents a successful JSON-RPC response for the `message/stream` method.\n * The server may send multiple response objects for a single request.\n */\nexport interface SendStreamingMessageSuccessResponse\n  extends JSONRPCSuccessResponse {\n  /** The result, which can be a Message, Task, or a streaming update event. */\n  result: Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;\n}\n</code></pre> <pre><code>// The stream response for a message. The stream should be one of the following\n// sequences:\n// If the response is a message, the stream should contain one, and only one,\n// message and then close\n// If the response is a task lifecycle, the first response should be a Task\n// object followed by zero or more TaskStatusUpdateEvents and\n// TaskArtifactUpdateEvents. The stream should complete when the Task\n// if in an interrupted or terminal state. A stream that ends before these\n// conditions are met are\nmessage StreamResponse {\n  oneof payload {\n    Task task = 1;\n    Message msg = 2 [json_name = \"message\"];\n    TaskStatusUpdateEvent status_update = 3;\n    TaskArtifactUpdateEvent artifact_update = 4;\n  }\n}\n</code></pre>"},{"location":"specification/#722-taskstatusupdateevent-object","title":"7.2.2. <code>TaskStatusUpdateEvent</code> Object","text":"<p>Carries information about a change in the task's status during streaming. This is one of the possible <code>result</code> types in a <code>SendStreamingMessageSuccessResponse</code>.</p> JSON-RPCgRPC <pre><code>/**\n * An event sent by the agent to notify the client of a change in a task's status.\n * This is typically used in streaming or subscription models.\n */\nexport interface TaskStatusUpdateEvent {\n  /**\n   * The ID of the task that was updated.\n   */\n  taskId: string;\n  /**\n   * The context ID associated with the task.\n   */\n  contextId: string;\n  /** The type of this event, used as a discriminator. Always 'status-update'. */\n  readonly kind: \"status-update\";\n  /** The new status of the task. */\n  status: TaskStatus;\n  /** If true, this is the final event in the stream for this interaction. */\n  final: boolean;\n  /** Optional metadata for extensions. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre> <pre><code>// TaskStatusUpdateEvent is a delta even on a task indicating that a task\n// has changed.\nmessage TaskStatusUpdateEvent {\n  // The id of the task that is changed\n  string task_id = 1;\n  // The id of the context that the task belongs to\n  string context_id = 2;\n  // The new status of the task.\n  TaskStatus status = 3;\n  // Whether this is the last status update expected for this task.\n  bool final = 4;\n  // Optional metadata to associate with the task update.\n  google.protobuf.Struct metadata = 5;\n}\n</code></pre>"},{"location":"specification/#723-taskartifactupdateevent-object","title":"7.2.3. <code>TaskArtifactUpdateEvent</code> Object","text":"<p>Carries a new or updated artifact (or a chunk of an artifact) generated by the task during streaming. This is one of the possible <code>result</code> types in a <code>SendTaskStreamingResponse</code>.</p> JSON-RPCgRPC <pre><code>/**\n * An event sent by the agent to notify the client that an artifact has been\n * generated or updated. This is typically used in streaming models.\n */\nexport interface TaskArtifactUpdateEvent {\n  /**\n   * The ID of the task this artifact belongs to.\n   */\n  taskId: string;\n  /**\n   * The context ID associated with the task.\n   */\n  contextId: string;\n  /** The type of this event, used as a discriminator. Always 'artifact-update'. */\n  readonly kind: \"artifact-update\";\n  /** The artifact that was generated or updated. */\n  artifact: Artifact;\n  /** If true, the content of this artifact should be appended to a previously sent artifact with the same ID. */\n  append?: boolean;\n  /** If true, this is the final chunk of the artifact. */\n  lastChunk?: boolean;\n  /** Optional metadata for extensions. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre> <pre><code>// TaskArtifactUpdateEvent represents a task delta where an artifact has\n// been generated.\nmessage TaskArtifactUpdateEvent {\n  // The id of the task for this artifact\n  string task_id = 1;\n  // The id of the context that this task belongs too\n  string context_id = 2;\n  // The artifact itself\n  Artifact artifact = 3;\n  //  Whether this should be appended to a prior one produced\n  bool append = 4;\n  // Whether this represents the last part of an artifact\n  bool last_chunk = 5;\n  // Optional metadata associated with the artifact update.\n  google.protobuf.Struct metadata = 6;\n}\n</code></pre>"},{"location":"specification/#73-tasksget","title":"7.3. <code>tasks/get</code>","text":"<p>Retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task. This is typically used for polling the status of a task initiated with <code>message/send</code>, or for fetching the final state of a task after being notified via a push notification or after an SSE stream has ended.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/get</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskQueryParams</code></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>GetTask</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message GetTaskRequest {\n  // name=tasks/{id}\n  string name;\n  int32 history_length;\n}\n</code></pre></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>v1/tasks/{id}?historyLength={historyLength}</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: None</li> <li>Response: <code>Task</code></li> </ul>"},{"location":"specification/#731-taskqueryparams-object","title":"7.3.1. <code>TaskQueryParams</code> Object","text":"JSON-RPCgRPC <pre><code>/**\n * Defines parameters for querying a task, with an option to limit history length.\n */\nexport interface TaskQueryParams extends TaskIdParams {\n  /** The number of most recent messages from the task's history to retrieve. */\n  historyLength?: number;\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"specification/#74-taskscancel","title":"7.4. <code>tasks/cancel</code>","text":"<p>Requests the cancellation of an ongoing task. The server will attempt to cancel the task, but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/cancel</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskIdParams</code></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>CancelTask</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message CancelTaskRequest{\n  // name=tasks/{id}\n  string name;\n}\n</code></pre></li> <li>Response: <code>Task</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}:cancel</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  name: string\n}\n</code></pre></li> <li>Response: <code>Task</code></li> </ul>"},{"location":"specification/#741-taskidparams-object-for-taskscancel-and-taskspushnotificationconfigget","title":"7.4.1. <code>TaskIdParams</code> Object (for <code>tasks/cancel</code> and <code>tasks/pushNotificationConfig/get</code>)","text":"<p>A simple object containing just the task ID and optional metadata.</p> JSON-RPCgRPC <pre><code>/**\n * Defines parameters containing a task ID, used for simple task operations.\n */\nexport interface TaskIdParams {\n  /**\n   * The unique identifier (e.g. UUID) of the task.\n   */\n  id: string;\n  /** Optional metadata associated with the request. */\n  metadata?: {\n    [key: string]: any;\n  };\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"specification/#75-taskspushnotificationconfigset","title":"7.5. <code>tasks/pushNotificationConfig/set</code>","text":"<p>Sets or updates the push notification configuration for a specified task. This allows the client to tell the server where and how to send asynchronous updates for the task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/pushNotificationConfig/set</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskPushNotificationConfig</code></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>CreateTaskPushNotification</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message SetTaskPushNotificationRequest {\n  TaskPushNotificationConfig config = 1;\n}\n</code></pre></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}/pushNotificationConfigs</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  config: TaskPushNotificationConfig\n}\n</code></pre></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul>"},{"location":"specification/#76-taskspushnotificationconfigget","title":"7.6. <code>tasks/pushNotificationConfig/get</code>","text":"<p>Retrieves the current push notification configuration for a specified task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/pushNotificationConfig/get</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>GetTaskPushNotificationConfigParams</code></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>GetTaskPushNotification</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message TaskSubscriptionRequest {\n  // name=tasks/{id}/pushNotification/{id}\n  string name;\n}\n</code></pre></li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{taskId}/pushNotificationConfigs/{configId}</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: None</li> <li>Response: <code>TaskPushNotificationConfig</code></li> </ul> <p>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>PushNotificationNotSupportedError</code>, <code>TaskNotFoundError</code>).</p>"},{"location":"specification/#761-gettaskpushnotificationconfigparams-object-taskspushnotificationconfigget","title":"7.6.1. <code>GetTaskPushNotificationConfigParams</code> Object (<code>tasks/pushNotificationConfig/get</code>)","text":"<p>A object for fetching the push notification configuration for a task.</p> JSON-RPCgRPC <pre><code>/**\n * Defines parameters for fetching a specific push notification configuration for a task.\n */\nexport interface GetTaskPushNotificationConfigParams extends TaskIdParams {\n  /**\n   * The ID of the push notification configuration to retrieve.\n   */\n  pushNotificationConfigId?: string;\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"specification/#77-taskspushnotificationconfiglist","title":"7.7. <code>tasks/pushNotificationConfig/list</code>","text":"<p>Retrieves the associated push notification configurations for a specified task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/pushNotificationConfig/list</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>ListTaskPushNotificationConfigParams</code></li> <li>Response: <code>TaskPushNotificationConfig[]</code></li> </ul> <ul> <li>URL: <code>ListTaskPushNotification</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message ListTaskPushNotificationRequest {\n  // parent=tasks/{id}\n  string parent = 1;\n}\n</code></pre></li> <li>Response: <code>repeated TaskPushNotificationConfig</code></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}/pushNotificationConfigs</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload:: None</li> <li>Response: <code>[TaskPushNotificationConfig]</code></li> </ul>"},{"location":"specification/#771-listtaskpushnotificationconfigparams-object-taskspushnotificationconfiglist","title":"7.7.1. <code>ListTaskPushNotificationConfigParams</code> Object (<code>tasks/pushNotificationConfig/list</code>)","text":"<p>A object for fetching the push notification configurations for a task.</p> JSON-RPCgRPC <pre><code>/**\n * Defines parameters for listing all push notification configurations associated with a task.\n */\nexport interface ListTaskPushNotificationConfigParams extends TaskIdParams {}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"specification/#78-taskspushnotificationconfigdelete","title":"7.8. <code>tasks/pushNotificationConfig/delete</code>","text":"<p>Deletes an associated push notification configuration for a task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> <ul> <li>Request <code>params</code> type: <code>DeleteTaskPushNotificationConfigParams</code></li> <li>Response <code>result</code> type (on success): [<code>null</code>]</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>PushNotificationNotSupportedError</code>, <code>TaskNotFoundError</code>).</li> </ul>"},{"location":"specification/#781-deletetaskpushnotificationconfigparams-object-taskspushnotificationconfigdelete","title":"7.8.1. <code>DeleteTaskPushNotificationConfigParams</code> Object (<code>tasks/pushNotificationConfig/delete</code>)","text":"<p>A object for deleting an associated push notification configuration for a task.</p> JSON-RPCgRPC <pre><code>/**\n * Defines parameters for deleting a specific push notification configuration for a task.\n */\nexport interface DeleteTaskPushNotificationConfigParams extends TaskIdParams {\n  /**\n   * The ID of the push notification configuration to delete.\n   */\n  pushNotificationConfigId: string;\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"specification/#79-tasksresubscribe","title":"7.9. <code>tasks/resubscribe</code>","text":"<p>Allows a client to reconnect to an SSE stream for an ongoing task after a previous connection (from <code>message/stream</code> or an earlier <code>tasks/resubscribe</code>) was interrupted. Requires the server to have <code>AgentCard.capabilities.streaming: true</code>.</p> <p>The purpose is to resume receiving subsequent updates. The server's behavior regarding events missed during the disconnection period (e.g., whether it attempts to backfill some missed events or only sends new ones from the point of resubscription) is implementation-dependent and not strictly defined by this specification.</p> JSON-RPCgRPCREST <ul> <li>URL: <code>tasks/resubscribe</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <code>TaskIdParams</code></li> <li>Response: A stream of Server-Sent Events. Each SSE <code>data</code> field contains a <code>SendStreamingMessageResponse</code></li> </ul> <ul> <li>URL: <code>TaskSubscription</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>message TaskSubscriptionRequest{\n  // name=tasks/{id}\n  string name;\n}\n</code></pre></li> <li>Response: <pre><code>message StreamResponse {\n  oneof payload {\n    Task task;\n    Message msg;\n    TaskStatusUpdateEvent status_update;\n    TaskArtifactUpdateEvent artifact_update;\n  }\n}\n</code></pre></li> </ul> <ul> <li>URL: <code>/v1/tasks/{id}:subscribe</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: <pre><code>{\n  name: string\n}\n</code></pre></li> <li>Response: <pre><code>{\n  message?: Message\n  task?: Task\n  statusUpdate?: TaskStatusUpdateEvent\n  artifactUpdate?: TaskArtifactUpdateEvent\n}\n</code></pre></li> </ul>"},{"location":"specification/#710-agentgetauthenticatedextendedcard","title":"7.10. <code>agent/getAuthenticatedExtendedCard</code>","text":"<p>Retrieves a potentially more detailed version of the Agent Card after the client has authenticated. This endpoint is available only if <code>AgentCard.supportsAuthenticatedExtendedCard</code> is <code>true</code>.</p> <ul> <li>Authentication: The client MUST authenticate the request using one of the schemes declared in the public <code>AgentCard.securitySchemes</code> and <code>AgentCard.security</code> fields.</li> <li>Response <code>result</code> type (on success): <code>AgentCard</code> (A complete Agent Card object, which may contain additional details or skills not present in the public card).</li> <li>Response <code>error</code> type (on failure): Standard HTTP error codes.<ul> <li><code>401 Unauthorized</code>: Authentication failed (missing or invalid credentials). The server SHOULD include a <code>WWW-Authenticate</code> header.</li> </ul> </li> </ul> JSON-RPCgRPCREST <ul> <li>URL: <code>agent/getAuthenticatedExtendedCard</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: None</li> <li>Response: <code>AgentCard</code></li> </ul> <ul> <li>URL: <code>GetAgentCard</code></li> <li>HTTP Method: <code>POST</code></li> <li>Payload: None</li> <li>Response: <code>AgentCard</code></li> </ul> <ul> <li>URL: <code>/v1/card</code></li> <li>HTTP Method: <code>GET</code></li> <li>Payload: None</li> <li>Response: <code>AgentCard</code></li> </ul> <p>Clients retrieving this authenticated card SHOULD replace their cached public Agent Card with the content received from this endpoint for the duration of their authenticated session or until the card's version changes.</p> <pre><code>/**\n * Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.\n */\nexport interface GetAuthenticatedExtendedCardSuccessResponse\n  extends JSONRPCSuccessResponse {\n  /** The result is an Agent Card object. */\n  result: AgentCard;\n}\n</code></pre>"},{"location":"specification/#8-error-handling","title":"8. Error Handling","text":"<p>A2A uses standard JSON-RPC 2.0 error codes and structure for reporting errors. Errors are returned in the <code>error</code> member of the <code>JSONRPCErrorResponse</code> object. See <code>JSONRPCError</code> Object definition.</p>"},{"location":"specification/#81-standard-json-rpc-errors","title":"8.1. Standard JSON-RPC Errors","text":"<p>These are standard codes defined by the JSON-RPC 2.0 specification.</p> Code JSON-RPC Spec Meaning Typical A2A <code>message</code> Description <code>-32700</code> Parse error Invalid JSON payload Server received JSON that was not well-formed. <code>-32600</code> Invalid Request Invalid JSON-RPC Request The JSON payload was valid JSON, but not a valid JSON-RPC Request object. <code>-32601</code> Method not found Method not found The requested A2A RPC <code>method</code> (e.g., <code>\"tasks/foo\"</code>) does not exist or is not supported. <code>-32602</code> Invalid params Invalid method parameters The <code>params</code> provided for the method are invalid (e.g., wrong type, missing required field). <code>-32603</code> Internal error Internal server error An unexpected error occurred on the server during processing. <code>-32000</code> to <code>-32099</code> Server error (Server-defined) Reserved for implementation-defined server-errors. A2A-specific errors use this range."},{"location":"specification/#82-a2a-specific-errors","title":"8.2. A2A-Specific Errors","text":"<p>These are custom error codes defined within the JSON-RPC server error range (<code>-32000</code> to <code>-32099</code>) to provide more specific feedback about A2A-related issues. Servers SHOULD use these codes where applicable.</p> Code Error Name (Conceptual) Typical <code>message</code> string Description <code>-32001</code> <code>TaskNotFoundError</code> Task not found The specified task <code>id</code> does not correspond to an existing or active task. It might be invalid, expired, or already completed and purged. <code>-32002</code> <code>TaskNotCancelableError</code> Task cannot be canceled An attempt was made to cancel a task that is not in a cancelable state (e.g., it has already reached a terminal state like <code>completed</code>, <code>failed</code>, or <code>canceled</code>). <code>-32003</code> <code>PushNotificationNotSupportedError</code> Push Notification is not supported Client attempted to use push notification features (e.g., <code>tasks/pushNotificationConfig/set</code>) but the server agent does not support them (i.e., <code>AgentCard.capabilities.pushNotifications</code> is <code>false</code>). <code>-32004</code> <code>UnsupportedOperationError</code> This operation is not supported The requested operation or a specific aspect of it (perhaps implied by parameters) is not supported by this server agent implementation. Broader than just method not found. <code>-32005</code> <code>ContentTypeNotSupportedError</code> Incompatible content types A Media Type provided in the request's <code>message.parts</code> (or implied for an artifact) is not supported by the agent or the specific skill being invoked. <code>-32006</code> <code>InvalidAgentResponseError</code> Invalid agent response type Agent generated an invalid response for the requested method <code>-32007</code> <code>AuthenticatedExtendedCardNotConfiguredError</code> Authenticated Extended Card not configured The agent does not have an Authenticated Extended Card configured. <p>Servers MAY define additional error codes within the <code>-32000</code> to <code>-32099</code> range for more specific scenarios not covered above, but they SHOULD document these clearly. The <code>data</code> field of the <code>JSONRPCError</code> object can be used to provide more structured details for any error.</p>"},{"location":"specification/#9-common-workflows-examples","title":"9. Common Workflows &amp; Examples","text":"<p>This section provides illustrative JSON examples of common A2A interactions. Timestamps, context IDs, and request/response IDs are for demonstration purposes. For brevity, some optional fields might be omitted if not central to the example.</p>"},{"location":"specification/#91-fetching-authenticated-extended-agent-card","title":"9.1. Fetching Authenticated Extended Agent Card","text":"<p>Scenario: A client discovers a public Agent Card indicating support for an authenticated extended card and wants to retrieve the full details.</p> <ol> <li>Client fetches the public Agent Card:</li> </ol> <pre><code>GET https://example.com/.well-known/agent-card.json\n</code></pre> <p>Server responds with the public Agent Card (like the example in Section 5.6), including <code>supportsAuthenticatedExtendedCard: true</code> (at the root level) and <code>securitySchemes</code>.</p> <ol> <li> <p>Client identifies required authentication from the public card.</p> </li> <li> <p>Client obtains necessary credentials out-of-band (e.g., performs OAuth 2.0 flow with Google, resulting in an access token).</p> </li> <li> <p>Client fetches the authenticated extended Agent Card using <code>agent/getAuthenticatedExtendedCard</code> request:</p> </li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"agent/getAuthenticatedExtendedCard\"\n}\n</code></pre> <ol> <li> <p>Server authenticates and authorizes the request.</p> </li> <li> <p>Server responds with the full Agent Card as the JSON-RPC result:</p> </li> </ol>"},{"location":"specification/#92-basic-execution-synchronous-polling-style","title":"9.2. Basic Execution (Synchronous / Polling Style)","text":"<p>Scenario: Client asks a simple question, and the agent responds quickly with a task</p> <ol> <li>Client sends a message using <code>message/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"tell me a joke\"\n        }\n      ],\n      \"messageId\": \"9229e770-767c-417b-a0b0-f0741243c589\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server processes the request, creates a task and responds (task completes quickly)</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"id\": \"363422be-b0f9-4692-a24d-278670e7c7f1\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"completed\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"joke\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Why did the chicken cross the road? To get to the other side!\"\n          }\n        ]\n      }\n    ],\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"tell me a joke\"\n          }\n        ],\n        \"messageId\": \"9229e770-767c-417b-a0b0-f0741243c589\",\n        \"taskId\": \"363422be-b0f9-4692-a24d-278670e7c7f1\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      }\n    ],\n    \"kind\": \"task\",\n    \"metadata\": {}\n  }\n}\n</code></pre> <p>If the task were longer-running, the server might initially respond with <code>status.state: \"working\"</code>. The client would then periodically call <code>tasks/get</code> with params: <code>{\"id\": \"363422be-b0f9-4692-a24d-278670e7c7f1\"}</code> until the task reaches a terminal state.</p> <p>Scenario: Client asks a simple question, and the agent responds quickly without a task</p> <ol> <li>Client sends a message using <code>message/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"tell me a joke\"\n        }\n      ],\n      \"messageId\": \"9229e770-767c-417b-a0b0-f0741243c589\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server processes the request, responds quickly without a task</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"messageId\": \"363422be-b0f9-4692-a24d-278670e7c7f1\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"parts\": [\n      {\n        \"kind\": \"text\",\n        \"text\": \"Why did the chicken cross the road? To get to the other side!\"\n      }\n    ],\n    \"kind\": \"message\",\n    \"metadata\": {}\n  }\n}\n</code></pre>"},{"location":"specification/#93-streaming-task-execution-sse","title":"9.3. Streaming Task Execution (SSE)","text":"<p>Scenario: Client asks the agent to write a long paper describing an attached picture.</p> <ol> <li>Client sends a message and subscribes using <code>message/stream</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"message/stream\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"write a long paper describing the attached pictures\"\n        },\n        {\n          \"kind\": \"file\",\n          \"file\": {\n            \"mimeType\": \"image/png\",\n            \"data\": \"&lt;base64-encoded-content&gt;\"\n          }\n        }\n      ],\n      \"messageId\": \"bbb7dee1-cf5c-4683-8a6f-4114529da5eb\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server responds with HTTP 200 OK, <code>Content-Type: text/event-stream</code>, and starts sending SSE events:</li> </ol> <p>Event 1: Task status update - working</p> <pre><code>data: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"id\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"status\": {\n      \"state\": \"submitted\",\n      \"timestamp\":\"2025-04-02T16:59:25.331844\"\n    },\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"write a long paper describing the attached pictures\"\n          },\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"mimeType\": \"image/png\",\n              \"data\": \"&lt;base64-encoded-content&gt;\"\n            }\n          }\n        ],\n        \"messageId\": \"bbb7dee1-cf5c-4683-8a6f-4114529da5eb\",\n        \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n        \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\"\n      }\n    ],\n    \"kind\": \"task\",\n    \"metadata\": {}\n  }\n}\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"artifact\": {\n      \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n      \"parts\": [\n        {\"kind\":\"text\", \"text\": \"&lt;section 1...&gt;\"}\n      ]\n    },\n    \"append\": false,\n    \"lastChunk\": false,\n    \"kind\":\"artifact-update\"\n  }\n}\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"artifact\": {\n      \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n      \"parts\": [\n        {\"kind\":\"text\", \"text\": \"&lt;section 2...&gt;\"}\n      ],\n    },\n    \"append\": true,\n    \"lastChunk\": false,\n    \"kind\":\"artifact-update\"\n  }\n}\n\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"artifact\": {\n      \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n      \"parts\": [\n        {\"kind\":\"text\", \"text\": \"&lt;section 3...&gt;\"}\n      ]\n    },\n    \"append\": true,\n    \"lastChunk\": true,\n    \"kind\":\"artifact-update\"\n  }\n}\n\ndata: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"taskId\": \"225d6247-06ba-4cda-a08b-33ae35c8dcfa\",\n    \"contextId\": \"05217e44-7e9f-473e-ab4f-2c2dde50a2b1\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"timestamp\":\"2025-04-02T16:59:35.331844\"\n    },\n    \"final\": true,\n    \"kind\":\"status-update\"\n  }\n}\n</code></pre> <p>(Server closes the SSE connection after the <code>final:true</code> event).</p>"},{"location":"specification/#94-multi-turn-interaction-input-required","title":"9.4. Multi-Turn Interaction (Input Required)","text":"<p>Scenario: Client wants to book a flight, and the agent needs more information.</p> <ol> <li>Client sends a message using <code>message/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-003\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{ \"kind\": \"text\", \"text\": \"I'd like to book a flight.\" }]\n    },\n    \"messageId\": \"c53ba666-3f97-433c-a87b-6084276babe2\"\n  }\n}\n</code></pre> <ol> <li>Server responds, task state is <code>input-required</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-003\",\n  \"result\": {\n    \"id\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"input-required\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?\"\n          }\n        ],\n        \"messageId\": \"c2e1b2dd-f200-4b04-bc22-1b0c65a1aad2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      },\n      \"timestamp\": \"2024-03-15T10:10:00Z\"\n    },\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"I'd like to book a flight.\"\n          }\n        ],\n        \"messageId\": \"c53ba666-3f97-433c-a87b-6084276babe2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre> <ol> <li>Client <code>message/send</code> (providing the requested input, using the same task ID):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-004\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th.\"\n        }\n      ],\n      \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n      \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n      \"messageId\": \"0db1d6c4-3976-40ed-b9b8-0043ea7a03d3\"\n    },\n    \"configuration\": {\n      \"blocking\": true\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the new input and responds (e.g., task completed or more input needed):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-004\",\n  \"result\": {\n    \"id\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Okay, I've found a flight for you. Confirmation XYZ123. Details are in the artifact.\"\n          }\n        ]\n      }\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"FlightItinerary.json\",\n        \"parts\": [\n          {\n            \"kind\": \"data\",\n            \"data\": {\n              \"confirmationId\": \"XYZ123\",\n              \"from\": \"JFK\",\n              \"to\": \"LHR\",\n              \"departure\": \"2024-10-10T18:00:00Z\",\n              \"arrival\": \"2024-10-11T06:00:00Z\",\n              \"returnDeparture\": \"...\"\n            }\n          }\n        ]\n      }\n    ],\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"I'd like to book a flight.\"\n          }\n        ],\n        \"messageId\": \"c53ba666-3f97-433c-a87b-6084276babe2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      },\n      {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?\"\n          }\n        ],\n        \"messageId\": \"c2e1b2dd-f200-4b04-bc22-1b0c65a1aad2\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\"\n      },\n      {\n        \"role\": \"user\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th.\"\n          }\n        ],\n        \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n        \"taskId\": \"3f36680c-7f37-4a5f-945e-d78981fafd36\",\n        \"messageId\": \"0db1d6c4-3976-40ed-b9b8-0043ea7a03d3\"\n      }\n    ],\n    \"kind\": \"task\",\n    \"metadata\": {}\n  }\n}\n</code></pre>"},{"location":"specification/#95-push-notification-setup-and-usage","title":"9.5. Push Notification Setup and Usage","text":"<p>Scenario: Client requests a long-running report generation and wants to be notified via webhook when it's done.</p> <ol> <li>Client <code>message/send</code> with <code>pushNotification</code> config:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-005\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Generate the Q1 sales report. This usually takes a while. Notify me when it's ready.\"\n        }\n      ],\n      \"messageId\": \"6dbc13b5-bd57-4c2b-b503-24e381b6c8d6\"\n    },\n    \"configuration\": {\n      \"pushNotificationConfig\": {\n        \"url\": \"https://client.example.com/webhook/a2a-notifications\",\n        \"token\": \"secure-client-token-for-task-aaa\",\n        \"authentication\": {\n          \"schemes\": [\"Bearer\"]\n          // Assuming server knows how to get a Bearer token for this webhook audience,\n          // or this implies the webhook is public/uses the 'token' for auth.\n          // 'credentials' could provide more specifics if needed by the server.\n        }\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Server acknowledges the task (e.g., status <code>submitted</code> or <code>working</code>):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-005\",\n  \"result\": {\n    \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": { \"state\": \"submitted\", \"timestamp\": \"2024-03-15T11:00:00Z\" }\n    // ... other fields ...\n  }\n}\n</code></pre> <ol> <li> <p>(Later) A2A Server completes the task and POSTs a notification to <code>https://client.example.com/webhook/a2a-notifications</code>:</p> </li> <li> <p>HTTP Headers might include:</p> <ul> <li><code>Authorization: Bearer &lt;server_jwt_for_webhook_audience&gt;</code> (if server authenticates to webhook)</li> <li><code>Content-Type: application/json</code></li> <li><code>X-A2A-Notification-Token: secure-client-token-for-task-aaa</code></li> </ul> </li> <li>HTTP Body (Task object is sent as JSON payload):</li> </ol> <pre><code>{\n  \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n  \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n  \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T18:30:00Z\" },\n  \"kind\": \"task\"\n  // ... other fields ...\n}\n</code></pre> <ol> <li> <p>Client's Webhook Service:</p> </li> <li> <p>Receives the POST.</p> </li> <li>Validates the <code>Authorization</code> header (if applicable).</li> <li>Validates the <code>X-A2A-Notification-Token</code>.</li> <li>Internally processes the notification (e.g., updates application state, notifies end user).</li> </ol>"},{"location":"specification/#96-file-exchange-upload-and-download","title":"9.6. File Exchange (Upload and Download)","text":"<p>Scenario: Client sends an image for analysis, and the agent returns a modified image.</p> <ol> <li>Client <code>message/send</code> with a <code>FilePart</code> (uploading image bytes):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-007\",\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Analyze this image and highlight any faces.\"\n        },\n        {\n          \"kind\": \"file\",\n          \"file\": {\n            \"name\": \"input_image.png\",\n            \"mimeType\": \"image/png\",\n            \"bytes\": \"iVBORw0KGgoAAAANSUhEUgAAAAUA...\" // Base64 encoded image data\n          }\n        }\n      ],\n      \"messageId\": \"6dbc13b5-bd57-4c2b-b503-24e381b6c8d6\"\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the image and responds with a <code>FilePart</code> in an artifact (e.g., providing a URI to the modified image):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-007\",\n  \"result\": {\n    \"id\": \"43667960-d455-4453-b0cf-1bae4955270d\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T12:05:00Z\" },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"9b6934dd-37e3-4eb1-8766-962efaab63a1\",\n        \"name\": \"processed_image_with_faces.png\",\n        \"parts\": [\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"name\": \"output.png\",\n              \"mimeType\": \"image/png\",\n              // Server might provide a URI to a temporary storage location\n              \"uri\": \"https://storage.example.com/processed/task-bbb/output.png?token=xyz\"\n              // Or, alternatively, it could return bytes directly:\n              // \"bytes\": \"ASEDGhw0KGgoAAAANSUhEUgAA...\"\n            }\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre>"},{"location":"specification/#97-structured-data-exchange-requesting-and-providing-json","title":"9.7. Structured Data Exchange (Requesting and Providing JSON)","text":"<p>Scenario: Client asks for a list of open support tickets in a specific JSON format.</p> <ol> <li>Client <code>message/send</code>, <code>Part.metadata</code> hints at desired output schema/Media Type: (Note: A2A doesn't formally standardize schema negotiation in v0.2.0, but <code>metadata</code> can be used for such hints by convention between client/server).</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 9,\n  \"method\": \"message/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Show me a list of my open IT tickets\",\n          \"metadata\": {\n            \"mimeType\": \"application/json\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"ticketNumber\": { \"type\": \"string\" },\n                  \"description\": { \"type\": \"string\" }\n                }\n              }\n            }\n          }\n        }\n      ],\n      \"messageId\": \"85b26db5-ffbb-4278-a5da-a7b09dea1b47\"\n    },\n    \"metadata\": {}\n  }\n}\n</code></pre> <ol> <li>Server responds with structured JSON data:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 9,\n  \"result\": {\n    \"id\": \"d8c6243f-5f7a-4f6f-821d-957ce51e856c\",\n    \"contextId\": \"c295ea44-7543-4f78-b524-7a38915ad6e4\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"timestamp\": \"2025-04-17T17:47:09.680794\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"c5e0382f-b57f-4da7-87d8-b85171fad17c\",\n        \"parts\": [\n          {\n            \"kind\": \"text\",\n            \"text\": \"[{\\\"ticketNumber\\\":\\\"REQ12312\\\",\\\"description\\\":\\\"request for VPN access\\\"},{\\\"ticketNumber\\\":\\\"REQ23422\\\",\\\"description\\\":\\\"Add to DL - team-gcp-onboarding\\\"}]\"\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre> <p>These examples illustrate the flexibility of A2A in handling various interaction patterns and data types. Implementers should refer to the detailed object definitions for all fields and constraints.</p>"},{"location":"specification/#10-appendices","title":"10. Appendices","text":""},{"location":"specification/#101-relationship-to-mcp-model-context-protocol","title":"10.1. Relationship to MCP (Model Context Protocol)","text":"<p>A2A and MCP are complementary protocols designed for different aspects of agentic systems:</p> <ul> <li>Model Context Protocol (MCP): Focuses on standardizing how AI models and agents connect to and interact with tools, APIs, data sources, and other external resources. It defines structured ways to describe tool capabilities (like function calling in LLMs), pass inputs, and receive structured outputs. Think of MCP as the \"how-to\" for an agent to use a specific capability or access a resource.</li> <li>Agent2Agent Protocol (A2A): Focuses on standardizing how independent, often opaque, AI agents communicate and collaborate with each other as peers. A2A provides an application-level protocol for agents to discover each other, negotiate interaction modalities, manage shared tasks, and exchange conversational context or complex results. It's about how agents partner or delegate work.</li> </ul> <p>How they work together: An A2A Client agent might request an A2A Server agent to perform a complex task. The Server agent, in turn, might use MCP to interact with several underlying tools, APIs, or data sources to gather information or perform actions necessary to fulfill the A2A task.</p> <p>For a more detailed comparison, see the A2A and MCP guide.</p>"},{"location":"specification/#102-security-considerations-summary","title":"10.2. Security Considerations Summary","text":"<p>Security is a paramount concern in A2A. Key considerations include:</p> <ul> <li>Transport Security: Always use HTTPS with strong TLS configurations in production environments.</li> <li>Authentication:<ul> <li>Handled via standard HTTP mechanisms (e.g., <code>Authorization</code> header with Bearer tokens, API keys).</li> <li>Requirements are declared in the <code>AgentCard</code>.</li> <li>Credentials MUST be obtained out-of-band by the client.</li> <li>A2A Servers MUST authenticate every request.</li> </ul> </li> <li>Authorization:<ul> <li>A server-side responsibility based on the authenticated identity.</li> <li>Implement the principle of least privilege.</li> <li>Can be granular, based on skills, actions, or data.</li> </ul> </li> <li>Push Notification Security:<ul> <li>Webhook URL validation (by the A2A Server sending notifications) is crucial to prevent SSRF.</li> <li>Authentication of the A2A Server to the client's webhook is essential.</li> <li>Authentication of the notification by the client's webhook receiver (verifying it came from the legitimate A2A Server and is relevant) is critical.</li> <li>See the Streaming &amp; Asynchronous Operations guide for detailed push notification security.</li> </ul> </li> <li>Input Validation: Servers MUST rigorously validate all RPC parameters and the content/structure of data in <code>Message</code> and <code>Artifact</code> parts to prevent injection attacks or processing errors.</li> <li>Resource Management: Implement rate limiting, concurrency controls, and resource limits to protect agents from abuse or overload.</li> <li>Data Privacy: Adhere to all applicable privacy regulations for data exchanged in <code>Message</code> and <code>Artifact</code> parts. Minimize sensitive data transfer.</li> </ul> <p>For a comprehensive discussion, refer to the Enterprise-Ready Features guide.</p>"},{"location":"specification/#11-a2a-compliance-requirements","title":"11. A2A Compliance Requirements","text":"<p>This section defines the normative requirements for A2A-compliant implementations.</p>"},{"location":"specification/#111-agent-compliance","title":"11.1. Agent Compliance","text":"<p>For an agent to be considered A2A-compliant, it MUST:</p>"},{"location":"specification/#1111-transport-support-requirements","title":"11.1.1. Transport Support Requirements","text":"<ul> <li>Support at least one transport: Agents MUST implement at least one transport protocols as defined in Section 3.2.</li> <li>Expose Agent Card: MUST provide a valid <code>AgentCard</code> document as defined in Section 5.</li> <li>Declare transport capabilities: MUST accurately declare all supported transports in the <code>AgentCard</code> using <code>preferredTransport</code> and <code>additionalInterfaces</code> fields following the requirements in Section 5.6.</li> </ul>"},{"location":"specification/#1112-core-method-implementation","title":"11.1.2. Core Method Implementation","text":"<p>MUST implement all of the following core methods via at least one supported transport:</p> <ul> <li><code>message/send</code> - Send messages and initiate tasks</li> <li><code>tasks/get</code> - Retrieve task status and results</li> <li><code>tasks/cancel</code> - Request task cancellation</li> </ul>"},{"location":"specification/#1113-optional-method-implementation","title":"11.1.3. Optional Method Implementation","text":"<p>MAY implement the following optional methods:</p> <ul> <li><code>message/stream</code> - Streaming message interaction (requires <code>capabilities.streaming: true</code>)</li> <li><code>tasks/resubscribe</code> - Resume streaming for existing tasks (requires <code>capabilities.streaming: true</code>)</li> <li><code>tasks/pushNotificationConfig/set</code> - Configure push notifications (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>tasks/pushNotificationConfig/get</code> - Retrieve push notification config (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>tasks/pushNotificationConfig/list</code> - List push notification configs (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>tasks/pushNotificationConfig/delete</code> - Delete push notification config (requires <code>capabilities.pushNotifications: true</code>)</li> <li><code>agent/authenticatedExtendedCard</code> - Retrieve authenticated agent card (requires <code>supportsAuthenticatedExtendedCard: true</code>)</li> </ul>"},{"location":"specification/#1114-multi-transport-compliance","title":"11.1.4. Multi-Transport Compliance","text":"<p>If an agent supports additional transports (gRPC, HTTP+JSON), it MUST:</p> <ul> <li>Functional equivalence: Provide identical functionality across all supported transports.</li> <li>Consistent behavior: Return semantically equivalent results for the same operations.</li> <li>Transport-specific requirements: Conform to all requirements defined in Section 3.2 for each supported transport.</li> <li>Method mapping compliance: Use the standard method mappings defined in Section 3.5 for all supported transports.</li> </ul>"},{"location":"specification/#1115-data-format-compliance","title":"11.1.5. Data Format Compliance","text":"<ul> <li>JSON-RPC structure: MUST use valid JSON-RPC 2.0 request/response objects as defined in Section 6.11.</li> <li>A2A data objects: MUST use the data structures defined in Section 6 for all protocol entities.</li> <li>Error handling: MUST use the error codes defined in Section 8.</li> </ul>"},{"location":"specification/#112-client-compliance","title":"11.2. Client Compliance","text":"<p>For a client to be considered A2A-compliant, it MUST:</p>"},{"location":"specification/#1121-transport-support","title":"11.2.1. Transport Support","text":"<ul> <li>Multi-transport capability: MUST be able to communicate with agents using at least one transport protocols.</li> <li>Agent Card processing: MUST be able to parse and interpret <code>AgentCard</code> documents.</li> <li>Transport selection: MUST be able to select an appropriate transport from the agent's declared capabilities following the rules defined in Section 5.6.3.</li> </ul>"},{"location":"specification/#1122-protocol-implementation","title":"11.2.2. Protocol Implementation","text":"<ul> <li>Core method usage: MUST properly construct requests for at least <code>message/send</code> and <code>tasks/get</code> methods.</li> <li>Error handling: MUST properly handle all A2A error codes defined in Section 8.2.</li> <li>Authentication: MUST support at least one authentication method when interacting with agents that require authentication.</li> </ul>"},{"location":"specification/#1123-optional-client-features","title":"11.2.3. Optional Client Features","text":"<p>Clients MAY implement:</p> <ul> <li>Multi-transport support: Support for gRPC and/or HTTP+JSON transports.</li> <li>Streaming support: Handle streaming methods and Server-Sent Events.</li> <li>Push notification handling: Serve as webhook endpoints for push notifications.</li> <li>Extended Agent Cards: Retrieve and use authenticated extended agent cards.</li> </ul>"},{"location":"specification/#113-compliance-testing","title":"11.3. Compliance Testing","text":"<p>Implementations SHOULD validate compliance through:</p> <ul> <li>Transport interoperability: Test communication with agents using different transport implementations.</li> <li>Method mapping verification: Verify that all supported transports use the correct method names and URL patterns as defined in Section 3.5.</li> <li>Error handling: Verify proper handling of all defined error conditions.</li> <li>Data format validation: Ensure JSON schemas match the TypeScript type definitions in <code>types/src/types.ts</code>.</li> <li>Multi-transport consistency: For multi-transport agents, verify functional equivalence across all supported transports.</li> </ul>"},{"location":"topics/a2a-and-mcp/","title":"A2A and MCP: Detailed Comparison","text":"<p>In AI agent development, two key protocol types emerge to facilitate interoperability. One connects agents to tools and resources. The other enables agent-to-agent collaboration. The Agent2Agent (A2A) Protocol and the Model Context Protocol (MCP) address these distinct but highly complementary needs.</p> <ul> <li>Model Context Protocol (MCP): This protocol focuses on how an agent interacts with individual tools and resources, enabling an agent to utilize a specific tool, such as a database or an API.</li> <li>Agent2Agent (A2A) Protocol: This protocol focuses on how different agents collaborate with each other, enabling agents to work together to achieve a common goal.</li> </ul> <p>Both protocols are crucial for building complex AI systems, and they address distinct but highly complementary needs.</p>"},{"location":"topics/a2a-and-mcp/#why-different-protocols","title":"Why Different Protocols?","text":"<p>The distinction between A2A and MCP arises from the nature of what an agent interacts with.</p> <ul> <li>Tools and Resources (MCP Domain):<ul> <li>Characteristics: These are typically primitives with well-defined,     structured inputs and outputs. They perform specific, often stateless,     functions. Examples include a calculator, a database query API, or a     weather lookup service.</li> <li>Purpose: Agents use tools to gather information and perform discrete     functions.</li> </ul> </li> <li>Agents (A2A domain):<ul> <li>Characteristics: These are more autonomous systems. They reason,     plan, use multiple tools, maintain state over longer interactions, and     engage in complex, often multi-turn dialogues to achieve novel or     evolving tasks.</li> <li>Purpose: Agents collaborate with other agents to tackle broader, more     complex goals.</li> </ul> </li> </ul>"},{"location":"topics/a2a-and-mcp/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Standardizes how AI models and agents connect to and interact with tools,         APIs, data sources, and other external resources.</li> <li>Defines a structured way to describe tool capabilities, similar to         function calling in Large Language Models.</li> <li>Passes inputs to tools and receives structured outputs.</li> <li>Use cases include enabling an LLM to call an external API, allowing an         agent to query a database, or connecting an agent to a set of predefined         functions.</li> </ul>"},{"location":"topics/a2a-and-mcp/#agent2agent-protocol-a2a","title":"Agent2Agent Protocol (A2A)","text":"<ul> <li>Standardizes how independent, often opaque, AI agents communicate and         collaborate with each other as peers.</li> <li>Provides an application-level protocol for agents to discover each other,         negotiate interaction modalities, manage shared Tasks, and exchange         conversational context and complex Artifacts.</li> <li>Use cases include a customer service agent delegating an inquiry to a         billing agent, or a travel agent coordinating with flight, hotel, and         activity agents.</li> </ul>"},{"location":"topics/a2a-and-mcp/#a2a-mcp-complementary-protocols-for-agentic-systems","title":"A2A \u2764\ufe0f MCP: Complementary Protocols for Agentic Systems","text":"<p>An agentic application might primarily use A2A to communicate with other agents. Each individual agent internally uses MCP to interact with its specific tools and resources.</p> <p></p> <p>An agentic application might use A2A to communicate with other agents, while each agent internally uses MCP to interact with its specific tools and resources.</p>"},{"location":"topics/a2a-and-mcp/#example-scenario-the-auto-repair-shop","title":"Example Scenario: The Auto Repair Shop","text":"<p>Consider an auto repair shop staffed by autonomous AI agent \"mechanics\". These mechanics use special-purpose tools, such as vehicle diagnostic scanners, repair manuals, and platform lifts, to diagnose and repair problems. The repair process can involve extensive conversations, research, and interaction with part suppliers.</p> <ul> <li> <p>Customer Interaction (User-to-Agent using A2A): A customer (or their     primary assistant agent) uses A2A to communicate with the \"Shop Manager\"     agent.</p> <p>For example, the customer might say, \"My car is making a rattling noise\". - Multi-turn Diagnostic Conversation (Agent-to-Agent using A2A): The Shop Manager agent uses A2A for a multi-turn diagnostic conversation.</p> <p>For example, the Manager might ask, \"Can you send a video of the noise?\" or \"I see some fluid leaking. How long has this been happening?\". - Internal Tool Usage (Agent-to-Tool using MCP): The Mechanic agent, assigned the task by the Shop Manager, needs to diagnose the issue. The Mechanic agent uses MCP to interact with its specialized tools.</p> <p>For example: - MCP call to a \"Vehicle Diagnostic Scanner\" tool:     <code>scan_vehicle_for_error_codes(vehicle_id='XYZ123')</code> - MCP call to a \"Repair Manual Database\" tool:     <code>get_repair_procedure(error_code='P0300', vehicle_make='Toyota',     vehicle_model='Camry')</code> - MCP call to a \"Platform Lift\" tool: <code>raise_platform(height_meters=2)</code> - Supplier Interaction (Agent-to-Agent using A2A): The Mechanic agent determines that a specific part is needed. The Mechanic agent uses A2A to communicate with a \"Parts Supplier\" agent to order a part. For example, the Mechanic agent might ask, \"Do you have part #12345 in stock for a Toyota Camry 2018?\" - Order processing (Agent-to-Agent using A2A): The Parts Supplier agent, which is also an A2A-compliant system, responds, potentially leading to an order.</p> </li> </ul> <p>In this example:</p> <ul> <li>A2A facilitates the higher-level, conversational, and task-oriented     interactions between the customer and the shop, and between the shop's     agents and external supplier agents.</li> <li>MCP enables the mechanic agent to use its specific, structured tools to     perform its diagnostic and repair functions.</li> </ul> <p>An A2A server could expose some of its skills as MCP-compatible resources. However, A2A's primary strength lies in its support for more flexible, stateful, and collaborative interactions. These interactions go beyond a typical tool invocation. A2A focuses on agents partnering on tasks, whereas MCP focuses on agents using capabilities.</p>"},{"location":"topics/a2a-and-mcp/#representing-a2a-agents-as-mcp-resources","title":"Representing A2A Agents as MCP Resources","text":"<p>An A2A Server (a remote agent) could expose some of its skills as MCP-compatible resources, especially if those skills are well-defined and can be invoked in a more tool-like, stateless manner. In such a case, another agent might \"discover\" this A2A agent's specific skill through an MCP-style tool description (perhaps derived from its Agent Card).</p> <p>However, the primary strength of A2A lies in its support for more flexible, stateful, and collaborative interactions that go beyond typical tool invocation. A2A is about agents partnering on tasks, while MCP is more about agents using capabilities.</p> <p>By leveraging both A2A for inter-agent collaboration and MCP for tool integration, developers can build more powerful, flexible, and interoperable AI systems.</p>"},{"location":"topics/agent-discovery/","title":"Agent Discovery in A2A","text":"<p>To collaborate using the Agent2Agent (A2A) protocol, AI agents need to first find each other and understand their capabilities. A2A standardizes agent self-descriptions through the Agent Card. However, discovery methods for these Agent Cards vary by environment and requirements. The Agent Card defines what an agent offers. Various strategies exist for a client agent to discover these cards. The choice of strategy depends on the deployment environment and security requirements.</p>"},{"location":"topics/agent-discovery/#the-role-of-the-agent-card","title":"The Role of the Agent Card","text":"<p>The Agent Card is a JSON document that serves as a digital \"business card\" for an A2A Server (the remote agent). It is crucial for agent discovery and interaction. The key information included in an Agent Card is as follows:</p> <ul> <li>Identity: Includes <code>name</code>, <code>description</code>, and <code>provider</code> information.</li> <li>Service Endpoint: Specifies the <code>url</code> for the A2A service.</li> <li>A2A Capabilities: Lists supported features such as <code>streaming</code> or <code>pushNotifications</code>.</li> <li>Authentication: Details the required <code>schemes</code> (e.g., \"Bearer\", \"OAuth2\").</li> <li>Skills: Describes the agent's tasks using <code>AgentSkill</code> objects, including <code>id</code>, <code>name</code>, <code>description</code>, <code>inputModes</code>, <code>outputModes</code>, and <code>examples</code>.</li> </ul> <p>Client agents use the Agent Card to determine an agent's suitability, structure requests, and ensure secure communication.</p>"},{"location":"topics/agent-discovery/#discovery-strategies","title":"Discovery Strategies","text":"<p>The following sections detail common strategies used by client agents to discover remote Agent Cards:</p>"},{"location":"topics/agent-discovery/#1-well-known-uri","title":"1. Well-Known URI","text":"<p>This approach is recommended for public agents or agents intended for broad discovery within a specific domain.</p> <ul> <li> <p>Mechanism: A2A Servers make their Agent Card discoverable by hosting it at a standardized, <code>well-known</code> URI on their domain. The standard path is <code>https://{agent-server-domain}/.well-known/agent-card.json</code>, following the principles of RFC 8615.</p> </li> <li> <p>Process:</p> <ol> <li>A client agent knows or programmatically discovers the domain of a potential A2A Server (e.g., <code>smart-thermostat.example.com</code>).</li> <li>The client performs an HTTP GET request to <code>https://smart-thermostat.example.com/.well-known/agent-card.json</code>.</li> <li>If the Agent Card exists and is accessible, the server returns it as a JSON response.</li> </ol> </li> <li> <p>Advantages:</p> <ul> <li>Ease of implementation</li> <li>Adheres to standards</li> <li>Facilitates automated discovery</li> </ul> </li> <li> <p>Considerations:</p> <ul> <li>Best suited for open or domain-controlled discovery scenarios.</li> <li>Authentication is necessary at the endpoint serving the Agent Card if it contains sensitive details.</li> </ul> </li> </ul>"},{"location":"topics/agent-discovery/#2-curated-registries-catalog-based-discovery","title":"2. Curated Registries (Catalog-Based Discovery)","text":"<p>This approach is employed in enterprise environments or public marketplaces, where Agent Cards are often managed by a central registry. The curated registry acts as a central repository, allowing clients to query and discover agents based on criteria like \"skills\" or \"tags\".</p> <ul> <li> <p>Mechanism: An intermediary service (the registry) maintains a collection of Agent Cards. Clients query this registry to find agents based on various criteria (e.g., skills offered, tags, provider name, capabilities).</p> </li> <li> <p>Process:</p> <ol> <li>A2A Servers publish their Agent Cards to the registry.</li> <li>Client agents query the registry's API, and search by criteria such as \"specific skills\".</li> <li>The registry returns matching Agent Cards or references.</li> </ol> </li> <li> <p>Advantages:</p> <ul> <li>Centralized management and governance.</li> <li>Capability-based discovery (e.g., by skill).</li> <li>Support for access controls and trust frameworks.</li> <li>Applicable in both private and public marketplaces.</li> </ul> </li> <li>Considerations:<ul> <li>Requires deployment and maintenance of a registry service.</li> <li>The current A2A specification does not prescribe a standard API for curated registries.</li> </ul> </li> </ul>"},{"location":"topics/agent-discovery/#3-direct-configuration-private-discovery","title":"3. Direct Configuration / Private Discovery","text":"<p>This approach is used for tightly coupled systems, private agents, or development purposes, where clients are directly configured with Agent Card information or URLs.</p> <ul> <li>Mechanism: Client applications utilize hardcoded details, configuration files, environment variables, or proprietary APIs for discovery.</li> <li>Process: The process is specific to the application's deployment and configuration strategy.</li> <li>Advantages: This method is straightforward for establishing connections within known, static relationships.</li> <li>Considerations:<ul> <li>Inflexible for dynamic discovery scenarios.</li> <li>Changes to Agent Card information necessitate client reconfiguration.</li> <li>Proprietary API-based discovery also lacks standardization.</li> </ul> </li> </ul>"},{"location":"topics/agent-discovery/#securing-agent-cards","title":"Securing Agent Cards","text":"<p>Agent Cards include sensitive information, such as:</p> <ul> <li>URLs for internal or restricted agents.</li> <li>Descriptions of sensitive skills.</li> </ul>"},{"location":"topics/agent-discovery/#protection-mechanisms","title":"Protection Mechanisms","text":"<p>To mitigate risks, the following protection mechanisms should be considered:</p> <ul> <li>Authenticated Agent Cards: We recommend the use of authenticated extended agent cards for sensitive information or for serving a more detailed version of the card.</li> <li> <p>Secure Endpoints: Implement access controls on the HTTP endpoint serving the Agent Card (e.g., <code>/.well-known/agent-card.json</code> or registry API). The methods include:</p> <ul> <li>Mutual TLS (mTLS)</li> <li>Network restrictions (e.g., IP ranges)</li> <li>HTTP Authentication (e.g., OAuth 2.0)</li> </ul> </li> <li> <p>Registry Selective Disclosure: Registries return different Agent Cards based on the client's identity and permissions.</p> </li> </ul> <p>Any Agent Card containing sensitive data must be protected with authentication and authorization mechanisms. The A2A specification strongly recommends the use of out-of-band dynamic credentials rather than embedding static secrets within the Agent Card.</p>"},{"location":"topics/agent-discovery/#future-considerations","title":"Future Considerations","text":"<p>The A2A community explores standardizing registry interactions or advanced discovery protocols.</p>"},{"location":"topics/enterprise-ready/","title":"Enterprise Implementation of A2A","text":"<p>The Agent2Agent (A2A) protocol is designed with enterprise requirements at its core. Rather than inventing new, proprietary standards for security and operations, A2A aims to integrate seamlessly with existing enterprise infrastructure and widely adopted best practices. This approach allows organizations to use their existing investments and expertise in security, monitoring, governance, and identity management.</p> <p>A key principle of A2A is that agents are typically opaque because they don't share internal memory, tools, or direct resource access with each other. This opacity naturally aligns with standard client-server security paradigms, treating remote agents as standard HTTP-based enterprise applications.</p>"},{"location":"topics/enterprise-ready/#transport-level-security-tls","title":"Transport Level Security (TLS)","text":"<p>Ensuring the confidentiality and integrity of data in transit is fundamental for any enterprise application.</p> <ul> <li>HTTPS Mandate: All A2A communication in production environments must     occur over <code>HTTPS</code>.</li> <li>Modern TLS Standards: Implementations should use modern TLS versions.     TLS 1.2 or higher is recommended. Strong, industry-standard cipher suites     should be used to protect data from eavesdropping and tampering.</li> <li>Server Identity Verification: A2A clients should verify the A2A server's     identity by validating its TLS certificate against trusted certificate     authorities during the TLS handshake. This prevents man-in-the-middle     attacks.</li> </ul>"},{"location":"topics/enterprise-ready/#authentication","title":"Authentication","text":"<p>A2A delegates authentication to standard web mechanisms. It primarily relies on HTTP headers and established standards like OAuth2 and OpenID Connect. Authentication requirements are advertised by the A2A server in its Agent Card.</p> <ul> <li>No Identity in Payload: A2A protocol payloads, such as <code>JSON-RPC</code>     messages, don't carry user or client identity information directly. Identity     is established at the transport/HTTP layer.</li> <li>Agent Card Declaration: The A2A server's Agent Card describes the     authentication schemes it supports in its <code>security</code> field and aligns with     those defined in the OpenAPI Specification for authentication.</li> <li>Out-of-Band Credential Acquisition: The A2A Client obtains the necessary credentials,     such as OAuth 2.0 tokens or API keys, through processes external to the A2A protocol itself. Examples include OAuth flows or secure key distribution.</li> <li>HTTP Header Transmission: Credentials must be transmitted in standard     HTTP headers as per the requirements of the chosen authentication scheme.     Examples include <code>Authorization: Bearer &lt;TOKEN&gt;</code> or <code>API-Key: &lt;KEY_VALUE&gt;</code>.</li> <li>Server-Side Validation: The A2A server must authenticate every     incoming request using the credentials provided in the HTTP headers.<ul> <li>If authentication fails or credentials are missing, the server should     respond with a standard HTTP status code:<ul> <li><code>401 Unauthorized</code>: If the credentials are missing or invalid. This     response should include a <code>WWW-Authenticate</code> header to inform     the client about the supported authentication methods.</li> <li><code>403 Forbidden</code>: If the credentials are valid, but the authenticated     client does not have permission to perform the requested action.</li> </ul> </li> </ul> </li> <li>In-Task Authentication (Secondary Credentials): If an agent needs     additional credentials to access a different system or service during a     task (for example, to use a specific tool on the user's behalf), the A2A server     indicates to the client that more information is needed. The client     is then responsible for obtaining these secondary credentials through a     process outside of the A2A protocol itself (for example, an OAuth flow) and     providing them back to the A2A server to continue the task.</li> </ul>"},{"location":"topics/enterprise-ready/#authorization","title":"Authorization","text":"<p>Once a client is authenticated, the A2A server is responsible for authorizing the request. Authorization logic is specific to the agent's implementation, the data it handles, and applicable enterprise policies.</p> <ul> <li>Granular Control: Authorization should be applied based on the     authenticated identity, which could represent an end user, a client     application, or both.</li> <li>Skill-Based Authorization: Access can be controlled on a per-skill     basis, as advertised in the Agent Card. For example, specific OAuth scopes     should grant an authenticated client access to invoke certain skills but     not others.</li> <li>Data and Action-Level Authorization: Agents that interact with backend     systems, databases, or tools must enforce appropriate authorization before     performing sensitive actions or accessing sensitive data through those     underlying resources. The agent acts as a gatekeeper.</li> <li>Principle of Least Privilege: Agents must grant only the necessary     permissions required for a client or user to perform their intended     operations through the A2A interface.</li> </ul>"},{"location":"topics/enterprise-ready/#data-privacy-and-confidentiality","title":"Data Privacy and Confidentiality","text":"<p>Protecting sensitive data exchanged between agents is paramount, requiring strict adherence to privacy regulations and best practices.</p> <ul> <li>Sensitivity Awareness: Implementers must be acutely aware of the     sensitivity of data exchanged in Message and Artifact parts of A2A     interactions.</li> <li>Compliance: Ensure compliance with relevant data privacy regulations     such as GDPR, CCPA, and HIPAA, based on the domain and data involved.</li> <li>Data Minimization: Avoid including or requesting unnecessarily sensitive     information in A2A exchanges.</li> <li>Secure Handling: Protect data both in transit, using TLS as mandated,     and at rest if persisted by agents, according to enterprise data security     policies and regulatory requirements.</li> </ul>"},{"location":"topics/enterprise-ready/#tracing-observability-and-monitoring","title":"Tracing, Observability, and Monitoring","text":"<p>A2A's reliance on HTTP allows for straightforward integration with standard enterprise tracing, logging, and monitoring tools, providing critical visibility into inter-agent workflows.</p> <ul> <li>Distributed Tracing: A2A Clients and Servers should participate in     distributed tracing systems. For example, use OpenTelemetry to propagate     trace context, including trace IDs and span IDs, through standard HTTP     headers, such as W3C Trace Context headers. This enables end-to-end     visibility for debugging and performance analysis.</li> <li>Comprehensive Logging: Log details on both client and server, including     taskId, sessionId, correlation IDs, and trace context for troubleshooting     and auditing.</li> <li>Metrics: A2A servers should expose key operational metrics, such as     request rates, error rates, task processing latency, and resource     utilization, to enable performance monitoring, alerting, and capacity     planning.</li> <li>Auditing: Audit significant events, such as task creation, critical     state changes, and agent actions, especially when involving sensitive data     or high-impact operations.</li> </ul>"},{"location":"topics/enterprise-ready/#api-management-and-governance","title":"API Management and Governance","text":"<p>For A2A servers exposed externally, across organizational boundaries, or even within large enterprises, integration with API Management solutions is highly recommended, as this provides:</p> <ul> <li>Centralized Policy Enforcement: Consistent application of security     policies such as authentication and authorization, rate limiting, and quotas.</li> <li>Traffic Management: Load balancing, routing, and mediation.</li> <li>Analytics and Reporting: Insights into agent usage, performance, and     trends.</li> <li>Developer Portals: Facilitate discovery of A2A-enabled agents, provide documentation such as Agent Cards, and streamline onboarding for client developers.</li> </ul> <p>By adhering to these enterprise-grade practices, A2A implementations can be deployed securely, reliably, and manageably within complex organizational environments. This fosters trust and enables scalable inter-agent collaboration.</p>"},{"location":"topics/extensions/","title":"Extensions in A2A","text":"<p>The Agent2Agent (A2A) protocol provides a strong foundation for inter-agent communication. However, specific domains or advanced use cases often require additional structure, custom data, or new interaction patterns beyond the generic methods. Extensions are A2A's powerful mechanism for layering new capabilities onto the base protocol.</p> <p>Extensions allow for extending the A2A protocol with new data, requirements, RPC methods, and state machines. Agents declare their support for specific extensions in their Agent Card, and clients can then opt-in to the behavior offered by an extension as part of requests they make to the agent. Extensions are identified by a URI and defined by their own specification. Anyone is able to define, publish, and implement an extension.</p> <p>The flexibility of extensions allows for customizing A2A without fragmenting the core standard, fostering innovation and domain-specific optimizations.</p>"},{"location":"topics/extensions/#scope-of-extensions","title":"Scope of Extensions","text":"<p>The exact set of possible ways to use extensions is intentionally broad, facilitating the ability to expand A2A beyond known use cases. However, some foreseeable applications include:</p> <ul> <li>Data-only Extensions: Exposing new, structured information in the Agent     Card that doesn't impact the request-response flow. For example, an     extension could add structured data about an agent's GDPR compliance.</li> <li>Profile Extensions: Overlaying additional structure and state change     requirements on the core request-response messages. This type effectively     acts as a profile on the core A2A protocol, narrowing the space of allowed     values (for example, requiring all messages to use <code>DataParts</code> adhering to     a specific schema). This can also include augmenting existing states in the     task state machine by using metadata. For example, an extension could define     a 'generating-image' sub-state when <code>TaskStatus.state</code> is 'working' and     <code>TaskStatus.message.metadata[\"generating-image\"]</code> is true.</li> <li>Method Extensions (Extended Skills): Adding entirely new RPC methods     beyond the core set defined by the protocol. An Extended Skill refers to a     capability or function an agent gains or exposes specifically through the     implementation of an extension that defines new RPC methods. For example, a     <code>task-history</code> extension might add a <code>tasks/search</code> RPC method to retrieve     a list of previous tasks, effectively providing the agent with a new,     extended skill.</li> <li>State Machine Extensions: Adding new states or transitions to the task   state machine.</li> </ul>"},{"location":"topics/extensions/#limitations","title":"Limitations","text":"<p>There are some changes to the protocol that extensions don't allow, primarily to prevent breaking core type validations:</p> <ul> <li>Changing the Definition of Core Data Structures: For example, adding new     fields or removing required fields to protocol-defined data structures).     Extensions should place custom attributes in the <code>metadata</code> map present on     core data structures.</li> <li>Adding New Values to Enum Types: Extensions should use existing enum values     and annotate additional semantic meaning in the <code>metadata</code> field.</li> </ul>"},{"location":"topics/extensions/#extension-declaration","title":"Extension Declaration","text":"<p>Agents declare their support for extensions in their Agent Card by including <code>AgentExtension</code> objects within their <code>AgentCapabilities</code> object.</p> <pre><code>/**\n * A declaration of a protocol extension supported by an Agent.\n *\n * @TJS-examples [{\"uri\": \"https://developers.google.com/identity/protocols/oauth2\", \"description\": \"Google OAuth 2.0 authentication\", \"required\": false}]\n */\nexport interface AgentExtension {\n  /** The unique URI identifying the extension. */\n  uri: string;\n  /** A human-readable description of how this agent uses the extension. */\n  description?: string;\n  /**\n   * If true, the client must understand and comply with the extension's requirements\n   * to interact with the agent.\n   */\n  required?: boolean;\n  /** Optional, extension-specific configuration parameters. */\n  params?: { [key: string]: any };\n}\n</code></pre> <p>The following is an example of an Agent Card with an extension:</p> <pre><code>{\n  \"name\": \"Magic 8-ball\",\n  \"description\": \"An agent that can tell your future... maybe.\",\n  \"version\": \"0.1.0\",\n  \"url\": \"https://example.com/agents/eightball\",\n  \"capabilities\": {\n    \"streaming\": true,\n    \"extensions\": [\n      {\n        \"uri\": \"https://example.com/ext/konami-code/v1\",\n        \"description\": \"Provide cheat codes to unlock new fortunes\",\n        \"required\": false,\n        \"params\": {\n          \"hints\": [\n            \"When your sims need extra cash fast\",\n            \"You might deny it, but we've seen the evidence of those cows.\"\n          ]\n        }\n      }\n    ]\n  },\n  \"defaultInputModes\": [\"text/plain\"],\n  \"defaultOutputModes\": [\"text/plain\"],\n  \"skills\": [\n    {\n      \"id\": \"fortune\",\n      \"name\": \"Fortune teller\",\n      \"description\": \"Seek advice from the mystical magic 8-ball\",\n      \"tags\": [\"mystical\", \"untrustworthy\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"topics/extensions/#required-extensions","title":"Required Extensions","text":"<p>While extensions generally offer optional functionality, some agents may have stricter requirements. When an Agent Card declares an extension as <code>required: true</code>, it signals to clients that some aspect of the extension impacts how requests are structured or processed, and that the client must abide by it. Agents shouldn't mark data-only extensions as required. If a client does not request activation of a required extension, or fails to follow its protocol, the agent should reject the incoming request with an appropriate error.</p>"},{"location":"topics/extensions/#extension-specification","title":"Extension Specification","text":"<p>The detailed behavior and structure of an extension are defined by its specification. While the exact format is not mandated, it should contain at at least:</p> <ul> <li>The specific URI(s) that identify the extension.</li> <li>The schema and meaning of objects specified in the <code>params</code> field of the     <code>AgentExtension</code> object.</li> <li>Schemas of any additional data structures communicated between client and     agent.</li> <li>Details of new request-response flows, additional endpoints, or any other     logic required to implement the extension.</li> </ul>"},{"location":"topics/extensions/#extension-dependencies","title":"Extension Dependencies","text":"<p>Extensions might depend on other extensions. This can be a required dependency (where the extension cannot function without the dependent) or an optional one (where additional functionality is enabled if another extension is present). Extension specifications should document these dependencies. It is the client's responsibility to activate an extension and all its required dependencies as listed in the extension's specification.</p>"},{"location":"topics/extensions/#extension-activation","title":"Extension Activation","text":"<p>Extensions default to being inactive, providing a baseline experience for extension-unaware clients. Clients and agents perform negotiation to determine which extensions are active for a specific request.</p> <ol> <li>Client Request: A client requests extension activation by including the     <code>X-A2A-Extensions</code> header in the HTTP request to the agent. The value is a     comma-separated list of extension URIs the client intends to activate.</li> <li>Agent Processing: Agents are responsible for identifying supported     extensions in the request and performing the activation. Any requested     extensions not supported by the agent can be ignored.</li> <li>Response: Once the agent has identified all activated extensions, the     response SHOULD include the <code>X-A2A-Extensions</code> header, listing all     extensions that were successfully activated for that request.</li> </ol> <p>Example request showing extension activation:</p> <pre><code>POST /agents/eightball HTTP/1.1\nHost: example.com\nContent-Type: application/json\nX-A2A-Extensions: https://example.com/ext/konami-code/v1\nContent-Length: 519\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"message/send\",\n  \"id\": \"1\",\n  \"params\": {\n    \"message\": {\n      \"kind\": \"message\",\n      \"messageId\": \"1\",\n      \"role\": \"user\",\n      \"parts\": [{\"kind\": \"text\", \"text\": \"Oh magic 8-ball, will it rain today?\"}]\n    },\n    \"metadata\": {\n      \"https://example.com/ext/konami-code/v1/code\": \"motherlode\"\n    }\n  }\n}\n</code></pre> <p>Corresponding response echoing activated extensions:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nX-A2A-Extensions: https://example.com/ext/konami-code/v1\nContent-Length: 338\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"result\": {\n    \"kind\": \"message\",\n    \"messageId\": \"2\",\n    \"role\": \"agent\",\n    \"parts\": [{\"kind\": \"text\", \"text\": \"That's a bingo!\"}]\n  }\n}\n</code></pre>"},{"location":"topics/extensions/#implementation-considerations","title":"Implementation Considerations","text":"<p>While the A2A protocol defines the functionality of extensions, this section provides guidance on their implementation\u2014best practices for authoring, versioning, and distributing extension implementations.</p> <ul> <li>Versioning: Extension specifications evolve. It is     crucial to have a clear versioning strategy to ensure that clients and     agents can negotiate compatible implementations.<ul> <li>Recommendation: Use the extension's URI as the primary version     identifier, ideally including a version number (for example,     <code>https://example.com/ext/my-extension/v1</code>).</li> <li>Breaking Changes: A new URI MUST be used when introducing a breaking     change to an extension's logic, data structures, or required parameters.</li> <li>Handling Mismatches: If a client requests a version not supported by     the agent, the agent SHOULD ignore the activation request for that     extension; it MUST NOT fall back to a different version.</li> </ul> </li> <li>Discoverability and Publication:<ul> <li>Specification Hosting: The extension specification document should be     hosted at the extension's URI.</li> <li>Permanent Identifiers: Authors are encouraged to use a permanent     identifier service, such as <code>w3id.org</code>, for their extension URIs to     prevent broken links.</li> <li>Community Registry (Future): The A2A community might establish a     central registry for discovering and browsing available extensions in     the future.</li> </ul> </li> <li> <p>Packaging and Reusability (A2A SDKs and Libraries):     To promote adoption, extension logic should be packaged into reusable         libraries that can be integrated into existing A2A client and         server applications.</p> <ul> <li>An extension implementation should be distributed as a     standard package for its language ecosystem (for example, a PyPI package     for Python, an npm package for TypeScript/JavaScript).</li> <li> <p>The objective is to provide a streamlined integration experience for     developers. A well-designed extension package should allow a developer     to add it to their server with minimal code, for example:</p> <pre><code>import logging\nimport os\n\nimport click\n\nfrom a2a.server.apps import A2AStarletteApplication\nfrom a2a.server.request_handlers import DefaultRequestHandler\nfrom a2a.server.tasks import InMemoryTaskStore\nfrom a2a.types import AgentCapabilities, AgentCard, AgentSkill\nfrom agent import ReimbursementAgent\nfrom agent_executor import ReimbursementAgentExecutor\nfrom dotenv import load_dotenv\nfrom timestamp_ext import TimestampExtension\n\n\nload_dotenv()\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass MissingAPIKeyError(Exception):\n    \"\"\"Exception for missing API key.\"\"\"\n\n\n@click.command()\n@click.option('--host', default='localhost')\n@click.option('--port', default=10002)\ndef main(host, port):\n    try:\n        # Check for API key only if Vertex AI is not configured\n        if not os.getenv('GOOGLE_GENAI_USE_VERTEXAI') == 'TRUE':\n            if not os.getenv('GEMINI_API_KEY'):\n                raise MissingAPIKeyError(\n                    'GEMINI_API_KEY environment variable not set and GOOGLE_GENAI_USE_VERTEXAI is not TRUE.'\n                )\n\n        hello_ext = TimestampExtension()\n        capabilities = AgentCapabilities(\n            streaming=True,\n            extensions=[\n                hello_ext.agent_extension(),\n            ],\n        )\n        skill = AgentSkill(\n            id='process_reimbursement',\n            name='Process Reimbursement Tool',\n            description='Helps with the reimbursement process for users given the amount and purpose of the reimbursement.',\n            tags=['reimbursement'],\n            examples=[\n                'Can you reimburse me $20 for my lunch with the clients?'\n            ],\n        )\n        agent_card = AgentCard(\n            name='Reimbursement Agent',\n            description='This agent handles the reimbursement process for the employees given the amount and purpose of the reimbursement.',\n            url=f'http://{host}:{port}/',\n            version='1.0.0',\n            default_input_modes=ReimbursementAgent.SUPPORTED_CONTENT_TYPES,\n            default_output_modes=ReimbursementAgent.SUPPORTED_CONTENT_TYPES,\n            capabilities=capabilities,\n            skills=[skill],\n        )\n        agent_executor = ReimbursementAgentExecutor()\n        # Use the decorator version of the extension for highest ease of use.\n        agent_executor = hello_ext.wrap_executor(agent_executor)\n        request_handler = DefaultRequestHandler(\n            agent_executor=agent_executor,\n            task_store=InMemoryTaskStore(),\n        )\n        server = A2AStarletteApplication(\n            agent_card=agent_card, http_handler=request_handler\n        )\n        import uvicorn\n\n        uvicorn.run(server.build(), host=host, port=port)\n    except MissingAPIKeyError as e:\n        logger.error(f'Error: {e}')\n        exit(1)\n    except Exception as e:\n        logger.error(f'An error occurred during server startup: {e}')\n        exit(1)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This example showcases how A2A SDKs or libraries such as <code>a2a.server</code> in Python facilitate the implementation of A2A agents and extensions.</p> </li> </ul> </li> <li> <p>Security: Extensions modify the core behavior of the A2A protocol, and therefore     introduce new security considerations:</p> <ul> <li>Input Validation: Any new data fields, parameters, or methods     introduced by an extension MUST be rigorously validated. Treat all     extension-related data from an external party as untrusted input.</li> <li>Scope of Required Extensions: Be mindful when marking an extension as     <code>required: true</code> in an Agent Card. This creates a hard dependency for     all clients and should only be used for extensions fundamental to the     agent's core function and security (for example, a message signing     extension).</li> <li>Authentication and Authorization: If an extension adds new methods,     the implementation MUST ensure these methods are subject to the same     authentication and authorization checks as the core A2A methods. An     extension MUST NOT provide a way to bypass the agent's primary security     controls.</li> </ul> </li> </ul>"},{"location":"topics/key-concepts/","title":"Core Concepts and Components in A2A","text":"<p>A2A uses a set of core concepts that define how agents interact. Understand these core building blocks to develop or integrate with A2A-compliant systems.</p> <p></p>"},{"location":"topics/key-concepts/#core-actors-in-a2a-interactions","title":"Core Actors in A2A Interactions","text":"<ul> <li>User: The end user, which can be a human operator or an automated     service. The user initiates a request or defines a goal that requires     assistance from one or more AI agents.</li> <li>A2A Client (Client Agent): An application, service, or another AI agent     that acts on behalf of the user. The client initiates communication using the     A2A protocol.</li> <li>A2A Server (Remote Agent): An AI agent or an agentic system that exposes     an HTTP endpoint implementing the A2A protocol. It receives requests from     clients, processes tasks, and returns results or status updates. From the client's perspective,     the remote agent operates as an opaque (black-box) system, meaning its internal workings, memory, or tools are not exposed.</li> </ul>"},{"location":"topics/key-concepts/#fundamental-communication-elements","title":"Fundamental Communication Elements","text":"<p>The following table describes the fundamental communication elements in A2A:</p> Element Description Key Purpose Agent Card A JSON metadata document describing an agent's identity, capabilities, endpoint, skills, and authentication requirements. Enables clients to discover agents and understand how to interact with them securely and effectively. Task A stateful unit of work initiated by an agent, with a unique ID and defined lifecycle. Facilitates tracking of long-running operations and enables multi-turn interactions and collaboration. Message A single turn of communication between a client and an agent, containing content and a role (\"user\" or \"agent\"). Conveys instructions, context, questions, answers, or status updates that are not necessarily formal artifacts. Part The fundamental content container (for example, TextPart, FilePart, DataPart) used within Messages and Artifacts. Provides flexibility for agents to exchange various content types within messages and artifacts. Artifact A tangible output generated by an agent during a task (for example, a document, image, or structured data). Delivers the concrete results of an agent's work, ensuring structured and retrievable outputs."},{"location":"topics/key-concepts/#interaction-mechanisms","title":"Interaction Mechanisms","text":"<p>The A2A Protocol supports various interaction patterns to accommodate different needs for responsiveness and persistence. These mechanisms ensure that agents can exchange information efficiently and reliably, regardless of the task's complexity or duration:</p> <ul> <li>Request/Response (Polling): Clients send a request and the server     responds. For long-running tasks, the client periodically polls the server     for updates.</li> <li>Streaming with Server-Sent Events (SSE): Clients initiate a stream to     receive real-time, incremental results or status updates from the server     over an open HTTP connection.</li> <li>Push Notifications: For very long-running tasks or disconnected     scenarios, the server can actively send asynchronous notifications to a     client-provided webhook when significant task updates occur.</li> </ul> <p>For a detailed exploration of streaming and push notifications, refer to the Streaming &amp; Asynchronous Operations document.</p>"},{"location":"topics/key-concepts/#agent-cards","title":"Agent Cards","text":"<p>The Agent Card is a JSON document that serves as a digital business card for initial discovery and interaction setup. It provides essential metadata about an agent. Clients parse this information to determine if an agent is suitable for a given task, how to structure requests, and how to communicate securely. Key information includes identity, service endpoint (URL), A2A capabilities, authentication requirements, and a list of skills.</p>"},{"location":"topics/key-concepts/#messages-and-parts","title":"Messages and Parts","text":"<p>A message represents a single turn of communication between a client and an agent. It includes a role (\"user\" or \"agent\") and a unique <code>messageId</code>. It contains one or more Part objects, which are granular containers for the actual content. This design allows A2A to be modality independent.</p> <p>The primary part kinds are:</p> <ul> <li><code>TextPart</code>: Contains plain textual content.</li> <li><code>FilePart</code>: Represents a file. It can be transmitted either inline (Base64    encoded) or through a URI. It includes metadata like \"filename\" and \"mimeType\".</li> <li><code>DataPart</code>: Carries structured JSON data. This is useful for forms,    parameters, or any machine-readable information.</li> </ul>"},{"location":"topics/key-concepts/#artifacts","title":"Artifacts","text":"<p>An artifact represents a tangible output or a concrete result generated by a remote agent during task processing. Unlike general messages, artifacts are the actual deliverables. An artifact has a unique <code>artifactId</code>, a human-readable name, and consists of one or more part objects. Artifacts are closely tied to the task lifecycle and can be streamed incrementally to the client.</p>"},{"location":"topics/key-concepts/#agent-response-task-or-message","title":"Agent Response: Task or Message","text":"<p>The agent response can be a new <code>Task</code> (when the agent needs to perform a long-running operation) or a <code>Message</code> (when the agent can respond immediately).</p> <p>For more details, see Life of a Task.</p>"},{"location":"topics/key-concepts/#other-important-concepts","title":"Other Important Concepts","text":"<ul> <li>Context (<code>contextId</code>): A server-generated identifier that can be used to logically group multiple related <code>Task</code> objects, providing context across a series of interactions.</li> <li>Transport and Format: A2A communication occurs over HTTP(S). JSON-RPC 2.0 is used as the payload format for all requests and responses.</li> <li>Authentication &amp; Authorization: A2A relies on standard web security practices. Authentication requirements are declared in the Agent Card, and credentials (e.g., OAuth tokens, API keys) are typically passed through HTTP headers, separate from the A2A protocol messages themselves. For more information, see Enterprise-Ready Features.</li> <li>Agent Discovery: The process by which clients find Agent Cards to learn about available A2A Servers and their capabilities. For more information, see Agent Discovery.</li> <li>Extensions: A2A allows agents to declare custom protocol extensions as part of their AgentCard. For more information, see Extensions.</li> </ul>"},{"location":"topics/life-of-a-task/","title":"Life of a Task","text":"<p>In the Agent2Agent (A2A) Protocol, interactions can range from simple, stateless exchanges to complex, long-running processes. When an agent receives a message from a client, it can respond in one of two fundamental ways:</p> <ul> <li>Respond with a Stateless <code>Message</code>: This type of response is     typically used for immediate, self-contained interactions that conclude     without requiring further state management.</li> <li>Initiate a Stateful <code>Task</code>: If the response is a <code>Task</code>, the agent will     process it through a defined lifecycle, communicating progress and requiring     input as needed, until it reaches an interrupted state (e.g.,     <code>input-required</code>, <code>auth-required</code>) or a terminal state (e.g., <code>completed</code>,     <code>canceled</code>, <code>rejected</code>, <code>failed</code>).</li> </ul>"},{"location":"topics/life-of-a-task/#group-related-interactions","title":"Group Related Interactions","text":"<p>A <code>contextId</code> is a crucial identifier that logically groups multiple <code>Task</code> objects and independent <code>Message</code> objects, providing continuity across a series of interactions.</p> <ul> <li>When a client sends a message for the first time, the agent responds     with a new <code>contextId</code>. If a task is initiated, it will also have a <code>taskId</code>.</li> <li>Clients can send subsequent messages and include the same <code>contextId</code> to     indicate that they are continuing their previous interaction within the same     context.</li> <li>Clients optionally attach the <code>taskId</code> to a subsequent message to     indicate that it continues that specific task.</li> </ul> <p>The <code>contextId</code> enables collaboration towards a common goal or a shared contextual session across multiple, potentially concurrent tasks. Internally, an A2A agent (especially one using an LLM) uses the <code>contextId</code> to manage its internal conversational state or its LLM context.</p>"},{"location":"topics/life-of-a-task/#agent-response-message-or-task","title":"Agent Response: Message or Task","text":"<p>The choice between responding with a <code>Message</code> or a <code>Task</code> depends on the nature of the interaction and the agent's capabilities:</p> <ul> <li>Messages for Trivial Interactions: <code>Message</code> objects are suitable for     transactional interactions that don't require long-running     processing or complex state management. An agent might use messages to     negotiate the acceptance or scope of a task before committing to a <code>Task</code>     object.</li> <li>Tasks for Stateful Interactions: Once an agent maps the intent of an     incoming message to a supported capability that requires substantial,     trackable work over an extended period, the agent responds with a <code>Task</code>     object.</li> </ul> <p>Conceptually, agents operate at different levels of complexity:</p> <ul> <li>Message-only Agents: Always respond with <code>Message</code> objects. They     typically don't manage complex state or long-running executions, and use     <code>contextId</code> to tie messages together. These agents might directly wrap LLM     invocations and simple tools.</li> <li>Task-generating Agents: Always respond with <code>Task</code> objects, even for     responses, which are then modeled as completed tasks. Once a task is     created, the agent will only return <code>Task</code> objects in response to messages     sent, and once a task is complete, no more messages can be sent. This     approach avoids deciding between <code>Task</code> versus <code>Message</code>, but creates completed task objects     for even simple interactions.</li> <li>Hybrid Agents: Generate both <code>Message</code> and <code>Task</code> objects. These agents     use messages to negotiate agent capability and the scope of work for a task,     then send a <code>Task</code> object to track execution and manage states like     <code>input-required</code> or error handling. Once a task is created, the agent will     only return <code>Task</code> objects in response to messages sent, and once a task is     complete, no more messages can be sent. A hybrid agent uses messages to     negotiate the scope of a task, and then generate a task to track its     execution.     For more information about hybrid agents, see A2A protocol: Demystifying Tasks vs Messages.</li> </ul>"},{"location":"topics/life-of-a-task/#task-refinements","title":"Task Refinements","text":"<p>Clients often need to send new requests based on task results or refine the outputs of previous tasks. This is modeled by starting another interaction using the same <code>contextId</code> as the original task. Clients further hint the agent by providing references to the original task using <code>referenceTaskIds</code> in the <code>Message</code> object. The agent then responds with either a new <code>Task</code> or a <code>Message</code>.</p>"},{"location":"topics/life-of-a-task/#task-immutability","title":"Task Immutability","text":"<p>Once a task reaches a terminal state (completed, canceled, rejected, or failed), it cannot restart. Any subsequent interaction related to that task, such as a refinement, must initiate a new task within the same <code>contextId</code>. This principle offers several benefits:</p> <ul> <li>Task Immutability. Clients reliably reference tasks and their     associated state, artifacts, and messages, providing a clean mapping of     inputs to outputs. This is valuable for orchestration and traceability.</li> <li>Clear Unit of Work. Every new request, refinement, or follow-up becomes     a distinct task. This simplifies bookkeeping, allows for granular tracking     of an agent's work, and enables tracing each artifact to a specific unit of     work.</li> <li>Easier Implementation. This removes ambiguity for agent developers     regarding whether to create a new task or restart an existing one.</li> </ul>"},{"location":"topics/life-of-a-task/#parallel-follow-ups","title":"Parallel Follow-ups","text":"<p>A2A supports parallel work by enabling agents to create distinct, parallel tasks for each follow-up message sent within the same <code>contextId</code>. This allows clients to track individual tasks and create new dependent tasks as soon as a prerequisite task is complete.</p> <p>For example:</p> <ul> <li>Task 1: Book a flight to Helsinki.</li> <li>Task 2: Based on Task 1, book a hotel.</li> <li>Task 3: Based on Task 1, book a snowmobile activity.</li> <li>Task 4: Based on Task 2, add a spa reservation to the hotel booking.</li> </ul>"},{"location":"topics/life-of-a-task/#referencing-previous-artifacts","title":"Referencing Previous Artifacts","text":"<p>The serving agent infers the relevant artifact from a referenced task or from the <code>contextId</code>. As the domain expert, the serving agent is best suited to resolve ambiguity or identify missing information. If there is ambiguity, the agent asks the client for clarification by returning an <code>input-required</code> state. The client then specifies the artifact in its response, optionally populating artifact references (<code>artifactId</code>, <code>taskId</code>) in <code>Part</code> metadata.</p>"},{"location":"topics/life-of-a-task/#tracking-artifact-mutation","title":"Tracking Artifact Mutation","text":"<p>Follow-up or refinement tasks often lead to the creation of new artifacts based on older ones. Tracking these mutations is important to ensure that only the most recent version of an artifact is used in subsequent interactions. This could be conceptualized as a version history, where each new artifact is linked to its predecessor.</p> <p>However, the client is in the best position to manage this artifact linkage. The client determines what constitutes an acceptable result and has the ability to accept or reject new versions. Therefore, the serving agent shouldn't be responsible for tracking artifact mutations, and this linkage is not part of the A2A protocol specification. Clients should maintain this version history on their end and present the latest acceptable version to the user.</p> <p>To facilitate client-side tracking, serving agents should use a consistent <code>artifact-name</code> when generating a refined version of an existing artifact.</p> <p>When initiating follow-up or refinement tasks, the client should explicitly reference the specific artifact they intend to refine, ideally the \"latest\" version from their perspective. If the artifact reference is not provided, the serving agent can:</p> <ul> <li>Attempt to infer the intended artifact based on the current <code>contextId</code>.</li> <li>If there is ambiguity or insufficient context, the agent should respond with an <code>input-required</code> task state to request clarification from the client.</li> </ul>"},{"location":"topics/life-of-a-task/#example-follow-up-scenario","title":"Example Follow-up Scenario","text":"<p>The following example illustrates a typical task flow with a follow-up:</p> <ol> <li> <p>Client sends a message to the agent:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"method\": \"message.send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Generate an image of a sailboat on the ocean.\"\n        }\n      ]\n      \"messageId\": \"msg-user-001\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>Agent responds with a boat image (completed task):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"result\": {\n    \"id\": \"task-boat-gen-123\",\n    \"contextId\": \"ctx-conversation-abc\",\n    \"status\": {\n      \"state\": \"completed\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"artifact-boat-v1-xyz\",\n        \"name\": \"sailboat_image.png\",\n        \"description\": \"A generated image of a sailboat on the ocean.\",\n        \"parts\": [\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"name\": \"sailboat_image.png\",\n              \"mimeType\": \"image/png\",\n              \"bytes\": \"base64_encoded_png_data_of_a_sailboat\"\n            }\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre> </li> <li> <p>Client asks to color the boat red. This refinement request refers to the     previous <code>taskId</code> and uses the same <code>contextId</code>.</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"method\": \"message.send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"messageId\": \"msg-user-002\",\n      \"contextId\": \"ctx-conversation-abc\",\n      \"referenceTaskIds\": [\n        \"task-boat-gen-123\"\n      ],\n      \"parts\": [\n        {\n          \"kind\": \"text\",\n          \"text\": \"Please modify the sailboat to be red.\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> </li> <li> <p>Agent responds with a new image artifact (new task, same context, updated     artifact name): The agent creates a new task within the same <code>contextId</code>. The     new boat image artifact retains the same name but has a new <code>artifactId</code>.</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"result\": {\n    \"id\": \"task-boat-color-456\",\n    \"contextId\": \"ctx-conversation-abc\",\n    \"status\": {\n      \"state\": \"completed\"\n    },\n    \"artifacts\": [\n      {\n        \"artifactId\": \"artifact-boat-v2-red-pqr\",\n        \"name\": \"sailboat_image.png\",\n        \"description\": \"A generated image of a red sailboat on the ocean.\",\n        \"parts\": [\n          {\n            \"kind\": \"file\",\n            \"file\": {\n              \"name\": \"sailboat_image.png\",\n              \"mimeType\": \"image/png\",\n              \"bytes\": \"base64_encoded_png_data_of_a_RED_sailboat\"\n            }\n          }\n        ]\n      }\n    ],\n    \"kind\": \"task\"\n  }\n}\n</code></pre> </li> </ol>"},{"location":"topics/streaming-and-async/","title":"Streaming and Asynchronous Operations for Long-Running Tasks","text":"<p>The Agent2Agent (A2A) protocol is explicitly designed to handle tasks that might not complete immediately. Many AI-driven operations are often long-running, involve multiple steps, produce incremental results, or require human intervention. A2A provides mechanisms for managing such asynchronous interactions, ensuring that clients receive updates effectively, whether they remain continuously connected or operate in a more disconnected fashion.</p>"},{"location":"topics/streaming-and-async/#streaming-with-server-sent-events-sse","title":"Streaming with Server-Sent Events (SSE)","text":"<p>For tasks that produce incremental results (like generating a long document or streaming media) or provide ongoing status updates, A2A supports real-time communication using Server-Sent Events (SSE). This approach is ideal when the client is able to maintain an active HTTP connection with the A2A Server.</p> <p>The following key features detail how SSE streaming is implemented and managed within the A2A protocol:</p> <ul> <li> <p>Server Capability: The A2A Server must indicate its support for streaming by setting <code>capabilities.streaming: true</code> in its Agent Card.</p> </li> <li> <p>Initiating a Stream: The client uses the <code>message/stream</code> RPC method to send an initial message (for example, a prompt or command) and simultaneously subscribe to updates for that task.</p> </li> <li> <p>Server Response and Connection: If the subscription is successful, the server responds with an HTTP 200 OK status and a <code>Content-Type: text/event-stream</code>. This HTTP connection remains open for the server to push events to the client.</p> </li> <li> <p>Event Structure and Types: The server sends events over this stream. Each event's <code>data</code> field contains a JSON-RPC 2.0 Response object, typically a <code>SendStreamingMessageResponse</code>. The <code>result</code> field of the <code>SendStreamingMessageResponse</code> contains:</p> <ul> <li><code>Task</code>: Represents the current state of the work.</li> <li><code>TaskStatusUpdateEvent</code>: Communicates changes in the task's lifecycle state (for example, from <code>working</code> to <code>input-required</code> or <code>completed</code>). It also provides intermediate messages from the agent.</li> <li><code>TaskArtifactUpdateEvent</code>: Delivers new or updated Artifacts generated by the task. This is used to stream large files or data structures in chunks, with fields like <code>append</code> and <code>lastChunk</code> to help reassemble.</li> </ul> </li> <li> <p>Stream Termination: The server signals the end of updates for a cycle by setting <code>final: true</code> in a <code>TaskStatusUpdateEvent</code>. This typically occurs when the task reaches a terminal state. After this, the server usually closes the SSE connection.</p> </li> <li> <p>Resubscription: If a client's SSE connection breaks prematurely while a task is still active, the client is able to attempt to reconnect to the stream using the <code>tasks/resubscribe</code> RPC method.</p> </li> </ul>"},{"location":"topics/streaming-and-async/#when-to-use-streaming","title":"When to Use Streaming","text":"<p>Streaming with SSE is best suited for:</p> <ul> <li>Real-time progress monitoring of long-running tasks.</li> <li>Receiving large results (artifacts) incrementally.</li> <li>Interactive, conversational exchanges where immediate feedback or partial responses are beneficial.</li> <li>Applications requiring low-latency updates from the agent.</li> </ul>"},{"location":"topics/streaming-and-async/#protocol-specification-references","title":"Protocol Specification References","text":"<p>Refer to the Protocol Specification for detailed structures:</p> <ul> <li><code>message/stream</code></li> <li><code>tasks/resubscribe</code></li> </ul>"},{"location":"topics/streaming-and-async/#push-notifications-for-disconnected-scenarios","title":"Push Notifications for Disconnected Scenarios","text":"<p>For very long-running tasks (for example, lasting minutes, hours, or even days) or when clients are unable to or prefer not to maintain persistent connections (like mobile clients or serverless functions), A2A supports asynchronous updates using push notifications. This allows the A2A Server to actively notify a client-provided webhook when a significant task update occurs.</p> <p>The following key features detail how push notifications are implemented and managed within the A2A protocol:</p> <ul> <li>Server Capability: The A2A Server must indicate its support for this feature by setting <code>capabilities.pushNotifications: true</code> in its Agent Card.</li> <li>Configuration: The client provides a <code>PushNotificationConfig</code> to the server. This configuration is supplied:<ul> <li>Within the initial <code>message/send</code> or <code>message/stream</code> request, or</li> <li>Separately, using the <code>tasks/pushNotificationConfig/set</code> RPC method for an existing task. The <code>PushNotificationConfig</code> includes a <code>url</code> (the HTTPS webhook URL), an optional <code>token</code> (for client-side validation), and optional <code>authentication</code> details (for the A2A Server to authenticate to the webhook).</li> </ul> </li> <li>Notification Trigger: The A2A Server decides when to send a push notification, typically when a task reaches a significant state change (for example, terminal state, <code>input-required</code>, or <code>auth-required</code>).</li> <li>Notification Payload: The A2A protocol does not strictly define the HTTP body payload, but it SHOULD contain sufficient information for the client to identify the Task ID and understand the general nature of the update (for example, the new <code>TaskState</code>).</li> <li>Client Action: Upon receiving a push notification (and successfully verifying its authenticity), the client typically uses the <code>tasks/get</code> RPC method with the <code>taskId</code> from the notification to retrieve the complete, updated <code>Task</code> object, including any new artifacts.</li> </ul>"},{"location":"topics/streaming-and-async/#when-to-use-push-notifications","title":"When to Use Push Notifications","text":"<p>Push notifications are ideal for:</p> <ul> <li>Very long-running tasks that can take minutes, hours, or days to complete.</li> <li>Clients that cannot or prefer not to maintain persistent connections, such as mobile applications or serverless functions.</li> <li>Scenarios where clients only need to be notified of significant state changes rather than continuous updates.</li> </ul>"},{"location":"topics/streaming-and-async/#protocol-specification-references_1","title":"Protocol Specification References","text":"<p>Refer to the Protocol Specification for detailed structures:</p> <ul> <li><code>tasks/pushNotificationConfig/set</code></li> <li><code>tasks/get</code></li> </ul>"},{"location":"topics/streaming-and-async/#client-side-push-notification-service","title":"Client-Side Push Notification Service","text":"<p>The <code>url</code> specified in <code>PushNotificationConfig.url</code> points to a client-side Push Notification Service. This service is responsible for receiving the HTTP POST notification from the A2A Server. Its responsibilities include authenticating the incoming notification, validating its relevance, and relaying the notification or its content to the appropriate client application logic or system.</p>"},{"location":"topics/streaming-and-async/#security-considerations-for-push-notifications","title":"Security Considerations for Push Notifications","text":"<p>Security is paramount for push notifications due to their asynchronous and server-initiated outbound nature. Both the A2A Server (sending the notification) and the client's webhook receiver have critical responsibilities.</p>"},{"location":"topics/streaming-and-async/#a2a-server-security-when-sending-notifications-to-client-webhook","title":"A2A Server Security (when sending notifications to client webhook)","text":"<ul> <li>Webhook URL Validation: Servers SHOULD NOT blindly trust and send POST requests to any URL provided by a client. Malicious clients could provide URLs pointing to internal services or unrelated third-party systems, leading to Server-Side Request Forgery (SSRF) attacks or acting as Distributed Denial of Service (DDoS) amplifiers.<ul> <li>Mitigation strategies: Allowlisting of trusted domains, ownership verification (for example, challenge-response mechanisms), and network controls (e.g., egress firewalls).</li> </ul> </li> <li>Authenticating to the Client's Webhook: The A2A Server MUST authenticate itself to the client's webhook URL according to the scheme(s) specified in <code>PushNotificationConfig.authentication</code>. Common schemes include Bearer Tokens (OAuth 2.0), API keys, HMAC signatures, or mutual TLS (mTLS).</li> </ul>"},{"location":"topics/streaming-and-async/#client-webhook-receiver-security-when-receiving-notifications-from-a2a-server","title":"Client Webhook Receiver Security (when receiving notifications from A2A server)","text":"<ul> <li>Authenticating the A2A Server: The webhook endpoint MUST rigorously verify the authenticity of incoming notification requests to ensure they originate from the legitimate A2A Server and not an imposter.<ul> <li>Verification methods: Verify signatures/tokens (for example, JWT signatures against the A2A Server's trusted public keys, HMAC signatures, or API key validation). Also, validate the <code>PushNotificationConfig.token</code> if provided.</li> </ul> </li> <li>Preventing Replay Attacks:<ul> <li>Timestamps: Notifications SHOULD include a timestamp. The webhook SHOULD reject notifications that are too old.</li> <li>Nonces/unique IDs: For critical notifications, consider using unique, single-use identifiers (for example, JWT's <code>jti</code> claim or event IDs) to prevent processing duplicate notifications.</li> </ul> </li> <li>Secure Key Management and Rotation: Implement secure key management practices, including regular key rotation, especially for cryptographic keys. Protocols like JWKS (JSON Web Key Set) facilitate key rotation for asymmetric keys.</li> </ul>"},{"location":"topics/streaming-and-async/#example-asymmetric-key-flow-jwt-jwks","title":"Example Asymmetric Key Flow (JWT + JWKS)","text":"<ol> <li>Client sets <code>PushNotificationConfig</code> specifying <code>authentication.schemes: [\"Bearer\"]</code> and possibly an expected <code>issuer</code> or <code>audience</code> for the JWT.</li> <li>A2A Server, when sending a notification:<ul> <li>Generates a JWT, signing it with its private key. The JWT includes claims like <code>iss</code> (issuer), <code>aud</code> (audience), <code>iat</code> (issued at), <code>exp</code> (expires), <code>jti</code> (JWT ID), and <code>taskId</code>.</li> <li>The JWT header indicates the signing algorithm and key ID (<code>kid</code>).</li> <li>The A2A Server makes its public keys available through a JWKS endpoint.</li> </ul> </li> <li>Client Webhook, upon receiving the notification:<ul> <li>Extracts the JWT from the Authorization header.</li> <li>Inspects the <code>kid</code> (key ID) in the JWT header.</li> <li>Fetches the corresponding public key from the A2A Server's JWKS endpoint (caching keys is recommended).</li> <li>Verifies the JWT signature using the public key.</li> <li>Validates claims (<code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>, <code>jti</code>).</li> <li>Checks the <code>PushNotificationConfig.token</code> if provided.</li> </ul> </li> </ol> <p>This comprehensive, layered approach to security for push notifications helps ensure that messages are authentic, integral, and timely, protecting both the sending A2A Server and the receiving client webhook infrastructure.</p>"},{"location":"topics/what-is-a2a/","title":"A2A Protocol Overview","text":"<p>The A2A protocol is an open standard that enables seamless communication and collaboration between AI agents. It provides a common language for agents built using diverse frameworks and by different vendors, fostering interoperability and breaking down silos. Agents are autonomous problem-solvers that act independently within their environment. A2A allows agents from different developers, built on different frameworks, and owned by different organizations to unite and work together.</p>"},{"location":"topics/what-is-a2a/#why-use-the-a2a-protocol","title":"Why Use the A2A Protocol","text":"<p>A2A addresses key challenges in AI agent collaboration. It provides a standardized approach for agents to interact. This section explains the problems A2A solves and the benefits it offers.</p>"},{"location":"topics/what-is-a2a/#problems-that-a2a-solves","title":"Problems that A2A Solves","text":"<p>Consider a user request for an AI assistant to plan an international trip. This task involves orchestrating multiple specialized agents, such as:</p> <ul> <li>A flight booking agent</li> <li>A hotel reservation agent</li> <li>An agent for local tour recommendations</li> <li>A currency conversion agent</li> </ul> <p>Without A2A, integrating these diverse agents presents several challenges:</p> <ul> <li>Agent Exposure: Developers often wrap agents as tools to expose them to     other agents, similar to how tools are exposed in a Multi-agent Control     Platform (Model Context Protocol). However, this approach is inefficient because agents are     designed to negotiate directly. Wrapping agents as tools limits their capabilities.     A2A allows agents to be exposed as they are, without requiring this wrapping.</li> <li>Custom Integrations: Each interaction requires custom, point-to-point     solutions, creating significant engineering overhead.</li> <li>Slow Innovation: Bespoke development for each new integration slows     innovation.</li> <li>Scalability Issues: Systems become difficult to scale and maintain as     the number of agents and interactions grows.</li> <li>Interoperability: This approach limits interoperability,     preventing the organic formation of complex AI ecosystems.</li> <li>Security Gaps: Ad hoc communication often lacks consistent security     measures.</li> </ul> <p>The A2A protocol addresses these challenges by establishing interoperability for AI agents to interact reliably and securely.</p>"},{"location":"topics/what-is-a2a/#a2a-example-scenario","title":"A2A Example Scenario","text":"<p>This section provides an example scenario to illustrate the benefits of using an A2A (Agent2Agent) protocol for complex interactions between AI agents.</p>"},{"location":"topics/what-is-a2a/#a-users-complex-request","title":"A User's Complex Request","text":"<p>A user interacts with an AI assistant, giving it a complex prompt like \"Plan an international trip.\"</p> <pre><code>graph LR\n    User --&gt; Prompt --&gt; AI_Assistant[AI Assistant]</code></pre>"},{"location":"topics/what-is-a2a/#the-need-for-collaboration","title":"The Need for Collaboration","text":"<p>The AI assistant receives the prompt and realizes it needs to call upon multiple specialized agents to fulfill the request. These agents include a Flight Booking Agent, a Hotel Reservation Agent, a Currency Conversion Agent, and a Local Tours Agent.</p> <pre><code>graph LR\n    subgraph \"Specialized Agents\"\n        FBA[\u2708\ufe0f Flight Booking Agent]\n        HRA[\ud83c\udfe8 Hotel Reservation Agent]\n        CCA[\ud83d\udcb1 Currency Conversion Agent]\n        LTA[\ud83d\ude8c Local Tours Agent]\n    end\n\n    AI_Assistant[\ud83e\udd16 AI Assistant] --&gt; FBA\n    AI_Assistant --&gt; HRA\n    AI_Assistant --&gt; CCA\n    AI_Assistant --&gt; LTA</code></pre>"},{"location":"topics/what-is-a2a/#the-interoperability-challenge","title":"The Interoperability Challenge","text":"<p>The core problem: The agents are unable to work together because each has its own bespoke development and deployment.</p> <p>The consequence of a lack of a standardized protocol is that these agents cannot collaborate with each other let alone discover what they can do. The individual agents (Flight, Hotel, Currency, and Tours) are isolated.</p>"},{"location":"topics/what-is-a2a/#scene-5-the-with-a2a-solution","title":"Scene 5: The \"With A2A\" Solution","text":"<p>The A2A Protocol provides standard methods and data structures for agents to communicate with one another, regardless of their underlying implementation, so the same agents can be used as an interconnected system, communicating seamlessly through the standardized protocol.</p> <p>The AI assistant, now acting as an orchestrator, receives the cohesive information from all the A2A-enabled agents. It then presents a single, complete travel plan as a seamless response to the user's initial prompt.</p> <p></p>"},{"location":"topics/what-is-a2a/#core-benefits-of-a2a","title":"Core Benefits of A2A","text":"<p>Implementing the A2A protocol offers significant advantages across the AI ecosystem:</p> <ul> <li>Secure collaboration: Without a standard, it's difficult to ensure     secure communication between agents. A2A uses HTTPS for secure communication     and maintains opaque operations, so agents can't see the inner workings of     other agents during collaboration.</li> <li>Interoperability: A2A breaks down silos between different AI     agent ecosystems, enabling agents from various vendors and frameworks to work     together seamlessly.</li> <li>Agent autonomy: A2A allows agents to retain their individual capabilities     and act as autonomous entities while collaborating with other agents.</li> <li>Reduced integration complexity: The protocol standardizes agent     communication, enabling teams to focus on the unique value their agents     provide.</li> <li>Support for LRO: The protocol supports long-running operations (LRO) and     streaming with Server-Sent Events (SSE) and asynchronous execution.</li> </ul>"},{"location":"topics/what-is-a2a/#key-design-principles-of-a2a","title":"Key Design Principles of A2A","text":"<p>A2A development follows principles that prioritize broad adoption, enterprise-grade capabilities, and future-proofing.</p> <ul> <li>Simplicity: A2A leverages existing standards like HTTP, JSON-RPC, and     Server-Sent Events (SSE). This avoids reinventing core technologies and     accelerates developer adoption.</li> <li>Enterprise Readiness: A2A addresses critical enterprise needs. It aligns     with standard web practices for robust authentication, authorization,     security, privacy, tracing, and monitoring.</li> <li>Asynchronous: A2A natively supports long-running tasks. It handles     scenarios where agents or users might not remain continuously connected. It     uses mechanisms like streaming and push notifications.</li> <li>Modality Independent: The protocol allows agents to communicate using a     wide variety of content types. This enables rich and flexible interactions     beyond plain text.</li> <li>Opaque Execution: Agents collaborate effectively without exposing their     internal logic, memory, or proprietary tools. Interactions rely on declared     capabilities and exchanged context. This preserves intellectual property and     enhances security.</li> </ul>"},{"location":"topics/what-is-a2a/#understanding-the-agent-stack-a2a-mcp-agent-frameworks-and-models","title":"Understanding the Agent Stack: A2A, MCP, Agent Frameworks and Models","text":"<p>A2A is situated within a broader agent stack, which includes:</p> <ul> <li>A2A: Standardizes communication among agents deployed in different organizations and developed using diverse frameworks.</li> <li>MCP: Connects models to data and external resources.</li> <li>Frameworks (like ADK): Provide toolkits for constructing agents.</li> <li>Models: Fundamental to an agent's reasoning, these can be any Large Language Model (LLM).</li> </ul> <p></p>"},{"location":"topics/what-is-a2a/#a2a-and-mcp","title":"A2A and MCP","text":"<p>In the broader ecosystem of AI communication, you might be familiar with protocols designed to facilitate interactions between agents, models, and tools. Notably, the Model Context Protocol (MCP) is an emerging standard focused on connecting Large Language Models (LLMs) with data and external resources.</p> <p>The Agent2Agent (A2A) protocol is designed to standardize communication between AI agents, particularly those deployed in external systems. A2A is positioned to complement MCP, addressing a distinct yet related aspect of agent interaction.</p> <ul> <li>MCP's Focus: Reducing the complexity involved in connecting agents with tools and data. Tools are typically stateless and perform specific, predefined functions (e.g., a calculator, a database query).</li> <li>A2A's Focus: Enabling agents to collaborate within their native modalities, allowing them to communicate as agents (or as users) rather than being constrained to tool-like interactions. This enables complex, multi-turn interactions where agents reason, plan, and delegate tasks to other agents. For example, this facilitates multi-turn interactions, such as those involving negotiation or clarification when placing an order.</li> </ul> <p></p> <p>The practice of encapsulating an agent as a simple tool is fundamentally limiting, as it fails to capture the agent's full capabilities. This critical distinction is explored in the post, Why Agents Are Not Tools.</p> <p>For a more in-depth comparison, refer to the A2A and MCP Comparison document.</p>"},{"location":"topics/what-is-a2a/#a2a-and-adk","title":"A2A and ADK","text":"<p>The Agent Development Kit (ADK) is an open-source agent development toolkit developed by Google. A2A is a communication protocol for agents that enables inter-agent communication, regardless of the framework used for their construction (e.g., ADK, LangGraph, or Crew AI). ADK is a flexible and modular framework for developing and deploying AI agents. While optimized for Gemini AI and the Google ecosystem, ADK is model-agnostic, deployment-agnostic, and built for compatibility with other frameworks.</p>"},{"location":"topics/what-is-a2a/#a2a-request-lifecycle","title":"A2A Request Lifecycle","text":"<p>The A2A request lifecycle is a sequence that details the four main steps a request follows: agent discovery, authentication, <code>sendMessage</code> API, and <code>sendMessageStream</code> API. The following diagram provides a deeper look into the operational flow, illustrating the interactions between the client, A2A server, and auth server.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant A2A Server\n    participant Auth Server\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 1. Agent Discovery\n    Client-&gt;&gt;A2A Server: GET agent card eg: (/.well-known/agent-card)\n    A2A Server--&gt;&gt;Client: Returns Agent Card\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, Auth Server: 2. Authentication\n    Client-&gt;&gt;Client: Parse Agent Card for securitySchemes\n    alt securityScheme is \"openIdConnect\"\n        Client-&gt;&gt;Auth Server: Request token based on \"authorizationUrl\" and \"tokenUrl\".\n        Auth Server--&gt;&gt;Client: Returns JWT\n    end\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 3. sendMessage API\n    Client-&gt;&gt;Client: Parse Agent Card for \"url\" param to send API requests to.\n    Client-&gt;&gt;A2A Server: POST /sendMessage (with JWT)\n    A2A Server-&gt;&gt;A2A Server: Process message and create task\n    A2A Server--&gt;&gt;Client: Returns Task Response\n    end\n\n    rect rgb(240, 240, 240)\n    Note over Client, A2A Server: 4. sendMessageStream API\n    Client-&gt;&gt;A2A Server: POST /sendMessageStream (with JWT)\n    A2A Server--&gt;&gt;Client: Stream: Task (Submitted)\n    A2A Server--&gt;&gt;Client: Stream: TaskStatusUpdateEvent (Working)\n    A2A Server--&gt;&gt;Client: Stream: TaskArtifactUpdateEvent (artifact A)\n    A2A Server--&gt;&gt;Client: Stream: TaskArtifactUpdateEvent (artifact B)\n    A2A Server--&gt;&gt;Client: Stream: TaskStatusUpdateEvent (Completed)\n    end</code></pre>"},{"location":"topics/what-is-a2a/#whats-next","title":"What's Next","text":"<p>Learn about the Key Concepts that form the foundation of the A2A protocol.</p>"},{"location":"tutorials/","title":"Get Started with A2A","text":"<p>The A2A protocol is an open standard that enables seamless communication and collaboration between AI agents. It provides a common language for agents built using diverse frameworks and by different vendors, fostering interoperability and breaking down silos. Agents are autonomous problem-solvers that act independently within their environment. A2A allows agents from different developers, built on different frameworks, and owned by different organizations to unite and work together.</p>"},{"location":"tutorials/#why-use-the-a2a-protocol","title":"Why Use the A2A Protocol","text":"<p>A2A addresses key challenges in AI agent collaboration. It provides a standardized approach for agents to interact. This section explains the problems A2A solves and the benefits it offers.</p>"},{"location":"tutorials/#problems-that-a2a-solves","title":"Problems that A2A Solves","text":"<p>Consider a user request for an AI assistant to plan an international trip. This task involves orchestrating multiple specialized agents, such as:</p> <ul> <li>A flight booking agent</li> <li>A hotel reservation agent</li> <li>An agent for local tour recommendations</li> <li>A currency conversion agent</li> </ul> <p>Without A2A, integrating these diverse agents presents several challenges:</p> <ul> <li>Agent Exposure: Developers often wrap agents as tools to expose them to     other agents, similar to how tools are exposed in a Multi-agent Control     Platform (Model Context Protocol). However, this approach is inefficient because agents are     designed to negotiate directly. Wrapping agents as tools limits their capabilities.     A2A allows agents to be exposed as they are, without requiring this wrapping.</li> <li>Custom Integrations: Each interaction requires custom, point-to-point     solutions, creating significant engineering overhead.</li> <li>Slow Innovation: Bespoke development for each new integration slows     innovation.</li> <li>Scalability Issues: Systems become difficult to scale and maintain as     the number of agents and interactions grows.</li> <li>Interoperability: This approach limits interoperability,     preventing the organic formation of complex AI ecosystems.</li> <li>Security Gaps: Ad hoc communication often lacks consistent security     measures.</li> </ul> <p>The A2A protocol addresses these challenges by establishing interoperability for AI agents to interact reliably and securely.</p>"},{"location":"tutorials/#how-the-a2a-protocol-works","title":"How the A2A Protocol Works","text":"<p>A2A defines how independent AI agent systems interact. It provides a standardized way for agents to communicate and collaborate.</p> <ul> <li>It utilizes JSON-RPC 2.0 over HTTP(S) for structuring and transmitting messages.</li> <li>It allows agents to advertise their capabilities and be found by others through Agent Cards.</li> <li>It outlines workflows for initiating, progressing, and completing tasks.</li> <li>It facilitates the exchange of text, files, and structured data.</li> <li>It offers guidelines for secure communication and managing long-running tasks.</li> </ul>"},{"location":"tutorials/#supported-languages-and-code-samples","title":"Supported Languages and Code Samples","text":"<p>The A2A Project currently hosts SDKs in four languages (Python, JS, Java, .NET) and contributors are adding more, including Go.</p> <p>The following table lists the supported languages and their stability.</p> Language Support Python Stable Java Stable JavaScript Stable C#/.NET Stable Go In Progress <p>The A2A project provides numerous samples across supported languages in the a2a-samples repository</p>"},{"location":"tutorials/#python","title":"Python","text":"<ul> <li>Follow the A2A Python Introduction Tutorial</li> <li>For additional Python samples, see the following:<ul> <li>ADK Facts</li> <li>ADK agent on Cloud Run</li> <li>Airbnb and weather multiagent</li> </ul> </li> </ul>"},{"location":"tutorials/#java","title":"Java","text":"<ul> <li>For a multi-language translator agent using Java, see Java samples.</li> </ul>"},{"location":"tutorials/#javascript","title":"JavaScript","text":"<ul> <li>For a movie research agent using JavaScript, see JavaScript samples.</li> </ul>"},{"location":"tutorials/#cnet","title":"C#/.NET","text":"<ul> <li>For all .NET samples, see .NET samples.</li> </ul>"},{"location":"tutorials/python/1-introduction/","title":"Python Quickstart Tutorial: Building an A2A Agent","text":"<p>Welcome to the Agent2Agent (A2A) Python Quickstart Tutorial!</p> <p>In this tutorial, you will explore a simple \"echo\" A2A server using the Python SDK. This will introduce you to the fundamental concepts and components of an A2A server. You will then look at a more advanced example that integrates a Large Language Model (LLM).</p> <p>This hands-on guide will help you understand:</p> <ul> <li>The basic concepts behind the A2A protocol.</li> <li>How to set up a Python environment for A2A development using the SDK.</li> <li>How Agent Skills and Agent Cards describe an agent.</li> <li>How an A2A server handles tasks.</li> <li>How to interact with an A2A server using a client.</li> <li>How streaming capabilities and multi-turn interactions work.</li> <li>How an LLM can be integrated into an A2A agent.</li> </ul> <p>By the end of this tutorial, you will have a functional understanding of A2A agents and a solid foundation for building or integrating A2A-compliant applications.</p>"},{"location":"tutorials/python/1-introduction/#tutorial-sections","title":"Tutorial Sections","text":"<p>The tutorial is broken down into the following steps:</p> <ol> <li>Introduction (This Page)</li> <li>Setup: Prepare your Python environment and the A2A SDK.</li> <li>Agent Skills &amp; Agent Card: Define what your agent can do and how it describes itself.</li> <li>The Agent Executor: Understand how the agent logic is implemented.</li> <li>Starting the Server: Run the Helloworld A2A server.</li> <li>Interacting with the Server: Send requests to your agent.</li> <li>Streaming &amp; Multi-Turn Interactions: Explore advanced capabilities with the LangGraph example.</li> <li>Next Steps: Explore further possibilities with A2A.</li> </ol> <p>Let's get started!</p>"},{"location":"tutorials/python/2-setup/","title":"2. Setup Your Environment","text":""},{"location":"tutorials/python/2-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher.</li> <li>Access to a terminal or command prompt.</li> <li>Git, for cloning the repository.</li> <li>A code editor (e.g., Visual Studio Code) is recommended.</li> </ul>"},{"location":"tutorials/python/2-setup/#clone-the-repository","title":"Clone the Repository","text":"<p>If you haven't already, clone the A2A Samples repository:</p> <pre><code>git clone https://github.com/a2aproject/a2a-samples.git -b main --depth 1\ncd a2a-samples\n</code></pre>"},{"location":"tutorials/python/2-setup/#python-environment-sdk-installation","title":"Python Environment &amp; SDK Installation","text":"<p>We recommend using a virtual environment for Python projects. The A2A Python SDK uses <code>uv</code> for dependency management, but you can use <code>pip</code> with <code>venv</code> as well.</p> <ol> <li> <p>Create and activate a virtual environment:</p> <p>Using <code>venv</code> (standard library):</p> Mac/LinuxWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate\n</code></pre> </li> <li> <p>Install needed Python dependencies along with the A2A SDK and its dependencies:</p> <pre><code>pip install -r samples/python/requirements.txt\n</code></pre> </li> </ol>"},{"location":"tutorials/python/2-setup/#verify-installation","title":"Verify Installation","text":"<p>After installation, you should be able to import the <code>a2a</code> package in a Python interpreter:</p> <pre><code>python -c \"import a2a; print('A2A SDK imported successfully')\"\n</code></pre> <p>If this command runs without error and prints the success message, your environment is set up correctly.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/","title":"3. Agent Skills &amp; Agent Card","text":"<p>Before an A2A agent can do anything, it needs to define what it can do (its skills) and how other agents or clients can find out about these capabilities (its Agent Card).</p> <p>We'll use the <code>helloworld</code> example located in <code>a2a-samples/samples/python/agents/helloworld/</code>.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/#agent-skills","title":"Agent Skills","text":"<p>An Agent Skill describes a specific capability or function the agent can perform. It's a building block that tells clients what kinds of tasks the agent is good for.</p> <p>Key attributes of an <code>AgentSkill</code> (defined in <code>a2a.types</code>):</p> <ul> <li><code>id</code>: A unique identifier for the skill.</li> <li><code>name</code>: A human-readable name.</li> <li><code>description</code>: A more detailed explanation of what the skill does.</li> <li><code>tags</code>: Keywords for categorization and discovery.</li> <li><code>examples</code>: Sample prompts or use cases.</li> <li><code>inputModes</code> / <code>outputModes</code>: Supported Media Types for input and output (e.g., \"text/plain\", \"application/json\").</li> </ul> <p>In <code>__main__.py</code>, you can see how a skill for the Helloworld agent is defined:</p> <pre><code>skill = AgentSkill(\n    id='hello_world',\n    name='Returns hello world',\n    description='just returns hello world',\n    tags=['hello world'],\n    examples=['hi', 'hello world'],\n)\n</code></pre> <p>This skill is very simple: it's named \"Returns hello world\" and primarily deals with text.</p>"},{"location":"tutorials/python/3-agent-skills-and-card/#agent-card","title":"Agent Card","text":"<p>The Agent Card is a JSON document that an A2A Server makes available, typically at a <code>.well-known/agent-card.json</code> endpoint. It's like a digital business card for the agent.</p> <p>Key attributes of an <code>AgentCard</code> (defined in <code>a2a.types</code>):</p> <ul> <li><code>name</code>, <code>description</code>, <code>version</code>: Basic identity information.</li> <li><code>url</code>: The endpoint where the A2A service can be reached.</li> <li><code>capabilities</code>: Specifies supported A2A features like <code>streaming</code> or <code>pushNotifications</code>.</li> <li><code>defaultInputModes</code> / <code>defaultOutputModes</code>: Default Media Types for the agent.</li> <li><code>skills</code>: A list of <code>AgentSkill</code> objects that the agent offers.</li> </ul> <p>The <code>helloworld</code> example defines its Agent Card like this:</p> <pre><code># This will be the public-facing agent card\npublic_agent_card = AgentCard(\n    name='Hello World Agent',\n    description='Just a hello world agent',\n    url='http://localhost:9999/',\n    version='1.0.0',\n    default_input_modes=['text'],\n    default_output_modes=['text'],\n    capabilities=AgentCapabilities(streaming=True),\n    skills=[skill],  # Only the basic skill for the public card\n    supports_authenticated_extended_card=True,\n)\n</code></pre> <p>This card tells us the agent is named \"Hello World Agent\", runs at <code>http://localhost:9999/</code>, supports text interactions, and has the <code>hello_world</code> skill. It also indicates public authentication, meaning no specific credentials are required.</p> <p>Understanding the Agent Card is crucial because it's how a client discovers an agent and learns how to interact with it.</p>"},{"location":"tutorials/python/4-agent-executor/","title":"4. The Agent Executor","text":"<p>The core logic of how an A2A agent processes requests and generates responses/events is handled by an Agent Executor. The A2A Python SDK provides an abstract base class <code>a2a.server.agent_execution.AgentExecutor</code> that you implement.</p>"},{"location":"tutorials/python/4-agent-executor/#agentexecutor-interface","title":"<code>AgentExecutor</code> Interface","text":"<p>The <code>AgentExecutor</code> class defines two primary methods:</p> <ul> <li><code>async def execute(self, context: RequestContext, event_queue: EventQueue)</code>: Handles incoming requests that expect a response or a stream of events. It processes the user's input (available via <code>context</code>) and uses the <code>event_queue</code> to send back <code>Message</code>, <code>Task</code>, <code>TaskStatusUpdateEvent</code>, or <code>TaskArtifactUpdateEvent</code> objects.</li> <li><code>async def cancel(self, context: RequestContext, event_queue: EventQueue)</code>: Handles requests to cancel an ongoing task.</li> </ul> <p>The <code>RequestContext</code> provides information about the incoming request, such as the user's message and any existing task details. The <code>EventQueue</code> is used by the executor to send events back to the client.</p>"},{"location":"tutorials/python/4-agent-executor/#helloworld-agent-executor","title":"Helloworld Agent Executor","text":"<p>Let's look at <code>agent_executor.py</code>. It defines <code>HelloWorldAgentExecutor</code>.</p> <ol> <li> <p>The Agent (<code>HelloWorldAgent</code>):     This is a simple helper class that encapsulates the actual \"business logic\".</p> <pre><code>class HelloWorldAgent:\n    \"\"\"Hello World Agent.\"\"\"\n\n    async def invoke(self) -&gt; str:\n        return 'Hello World'\n</code></pre> <p>It has a simple <code>invoke</code> method that returns the string \"Hello World\".</p> </li> <li> <p>The Executor (<code>HelloWorldAgentExecutor</code>):     This class implements the <code>AgentExecutor</code> interface.</p> <ul> <li> <p><code>__init__</code>:</p> <pre><code>class HelloWorldAgentExecutor(AgentExecutor):\n    \"\"\"Test AgentProxy Implementation.\"\"\"\n\n    def __init__(self):\n        self.agent = HelloWorldAgent()\n</code></pre> <p>It instantiates the <code>HelloWorldAgent</code>.</p> </li> <li> <p><code>execute</code>:</p> <pre><code>async def execute(\n    self,\n    context: RequestContext,\n    event_queue: EventQueue,\n) -&gt; None:\n    result = await self.agent.invoke()\n    await event_queue.enqueue_event(new_agent_text_message(result))\n</code></pre> <p>When a <code>message/send</code> or <code>message/stream</code> request comes in (both are handled by <code>execute</code> in this simplified executor):</p> <ol> <li>It calls <code>self.agent.invoke()</code> to get the \"Hello World\" string.</li> <li>It creates an A2A <code>Message</code> object using the <code>new_agent_text_message</code> utility function.</li> <li>It enqueues this message onto the <code>event_queue</code>. The underlying <code>DefaultRequestHandler</code> will then process this queue to send the response(s) to the client. For a single message like this, it will result in a single response for <code>message/send</code> or a single event for <code>message/stream</code> before the stream closes.</li> </ol> </li> <li> <p><code>cancel</code>:     The Helloworld example's <code>cancel</code> method simply raises an exception, indicating that cancellation is not supported for this basic agent.</p> <pre><code>async def cancel(\n    self, context: RequestContext, event_queue: EventQueue\n) -&gt; None:\n    raise Exception('cancel not supported')\n</code></pre> </li> </ul> </li> </ol> <p>The <code>AgentExecutor</code> acts as the bridge between the A2A protocol (managed by the request handler and server application) and your agent's specific logic. It receives context about the request and uses an event queue to communicate results or updates back.</p>"},{"location":"tutorials/python/5-start-server/","title":"5. Starting the Server","text":"<p>Now that we have an Agent Card and an Agent Executor, we can set up and start the A2A server.</p> <p>The A2A Python SDK provides an <code>A2AStarletteApplication</code> class that simplifies running an A2A-compliant HTTP server. It uses Starlette for the web framework and is typically run with an ASGI server like Uvicorn.</p>"},{"location":"tutorials/python/5-start-server/#server-setup-in-helloworld","title":"Server Setup in Helloworld","text":"<p>Let's look at <code>__main__.py</code> again to see how the server is initialized and started.</p> <pre><code>import uvicorn\n\nfrom a2a.server.apps import A2AStarletteApplication\nfrom a2a.server.request_handlers import DefaultRequestHandler\nfrom a2a.server.tasks import InMemoryTaskStore\nfrom a2a.types import (\n    AgentCapabilities,\n    AgentCard,\n    AgentSkill,\n)\nfrom agent_executor import (\n    HelloWorldAgentExecutor,  # type: ignore[import-untyped]\n)\n\n\nif __name__ == '__main__':\n    skill = AgentSkill(\n        id='hello_world',\n        name='Returns hello world',\n        description='just returns hello world',\n        tags=['hello world'],\n        examples=['hi', 'hello world'],\n    )\n\n    extended_skill = AgentSkill(\n        id='super_hello_world',\n        name='Returns a SUPER Hello World',\n        description='A more enthusiastic greeting, only for authenticated users.',\n        tags=['hello world', 'super', 'extended'],\n        examples=['super hi', 'give me a super hello'],\n    )\n\n    # This will be the public-facing agent card\n    public_agent_card = AgentCard(\n        name='Hello World Agent',\n        description='Just a hello world agent',\n        url='http://localhost:9999/',\n        version='1.0.0',\n        default_input_modes=['text'],\n        default_output_modes=['text'],\n        capabilities=AgentCapabilities(streaming=True),\n        skills=[skill],  # Only the basic skill for the public card\n        supports_authenticated_extended_card=True,\n    )\n\n    # This will be the authenticated extended agent card\n    # It includes the additional 'extended_skill'\n    specific_extended_agent_card = public_agent_card.model_copy(\n        update={\n            'name': 'Hello World Agent - Extended Edition',  # Different name for clarity\n            'description': 'The full-featured hello world agent for authenticated users.',\n            'version': '1.0.1',  # Could even be a different version\n            # Capabilities and other fields like url, default_input_modes, default_output_modes,\n            # supports_authenticated_extended_card are inherited from public_agent_card unless specified here.\n            'skills': [\n                skill,\n                extended_skill,\n            ],  # Both skills for the extended card\n        }\n    )\n\n    request_handler = DefaultRequestHandler(\n        agent_executor=HelloWorldAgentExecutor(),\n        task_store=InMemoryTaskStore(),\n    )\n\n    server = A2AStarletteApplication(\n        agent_card=public_agent_card,\n        http_handler=request_handler,\n        extended_agent_card=specific_extended_agent_card,\n    )\n\n    uvicorn.run(server.build(), host='0.0.0.0', port=9999)\n</code></pre> <p>Let's break this down:</p> <ol> <li> <p><code>DefaultRequestHandler</code>:</p> <ul> <li>The SDK provides <code>DefaultRequestHandler</code>. This handler takes your <code>AgentExecutor</code> implementation (here, <code>HelloWorldAgentExecutor</code>) and a <code>TaskStore</code> (here, <code>InMemoryTaskStore</code>).</li> <li>It routes incoming A2A RPC calls to the appropriate methods on your executor (like <code>execute</code> or <code>cancel</code>).</li> <li>The <code>TaskStore</code> is used by the <code>DefaultRequestHandler</code> to manage the lifecycle of tasks, especially for stateful interactions, streaming, and resubscription. Even if your agent executor is simple, the handler needs a task store.</li> </ul> </li> <li> <p><code>A2AStarletteApplication</code>:</p> <ul> <li>The <code>A2AStarletteApplication</code> class is instantiated with the <code>agent_card</code> and the <code>request_handler</code> (referred to as <code>http_handler</code> in its constructor).</li> <li>The <code>agent_card</code> is crucial because the server will expose it at the <code>/.well-known/agent-card.json</code> endpoint (by default).</li> <li>The <code>request_handler</code> is responsible for processing all incoming A2A method calls by interacting with your <code>AgentExecutor</code>.</li> </ul> </li> <li> <p><code>uvicorn.run(server_app_builder.build(), ...)</code>:</p> <ul> <li>The <code>A2AStarletteApplication</code> has a <code>build()</code> method that constructs the actual Starlette application.</li> <li>This application is then run using <code>uvicorn.run()</code>, making your agent accessible over HTTP.</li> <li><code>host='0.0.0.0'</code> makes the server accessible on all network interfaces on your machine.</li> <li><code>port=9999</code> specifies the port to listen on. This matches the <code>url</code> in the <code>AgentCard</code>.</li> </ul> </li> </ol>"},{"location":"tutorials/python/5-start-server/#running-the-helloworld-server","title":"Running the Helloworld Server","text":"<p>Navigate to the <code>a2a-samples</code> directory in your terminal (if you're not already there) and ensure your virtual environment is activated.</p> <p>To run the Helloworld server:</p> <pre><code># from the a2a-samples directory\npython samples/python/agents/helloworld/__main__.py\n</code></pre> <p>You should see output similar to this, indicating the server is running:</p> <pre><code>INFO:     Started server process [xxxxx]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:9999 (Press CTRL+C to quit)\n</code></pre> <p>Your A2A Helloworld agent is now live and listening for requests! In the next step, we'll interact with it.</p>"},{"location":"tutorials/python/6-interact-with-server/","title":"6. Interacting with the Server","text":"<p>With the Helloworld A2A server running, let's send some requests to it. The SDK includes a client (<code>A2AClient</code>) that simplifies these interactions.</p>"},{"location":"tutorials/python/6-interact-with-server/#the-helloworld-test-client","title":"The Helloworld Test Client","text":"<p>The <code>test_client.py</code> script demonstrates how to:</p> <ol> <li>Fetch the Agent Card from the server.</li> <li>Create an <code>A2AClient</code> instance.</li> <li>Send both non-streaming (<code>message/send</code>) and streaming (<code>message/stream</code>) requests.</li> </ol> <p>Open a new terminal window, activate your virtual environment, and navigate to the <code>a2a-samples</code> directory.</p> <p>Activate virtual environment (Be sure to do this in the same directory where you created the virtual environment):</p> Mac/LinuxWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>Run the test client:</p> <pre><code># from the a2a-samples directory\npython samples/python/agents/helloworld/test_client.py\n</code></pre>"},{"location":"tutorials/python/6-interact-with-server/#understanding-the-client-code","title":"Understanding the Client Code","text":"<p>Let's look at key parts of <code>test_client.py</code>:</p> <ol> <li> <p>Fetching the Agent Card &amp; Initializing the Client:</p> <pre><code>base_url = 'http://localhost:9999'\n\nasync with httpx.AsyncClient() as httpx_client:\n    # Initialize A2ACardResolver\n    resolver = A2ACardResolver(\n        httpx_client=httpx_client,\n        base_url=base_url,\n        # agent_card_path uses default, extended_agent_card_path also uses default\n    )\n</code></pre> <p>The <code>A2ACardResolver</code> class is a convenience. It first fetches the <code>AgentCard</code> from the server's <code>/.well-known/agent-card.json</code> endpoint (based on the provided base URL) and then initializes the client with it.</p> </li> <li> <p>Sending a Non-Streaming Message (<code>send_message</code>):</p> <pre><code>client = A2AClient(\n    httpx_client=httpx_client, agent_card=final_agent_card_to_use\n)\nlogger.info('A2AClient initialized.')\n\nsend_message_payload: dict[str, Any] = {\n    'message': {\n        'role': 'user',\n        'parts': [\n            {'kind': 'text', 'text': 'how much is 10 USD in INR?'}\n        ],\n        'messageId': uuid4().hex,\n    },\n}\nrequest = SendMessageRequest(\n    id=str(uuid4()), params=MessageSendParams(**send_message_payload)\n)\n\nresponse = await client.send_message(request)\nprint(response.model_dump(mode='json', exclude_none=True))\n</code></pre> <ul> <li>The <code>send_message_payload</code> constructs the data for <code>MessageSendParams</code>.</li> <li>This is wrapped in a <code>SendMessageRequest</code>.</li> <li>It includes a <code>message</code> object with the <code>role</code> set to \"user\" and the content in <code>parts</code>.</li> <li>The Helloworld agent's <code>execute</code> method will enqueue a single \"Hello World\" message. The <code>DefaultRequestHandler</code> will retrieve this and send it as the response.</li> <li>The <code>response</code> will be a <code>SendMessageResponse</code> object, which contains either a <code>SendMessageSuccessResponse</code> (with the agent's <code>Message</code> as the result) or a <code>JSONRPCErrorResponse</code>.</li> </ul> </li> <li> <p>Handling Task IDs (Illustrative Note for Helloworld):</p> <p>The Helloworld client (<code>test_client.py</code>) doesn't attempt <code>get_task</code> or <code>cancel_task</code> directly because the simple Helloworld agent's <code>execute</code> method, when called via <code>message/send</code>, results in the <code>DefaultRequestHandler</code> returning a direct <code>Message</code> response rather than a <code>Task</code> object. More complex agents that explicitly manage tasks (like the LangGraph example) would return a <code>Task</code> object from <code>message/send</code>, and its <code>id</code> could then be used for <code>get_task</code> or <code>cancel_task</code>.</p> </li> <li> <p>Sending a Streaming Message (<code>send_message_streaming</code>):</p> <pre><code>streaming_request = SendStreamingMessageRequest(\n    id=str(uuid4()), params=MessageSendParams(**send_message_payload)\n)\n\nstream_response = client.send_message_streaming(streaming_request)\n\nasync for chunk in stream_response:\n    print(chunk.model_dump(mode='json', exclude_none=True))\n</code></pre> <ul> <li>This method calls the agent's <code>message/stream</code> endpoint. The <code>DefaultRequestHandler</code> will invoke the <code>HelloWorldAgentExecutor.execute</code> method.</li> <li>The <code>execute</code> method enqueues one \"Hello World\" message, and then the event queue is closed.</li> <li>The client will receive this single message as one <code>SendStreamingMessageResponse</code> event, and then the stream will terminate.</li> <li>The <code>stream_response</code> is an <code>AsyncGenerator</code>.</li> </ul> </li> </ol>"},{"location":"tutorials/python/6-interact-with-server/#expected-output","title":"Expected Output","text":"<p>When you run <code>test_client.py</code>, you'll see JSON outputs for:</p> <ul> <li>The non-streaming response (a single \"Hello World\" message).</li> <li>The streaming response (a single \"Hello World\" message as one chunk, after which the stream ends).</li> </ul> <p>The <code>id</code> fields in the output will vary with each run.</p> <pre><code>// Non-streaming response\n{\"jsonrpc\":\"2.0\",\"id\":\"xxxxxxxx\",\"result\":{\"type\":\"message\",\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Hello World\"}],\"messageId\":\"yyyyyyyy\"}}\n// Streaming response (one chunk)\n{\"jsonrpc\":\"2.0\",\"id\":\"zzzzzzzz\",\"result\":{\"type\":\"message\",\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Hello World\"}],\"messageId\":\"wwwwwwww\",\"final\":true}}\n</code></pre> <p>(Actual IDs like <code>xxxxxxxx</code>, <code>yyyyyyyy</code>, <code>zzzzzzzz</code>, <code>wwwwwwww</code> will be different UUIDs/request IDs)</p> <p>This confirms your server is correctly handling basic A2A interactions with the updated SDK structure!</p> <p>Now you can shut down the server by typing Ctrl+C in the terminal window where <code>__main__.py</code> is running.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/","title":"7. Streaming &amp; Multi-Turn Interactions (LangGraph Example)","text":"<p>The Helloworld example demonstrates the basic mechanics of A2A. For more advanced features like robust streaming, task state management, and multi-turn conversations powered by an LLM, we'll turn to the LangGraph example located in <code>a2a-samples/samples/python/agents/langgraph/</code>.</p> <p>This example features a \"Currency Agent\" that uses the Gemini model via LangChain and LangGraph to answer currency conversion questions.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#setting-up-the-langgraph-example","title":"Setting up the LangGraph Example","text":"<ol> <li> <p>Create a Gemini API Key, if you don't already have one.</p> </li> <li> <p>Environment Variable:</p> <p>Create a <code>.env</code> file in the <code>a2a-samples/samples/python/agents/langgraph/</code> directory:</p> <pre><code>echo \"GOOGLE_API_KEY=YOUR_API_KEY_HERE\" &gt; .env\n</code></pre> <p>Replace <code>YOUR_API_KEY_HERE</code> with your actual Gemini API key.</p> </li> <li> <p>Install Dependencies (if not already covered):</p> <p>The <code>langgraph</code> example has its own <code>pyproject.toml</code> which includes dependencies like <code>langchain-google-genai</code> and <code>langgraph</code>. When you installed the SDK from the <code>a2a-samples</code> root using <code>pip install -e .[dev]</code>, this should have also installed the dependencies for the workspace examples, including <code>langgraph-example</code>. If you encounter import errors, ensure your primary SDK installation from the root directory was successful.</p> </li> </ol>"},{"location":"tutorials/python/7-streaming-and-multiturn/#running-the-langgraph-server","title":"Running the LangGraph Server","text":"<p>Navigate to the <code>a2a-samples/samples/python/agents/langgraph/app</code> directory in your terminal and ensure your virtual environment (from the SDK root) is activated.</p> <p>Start the LangGraph agent server:</p> <pre><code>python __main__.py\n</code></pre> <p>This will start the server, usually on <code>http://localhost:10000</code>.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#interacting-with-the-langgraph-agent","title":"Interacting with the LangGraph Agent","text":"<p>Open a new terminal window, activate your virtual environment, and navigate to <code>a2a-samples/samples/python/agents/langgraph/app</code>.</p> <p>Run its test client:</p> <pre><code>python test_client.py\n</code></pre> <p>Now, you can shut down the server by typing Ctrl+C in the terminal window where <code>__main__.py</code> is running.</p>"},{"location":"tutorials/python/7-streaming-and-multiturn/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The <code>langgraph</code> example showcases several important A2A concepts:</p> <ol> <li> <p>LLM Integration:</p> <ul> <li><code>agent.py</code> defines <code>CurrencyAgent</code>. It uses <code>ChatGoogleGenerativeAI</code> and LangGraph's <code>create_react_agent</code> to process user queries.</li> <li>This demonstrates how a real LLM can power the agent's logic.</li> </ul> </li> <li> <p>Task State Management:</p> <ul> <li> <p><code>samples/langgraph/__main__.py</code> initializes a <code>DefaultRequestHandler</code> with an <code>InMemoryTaskStore</code>.</p> <pre><code>httpx_client = httpx.AsyncClient()\npush_config_store = InMemoryPushNotificationConfigStore()\npush_sender = BasePushNotificationSender(httpx_client=httpx_client,\n                config_store=push_config_store)\nrequest_handler = DefaultRequestHandler(\n    agent_executor=CurrencyAgentExecutor(),\n    task_store=InMemoryTaskStore(),\n    push_config_store=push_config_store,\n    push_sender= push_sender\n)\nserver = A2AStarletteApplication(\n    agent_card=agent_card, http_handler=request_handler\n)\n\nuvicorn.run(server.build(), host=host, port=port)\n</code></pre> </li> <li> <p>The <code>CurrencyAgentExecutor</code> (in <code>samples/langgraph/agent_executor.py</code>), when its <code>execute</code> method is called by the <code>DefaultRequestHandler</code>, interacts with the <code>RequestContext</code> which contains the current task (if any).</p> </li> <li>For <code>message/send</code>, the <code>DefaultRequestHandler</code> uses the <code>TaskStore</code> to persist and retrieve task state across interactions. The response to <code>message/send</code> will be a full <code>Task</code> object if the agent's execution flow involves multiple steps or results in a persistent task.</li> <li>The <code>test_client.py</code>'s <code>run_single_turn_test</code> demonstrates getting a <code>Task</code> object back and then querying it using <code>get_task</code>.</li> </ul> </li> <li> <p>Streaming with <code>TaskStatusUpdateEvent</code> and <code>TaskArtifactUpdateEvent</code>:</p> <ul> <li>The <code>execute</code> method in <code>CurrencyAgentExecutor</code> is responsible for handling both non-streaming and streaming requests, orchestrated by the <code>DefaultRequestHandler</code>.</li> <li>As the LangGraph agent processes the request (which might involve calling tools like <code>get_exchange_rate</code>), the <code>CurrencyAgentExecutor</code> enqueues different types of events onto the <code>EventQueue</code>:<ul> <li><code>TaskStatusUpdateEvent</code>: For intermediate updates (e.g., \"Looking up exchange rates...\", \"Processing the exchange rates..\"). The <code>final</code> flag on these events is <code>False</code>.</li> <li><code>TaskArtifactUpdateEvent</code>: When the final answer is ready, it's enqueued as an artifact. The <code>lastChunk</code> flag is <code>True</code>.</li> <li>A final <code>TaskStatusUpdateEvent</code> with <code>state=TaskState.completed</code> and <code>final=True</code> is sent to signify the end of the task for streaming.</li> </ul> </li> <li>The <code>test_client.py</code>'s <code>run_streaming_test</code> function will print these individual event chunks as they are received from the server.</li> </ul> </li> <li> <p>Multi-Turn Conversation (<code>TaskState.input_required</code>):</p> <ul> <li>The <code>CurrencyAgent</code> can ask for clarification if a query is ambiguous (e.g., user asks \"how much is 100 USD?\").</li> <li>When this happens, the <code>CurrencyAgentExecutor</code> will enqueue a <code>TaskStatusUpdateEvent</code> where <code>status.state</code> is <code>TaskState.input_required</code> and <code>status.message</code> contains the agent's question (e.g., \"To which currency would you like to convert?\"). This event will have <code>final=True</code> for the current interaction stream.</li> <li>The <code>test_client.py</code>'s <code>run_multi_turn_test</code> function demonstrates this:<ul> <li>It sends an initial ambiguous query.</li> <li>The agent responds (via the <code>DefaultRequestHandler</code> processing the enqueued events) with a <code>Task</code> whose status is <code>input_required</code>.</li> <li>The client then sends a second message, including the <code>taskId</code> and <code>contextId</code> from the first turn's <code>Task</code> response, to provide the missing information (\"in GBP\"). This continues the same task.</li> </ul> </li> </ul> </li> </ol>"},{"location":"tutorials/python/7-streaming-and-multiturn/#exploring-the-code","title":"Exploring the Code","text":"<p>Take some time to look through these files:</p> <ul> <li><code>__main__.py</code>: Server setup using <code>A2AStarletteApplication</code> and <code>DefaultRequestHandler</code>. Note the <code>AgentCard</code> definition includes <code>capabilities.streaming=True</code>.</li> <li><code>agent.py</code>: The <code>CurrencyAgent</code> with LangGraph, LLM model, and tool definitions.</li> <li><code>agent_executor.py</code>: The <code>CurrencyAgentExecutor</code> implementing the <code>execute</code> (and <code>cancel</code>) method. It uses the <code>RequestContext</code> to understand the ongoing task and the <code>EventQueue</code> to send back various events (<code>TaskStatusUpdateEvent</code>, <code>TaskArtifactUpdateEvent</code>, new <code>Task</code> object implicitly via the first event if no task exists).</li> <li><code>test_client.py</code>: Demonstrates various interaction patterns, including retrieving task IDs and using them for multi-turn conversations.</li> </ul> <p>This example provides a much richer illustration of how A2A facilitates complex, stateful, and asynchronous interactions between agents.</p>"},{"location":"tutorials/python/8-next-steps/","title":"Next Steps","text":"<p>Congratulations on completing the A2A Python SDK Tutorial! You've learned how to:</p> <ul> <li>Set up your environment for A2A development.</li> <li>Define Agent Skills and Agent Cards using the SDK's types.</li> <li>Implement a basic HelloWorld A2A server and client.</li> <li>Understand and implement streaming capabilities.</li> <li>Integrate a more complex agent using LangGraph, demonstrating task state management and tool use.</li> </ul> <p>You now have a solid foundation for building and integrating your own A2A-compliant agents.</p>"},{"location":"tutorials/python/8-next-steps/#where-to-go-from-here","title":"Where to Go From Here?","text":"<p>Here are some ideas and resources to continue your A2A journey:</p> <ul> <li>Explore Other Examples:<ul> <li>Check out the other examples in the a2a-samples GitHub repository for more complex agent integrations and features.</li> </ul> </li> <li>Deepen Your Protocol Understanding:<ul> <li>\ud83d\udcda Read the complete A2A Protocol Documentation site for a comprehensive overview.</li> <li>\ud83d\udcdd Review the detailed A2A Protocol Specification to understand the nuances of all data structures and RPC methods.</li> </ul> </li> <li>Review Key A2A Topics:<ul> <li>A2A and MCP: Understand how A2A complements the Model Context Protocol for tool usage.</li> <li>Enterprise-Ready Features: Learn about security, observability, and other enterprise considerations.</li> <li>Streaming &amp; Asynchronous Operations: Get more details on SSE and push notifications.</li> <li>Agent Discovery: Explore different ways agents can find each other.</li> </ul> </li> <li>Build Your Own Agent:<ul> <li>Try creating a new A2A agent using your favorite Python agent framework (like LangChain, CrewAI, AutoGen, Semantic Kernel, or a custom solution).</li> <li>Implement the <code>a2a.server.AgentExecutor</code> interface to bridge your agent's logic with the A2A protocol.</li> <li>Think about what unique skills your agent could offer and how its Agent Card would represent them.</li> </ul> </li> <li>Experiment with Advanced Features:<ul> <li>Implement robust task management with a persistent <code>TaskStore</code> if your agent handles long-running or multi-session tasks.</li> <li>Explore implementing push notifications if your agent's tasks are very long-lived.</li> <li>Consider more complex input and output modalities (e.g., handling file uploads/downloads, or structured data via <code>DataPart</code>).</li> </ul> </li> <li>Contribute to the A2A Community:<ul> <li>Join the discussions on the A2A GitHub Discussions page.</li> <li>Report issues or suggest improvements via GitHub Issues.</li> <li>Consider contributing code, examples, or documentation. See the CONTRIBUTING.md guide.</li> </ul> </li> </ul> <p>The A2A protocol aims to foster an ecosystem of interoperable AI agents. By building and sharing A2A-compliant agents, you can be a part of this exciting development!</p>"}]}