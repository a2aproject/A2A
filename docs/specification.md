# Agent2Agent (A2A) Protocol Official Specification

{% macro render_spec_tabs(region_tag) %}
=== "JSON-RPC"

    ```ts { .no-copy }
    --8<-- "types/src/types.ts:{{ region_tag }}"
    ```

=== "gRPC"

    ```proto { .no-copy }
    --8<-- "specification/grpc/a2a.proto:{{ region_tag }}"
    ```
{% endmacro %}

??? note "**Latest Released Version** [`0.3.0`](https://a2a-protocol.org/v0.3.0/specification)"

    **Previous Versions**

    - [`0.2.6`](https://a2a-protocol.org/v0.2.6/specification)
    - [`0.2.5`](https://a2a-protocol.org/v0.2.5/specification)
    - [`0.2.4`](https://a2a-protocol.org/v0.2.4/specification)
    - [`0.2.0`](https://a2a-protocol.org/v0.2.0/specification)
    - [`0.1.0`](https://a2a-protocol.org/v0.1.0/specification)

See [Release Notes](https://github.com/a2aproject/A2A/releases) for changes made between versions.

## 1. Introduction

The Agent2Agent (A2A) Protocol is an open standard designed to facilitate communication and interoperability between independent, potentially opaque AI agent systems. In an ecosystem where agents might be built using different frameworks, languages, or by different vendors, A2A provides a common language and interaction model.

This document provides the detailed technical specification for the A2A protocol. Its primary goal is to enable agents to:

- Discover each other's capabilities.
- Negotiate interaction modalities (text, files, structured data).
- Manage collaborative tasks.
- Securely exchange information to achieve user goals **without needing access to each other's internal state, memory, or tools.**

### 1.1. Key Goals of A2A

- **Interoperability:** Bridge the communication gap between disparate agentic systems.
- **Collaboration:** Enable agents to delegate tasks, exchange context, and work together on complex user requests.
- **Discovery:** Allow agents to dynamically find and understand the capabilities of other agents.
- **Flexibility:** Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.
- **Security:** Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.
- **Asynchronicity:** Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.

### 1.2. Guiding Principles

- **Simple:** Reuse existing, well-understood standards (HTTP, JSON-RPC 2.0, Server-Sent Events).
- **Enterprise Ready:** Address authentication, authorization, security, privacy, tracing, and monitoring by aligning with established enterprise practices.
- **Async First:** Designed for (potentially very) long-running tasks and human-in-the-loop interactions.
- **Modality Agnostic:** Support exchange of diverse content types including text, audio/video (via file references), structured data/forms, and potentially embedded UI components (e.g., iframes referenced in parts).
- **Opaque Execution:** Agents collaborate based on declared capabilities and exchanged information, without needing to share their internal thoughts, plans, or tool implementations.

For a broader understanding of A2A's purpose and benefits, see [What is A2A?](./topics/what-is-a2a.md).

## 2. Core Concepts Summary

A2A revolves around several key concepts. For detailed explanations, please refer to the [Key Concepts guide](./topics/key-concepts.md).

- **A2A Client:** An application or agent that initiates requests to an A2A Server on behalf of a user or another system.
- **A2A Server (Remote Agent):** An agent or agentic system that exposes an A2A-compliant endpoint, processing tasks and providing responses.
- **Agent Card:** A JSON metadata document published by an A2A Server, describing its identity, capabilities, skills, service endpoint, and authentication requirements.
- **Message:** A communication turn between a client and a remote agent, having a `role` ("user" or "agent") and containing one or more `Parts`.
- **Task:** The fundamental unit of work managed by A2A, identified by a unique ID. Tasks are stateful and progress through a defined lifecycle.
- **Part:** The smallest unit of content within a Message or Artifact (e.g., `TextPart`, `FilePart`, `DataPart`).
- **Artifact:** An output (e.g., a document, image, structured data) generated by the agent as a result of a task, composed of `Parts`.
- **Streaming:** Real-time, incremental updates for tasks (status changes, artifact chunks) delivered via protocol-specific streaming mechanisms.
- **Push Notifications:** Asynchronous task updates delivered via server-initiated HTTP POST requests to a client-provided webhook URL, for long-running or disconnected scenarios.
- **Context:** An optional, server-generated identifier to logically group related tasks.
- **Extension:** A mechanism for agents to provide additional functionality or data beyond the core A2A specification.

## 3. A2A Protocol Operations

This section describes the core operations of the A2A protocol in a transport-independent manner. These operations define the fundamental capabilities that all A2A implementations must support, regardless of the underlying transport mechanism.

### 3.1. Core Operations

#### 3.1.1. Send Message

The primary operation for initiating agent interactions. Clients send a message to an agent and receive either a task that tracks the processing or a direct response message.

**Inputs:**

- [`Message`](#414-message): The message containing user input (required)
- [`MessageSendConfiguration`](#331-messagesendconfiguration): Configuration for the send request (optional)
- `metadata`: Optional metadata for the request (optional)

**Outputs:**

- [`Task`](#411-task): A task object representing the processing of the message, OR
- [`Message`](#414-message): A direct response message (for simple interactions that don't require task tracking)

**Behavior:**

The agent MAY create a new task to process the provided message asynchronously or MAY return a direct message response for simple interactions. The operation MUST return immediately with either task information or response message. Task processing MAY continue asynchronously after the response when a [`Task`](#411-task) is returned.

**Transport Implementations:**

- **JSON-RPC**: [`message/send`](#931-messagesend)
- **gRPC**: [`SendMessage`](#1031-sendmessage)
- **HTTP/REST**: [`POST /v1/message:send`](#1121-message-operations)

#### 3.1.2. Stream Message

Similar to Send Message but with real-time streaming of updates during processing.

**Inputs:**

- [`Message`](#414-message): The message containing user input (required)
- [`MessageSendConfiguration`](#331-messagesendconfiguration): Configuration for the send request (optional)
- `metadata`: Optional metadata for the request (optional)

**Outputs:**

- Initial response: [`Task`](#411-task) object OR [`Message`](#414-message) object
- Subsequent events following a `Task` MAY include stream of [`TaskStatusUpdateEvent`](#421-taskstatusupdateevent) and [`TaskArtifactUpdateEvent`](#422-taskartifactupdateevent) objects
- Final completion indicator

**Behavior:**

The operation MUST establish a streaming connection for real-time updates. The agent MAY return a [`Task`](#411-task) for complex processing with status/artifact updates or MAY return a [`Message`](#414-message) for direct streaming responses without task overhead. The implementation MUST provide immediate feedback on progress and intermediate results. The stream MUST terminate when processing reaches a final state.

**Transport Implementations:**

- **JSON-RPC**: [`message/stream`](#932-messagestream)
- **gRPC**: [`SendStreamingMessage`](#1032-sendstreamingmessage)
- **HTTP/REST**: [`POST /v1/message:stream`](#1121-message-operations)

#### 3.1.3. Get Task

Retrieves current information about an existing task.

**Inputs:**

- `taskId`: Unique identifier of the task to retrieve

**Outputs:**

- [`Task`](#411-task): Current state and artifacts of the requested task

**Behavior:**

The operation MUST return the current task state and any available artifacts. This operation SHOULD be used to support polling-based clients that don't use streaming.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/get`](#933-tasksget)
- **gRPC**: [`GetTask`](#1033-gettask)
- **HTTP/REST**: [`GET /v1/tasks/{id}`](#1122-task-operations)

#### 3.1.4. List Tasks

Retrieves a list of tasks associated with the current client session or context.

**Inputs:**

- `contextId` (optional): Filter tasks by context ID to get tasks from a specific conversation or session
- `status` (optional): Filter tasks by their current status state
- `pageSize` (optional): Maximum number of tasks to return (must be between 1 and 100, defaults to 50)
- `pageToken` (optional): Token for pagination from a previous response
- `historyLength` (optional): Number of recent messages to include in each task's history (defaults to 0)
- `lastUpdatedAfter` (optional): Filter tasks updated after this timestamp (milliseconds since epoch)
- `includeArtifacts` (optional): Whether to include artifacts in returned tasks (defaults to false)

**Outputs:**

- Array of [`Task`](#411-task) objects
- Pagination information including `nextPageToken` for retrieving additional results

**Behavior:**

The operation MUST return only tasks visible to the authenticated client and MUST use cursor-based pagination for performance and consistency. Tasks MUST be sorted by last update time in descending order. Implementations MUST implement appropriate authorization scoping to ensure clients can only access authorized tasks.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/list`](#934-taskslist)
- **gRPC**: [`ListTasks`](#1034-listtasks)
- **HTTP/REST**: [`GET /v1/tasks`](#1122-task-operations)

#### 3.1.5. Cancel Task

Requests cancellation of an active task.

**Inputs:**

- `taskId`: Unique identifier of the task to cancel

**Outputs:**

- Updated [`Task`](#411-task) with cancellation status

**Behavior:**

The operation SHOULD attempt to stop task processing and MUST return the updated task state. Success depends on the task's current state and agent capabilities. The agent MAY refuse cancellation for tasks that cannot be safely interrupted.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/cancel`](#935-taskscancel)
- **gRPC**: [`CancelTask`](#103-core-methods)
- **HTTP/REST**: [`POST /v1/tasks/{id}:cancel`](#1122-task-operations)

#### 3.1.6. Resubscribe to Task
<span id="79-tasksresubscribe"></span><span id="1035-taskresubscription"></span>

Establishes a streaming connection to resume receiving updates for a specific task that was originally created by a streaming operation.

**Inputs:**

- `taskId`: Unique identifier of the task to monitor

**Outputs:**

- Initial response: [`Task`](#411-task) object with current state
- Stream of [`TaskStatusUpdateEvent`](#421-taskstatusupdateevent) and [`TaskArtifactUpdateEvent`](#422-taskartifactupdateevent) objects

**Behavior:**

The operation MUST enable real-time monitoring of task progress but can only be used with tasks created by `message/stream` operations, not `message/send`. This operation SHOULD be used for reconnecting to previously created streaming tasks after connection interruption. The stream MUST terminate when the task reaches a final state.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/resubscribe`](#936-tasksresubscribe)
- **gRPC**: [`TaskResubscription`](#1035-taskresubscription)
- **HTTP/REST**: [`POST /v1/tasks/{id}:resubscribe`](#1122-task-operations)

#### 3.1.7. Get Agent Card

Retrieves the agent's capability and configuration information.

**Inputs:**

- None (operates on authenticated agent context)

**Outputs:**

- [`AgentCard`](#441-agentcard): Complete agent metadata including capabilities, supported transports, and authentication schemes

**Behavior:**

The operation MUST return public agent information and MAY include different details based on client authentication level. This operation is essential for agent discovery and capability negotiation.

**Transport Implementations:**

- **JSON-RPC**: [`agent/getAuthenticatedExtendedCard`](#938-agentgetauthenticatedextendedcard)
- **gRPC**: [`GetAgentCard`](#103-core-methods)
- **HTTP/REST**: [`GET /v1/card`](#1124-agent-card)

#### 3.1.8. Create Push Notification Config
<span id="75-taskspushnotificationconfigset"></span>

Creates a push notification configuration for a task to receive asynchronous updates.

**Inputs:**

- `taskId`: Unique identifier of the task to configure notifications for
- [`PushNotificationConfig`](#431-pushnotificationconfig): Configuration specifying webhook URL and notification preferences

**Outputs:**

- [`TaskPushNotificationConfig`](#432-taskpushnotificationconfig): Created configuration with assigned ID

**Behavior:**

The operation MUST establish a webhook endpoint for task completion notifications and is only available if the agent supports push notifications capability. The configuration MUST persist until task completion or explicit deletion.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/pushNotificationConfig/set`](#937-push-notification-configuration-methods)
- **gRPC**: [`CreateTaskPushNotificationConfig`](#grpc-push-notification-operations)
 - **HTTP/REST**: [`POST /v1/tasks/{id}/pushNotificationConfigs`](#1123-push-notification-configuration)
 <span id="tasks-push-notification-config-operations"></span><span id="grpc-push-notification-operations"></span><span id="push-notification-operations"></span>

#### 3.1.9. Get Push Notification Config
<span id="76-taskspushnotificationconfigget"></span>

Retrieves an existing push notification configuration for a task.

**Inputs:**

- `taskId`: Unique identifier of the task
- `configId`: Unique identifier of the push notification configuration

**Outputs:**

- [`TaskPushNotificationConfig`](#432-taskpushnotificationconfig): The requested configuration

**Behavior:**

The operation MUST return configuration details including webhook URL and notification settings. The operation MUST fail if the configuration does not exist or the client lacks access.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/pushNotificationConfig/get`](#937-push-notification-configuration-methods)
- **gRPC**: [`GetTaskPushNotificationConfig`](#grpc-push-notification-operations)
- **HTTP/REST**: [`GET /v1/tasks/{id}/pushNotificationConfigs/{configId}`](#1123-push-notification-configuration)

#### 3.1.10. List Push Notification Configs

Retrieves all push notification configurations for a task.

**Inputs:**

- `taskId`: Unique identifier of the task

**Outputs:**

- Array of [`TaskPushNotificationConfig`](#432-taskpushnotificationconfig) objects

**Behavior:**

The operation MUST return all active push notification configurations for the specified task and MAY support pagination for tasks with many configurations.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/pushNotificationConfig/list`](#937-push-notification-configuration-methods)
- **gRPC**: [`ListTaskPushNotificationConfig`](#grpc-push-notification-operations)
- **HTTP/REST**: [`GET /v1/tasks/{id}/pushNotificationConfigs`](#1123-push-notification-configuration)

#### 3.1.11. Delete Push Notification Config

Removes a push notification configuration for a task.

**Inputs:**

- `taskId`: Unique identifier of the task
- `configId`: Unique identifier of the push notification configuration to delete

**Outputs:**

- Confirmation of deletion (implementation-specific)

**Behavior:**

The operation MUST permanently remove the specified push notification configuration. No further notifications will be sent to the configured webhook after deletion. This operation MUST be idempotent - multiple deletions of the same config have the same effect.

**Transport Implementations:**

- **JSON-RPC**: [`tasks/pushNotificationConfig/delete`](#937-push-notification-configuration-methods)
- **gRPC**: [`DeleteTaskPushNotificationConfig`](#grpc-push-notification-operations)
- **HTTP/REST**: [`DELETE /v1/tasks/{id}/pushNotificationConfigs/{configId}`](#1123-push-notification-configuration)

### 3.2. Operation Semantics

#### 3.2.1. Idempotency

- **Get operations** (Get Task, List Tasks, Get Agent Card) are naturally idempotent
- **Send Message** operations are **NOT** idempotent - each call creates a new task
- **Cancel Task** operations are idempotent - multiple cancellation requests have the same effect

#### 3.2.2. Error Handling

All operations may return errors in the following categories:

- **Authentication Errors**: Invalid or missing credentials
- **Authorization Errors**: Insufficient permissions for requested operation
- **Validation Errors**: Invalid input parameters or message format
- **Resource Errors**: Requested task not found or not accessible
- **System Errors**: Internal agent failures or temporary unavailability

#### 3.2.3. Asynchronous Processing

- [`Task`](#411-task) objects represent asynchronous work units
- Operations return immediately with task information
- Clients must poll or stream to get completion status
- Agents may continue processing after initial response

### 3.3. Operation Parameter Objects

This section defines common parameter objects used across multiple operations.

#### 3.3.1. MessageSendConfiguration

Configuration for send message requests.

```proto
--8<-- "specification/grpc/a2a.proto:MessageSendConfiguration"
```

### 3.3.2. Metadata

A flexible key-value map for passing additional context or parameters with operations. Metadata keys and are strings and values can be any valid value that can be represented in JSON. [`Extensions`](#extensions) can be used to strongly type metadata values for specific use cases.

### 3.4. Multi-Turn Interactions

The A2A protocol supports multi-turn conversations through task context:

1. **Context Continuity**: [`Task`](#411-task) objects maintain conversation context through `contextId`
2. **Input Required State**: Agents can request additional input mid-processing
3. **Follow-up Messages**: Clients can send additional messages with `taskId` reference
4. **Context Inheritance**: New tasks can inherit context from previous interactions

### 3.5. Streaming and Real-Time Updates

Real-time capabilities are provided through:

- **Streaming Operations**: Stream Message and Resubscribe to Task
- **Event Types**: Status updates and artifact updates
- **Connection Management**: Proper handling of connection interruption and reconnection
- **Buffering**: Events may be buffered during connection outages

This specification defines three standard transport protocols: [JSON-RPC Transport](#9-json-rpc-transport), [gRPC Transport](#10-grpc-transport), and [HTTP+JSON/REST Transport](#11-httpjsonrest-transport). Alternative transport protocols **MAY** be supported as long as they comply with the constraints defined in [Section 3 (A2A Protocol Operations)](#3-a2a-protocol-operations), [Section 4 (Protocol Data Model)](#4-protocol-data-model), and [Section 5 (Transport Compliance and Interoperability)](#5-transport-compliance-and-interoperability).

## 4. Protocol Data Model

The A2A protocol defines a canonical data model using Protocol Buffers. All transport implementations **MUST** provide functionally equivalent representations of these data structures.

"Normative Source" Principle:

The file `specification/grpc/a2a.proto` is the single authoritative normative definition of all protocol data objects and request/response messages. A generated JSON artifact (`specification/json/a2a.json`, produced at build time and not committed) MAY be published for convenience to tooling and the website, but it is a non-normative build artifact. SDK language bindings, schemas, and any other derived forms **MUST** be regenerated from the proto (directly or via code generation) rather than edited manually.

Change Control and Deprecation Lifecycle:

- Introduction: When a proto message or field is renamed, the new name is added while existing published names remain available for at least one subsequent minor release.
- Documentation: This specification MUST include a Migration Appendix (Appendix A) enumerating legacy→current name mappings with planned removal versions.
- Anchors: Legacy documentation anchors MUST be preserved (as hidden HTML anchors) to avoid breaking inbound links.
- SDK/Schema Aliases: SDKs and JSON Schemas SHOULD provide deprecated alias types/definitions to maintain backward compatibility.
- Removal: A deprecated name SHOULD NOT be removed earlier than two minor versions after introduction of its replacement and MUST appear in at least one stable tagged release containing both forms.

Automated Generation:

The documentation build generates `specification/json/a2a.json` on-the-fly (the file is not tracked in source control). Future improvements may publish an OpenAPI v3 + JSON Schema bundle for enhanced tooling.

Rationale:

Centering the proto file as the normative source ensures transport neutrality, reduces specification drift, and provides a deterministic evolution path for the ecosystem.

### 4.1. Core Objects

<span id="61-task-object"></span>
#### 4.1.1. Task

Represents the stateful unit of work being processed by the A2A Server for an A2A Client.

```proto
--8<-- "specification/grpc/a2a.proto:Task"
```

#### 4.1.2. TaskStatus

Represents the current state and associated context of a Task.

```proto
--8<-- "specification/grpc/a2a.proto:TaskStatus"
```

<span id="63-taskstate-enum"></span>
#### 4.1.3. TaskState

Defines the possible lifecycle states of a Task.

```proto
--8<-- "specification/grpc/a2a.proto:TaskState"
```

#### 4.1.4. Message
<span id="4241-messagesendconfiguration"></span>

Represents a single communication turn between a client and an agent.

```proto
--8<-- "specification/grpc/a2a.proto:Message"
```

#### 4.1.5. Part

Represents a distinct piece of content within a Message or Artifact.

```proto
--8<-- "specification/grpc/a2a.proto:Part"
```

#### 4.1.6. FilePart

Represents file-based content within a Part.

```proto
--8<-- "specification/grpc/a2a.proto:FilePart"
```

#### 4.1.7. DataPart

Represents structured JSON data within a Part.

```proto
--8<-- "specification/grpc/a2a.proto:DataPart"
```

#### 4.1.8. Artifact

Represents a tangible output generated by the agent during a task.

```proto
--8<-- "specification/grpc/a2a.proto:Artifact"
```

### 4.2. Streaming Events

<span id="4192-taskstatusupdateevent"></span>
<span id="722-taskstatusupdateevent-object"></span>
#### 4.2.1. TaskStatusUpdateEvent

Carries information about a change in task status during streaming.

```proto
--8<-- "specification/grpc/a2a.proto:TaskStatusUpdateEvent"
```

<span id="4193-taskartifactupdateevent"></span>
<span id="723-taskartifactupdateevent-object"></span>
#### 4.2.2. TaskArtifactUpdateEvent

Carries a new or updated artifact generated during streaming.

```proto
--8<-- "specification/grpc/a2a.proto:TaskArtifactUpdateEvent"
```

### 4.3. Push Notification Objects

#### 4.3.1. PushNotificationConfig
<span id="68-pushnotificationconfig-object"></span>

Configuration for setting up push notifications for task updates.

```proto
--8<-- "specification/grpc/a2a.proto:PushNotificationConfig"
```

#### 4.3.2. TaskPushNotificationConfig

Resource wrapper for push notification configurations.

```proto
--8<-- "specification/grpc/a2a.proto:TaskPushNotificationConfig"
```

#### 4.3.3. AuthenticationInfo

Defines authentication details for push notifications.

```proto
--8<-- "specification/grpc/a2a.proto:PushNotificationAuthenticationInfo"
```

### 4.4. Agent Discovery Objects

<span id="441-agentcard"></span>
<span id="710-agentgetauthenticatedextendedcard"></span>
#### 4.4.1. AgentCard
<span id="421-agentcard"></span>

The primary metadata document describing an agent's capabilities and interface.

```proto
--8<-- "specification/grpc/a2a.proto:AgentCard"
```

#### 4.4.2. AgentProvider

Information about the organization providing the agent.

```proto
--8<-- "specification/grpc/a2a.proto:AgentProvider"
```

#### 4.4.3. AgentCapabilities

Defines optional A2A protocol features supported by the agent.

```proto
--8<-- "specification/grpc/a2a.proto:AgentCapabilities"
```

#### 4.4.4. AgentExtension

Specifies a protocol extension supported by the agent.

```proto
--8<-- "specification/grpc/a2a.proto:AgentExtension"
```

#### 4.4.5. AgentSkill

Describes a specific capability or area of expertise the agent can perform.

```proto
--8<-- "specification/grpc/a2a.proto:AgentSkill"
```

#### 4.4.6. AgentInterface

Declares additional transport interfaces supported by the agent.

```proto
--8<-- "specification/grpc/a2a.proto:AgentInterface"
```

#### 4.4.7. AgentCardSignature

Represents a JSON Web Signature for agent card verification.

```proto
--8<-- "specification/grpc/a2a.proto:AgentCardSignature"
```

### 4.5. Security Objects

#### 4.5.1. SecurityScheme

Base security scheme definition supporting multiple authentication types.

```proto
--8<-- "specification/grpc/a2a.proto:SecurityScheme"
```

#### 4.5.2. APIKeySecurityScheme

API key-based authentication scheme.

```proto
--8<-- "specification/grpc/a2a.proto:APIKeySecurityScheme"
```

#### 4.5.3. HTTPAuthSecurityScheme

HTTP authentication scheme (Basic, Bearer, etc.).

```proto
--8<-- "specification/grpc/a2a.proto:HTTPAuthSecurityScheme"
```

#### 4.5.4. OAuth2SecurityScheme

OAuth 2.0 authentication scheme.

```proto
--8<-- "specification/grpc/a2a.proto:OAuth2SecurityScheme"
```

#### 4.5.5. OpenIdConnectSecurityScheme

OpenID Connect authentication scheme.

```proto
--8<-- "specification/grpc/a2a.proto:OpenIdConnectSecurityScheme"
```

#### 4.5.6. MutualTLSSecurityScheme

Mutual TLS authentication scheme.

```proto
--8<-- "specification/grpc/a2a.proto:MutualTLSSecurityScheme"
```

### 4.6. Extensions

The A2A protocol supports extensions to provide additional functionality or data beyond the core specification while maintaining backward compatibility and interoperability. Extensions allow agents to declare additional capabilities such as protocol enhancements or vendor-specific features, maintain compatibility with clients that don't support specific extensions, enable innovation through experimental or domain-specific features without modifying the core protocol, and facilitate standardization by providing a pathway for community-developed features to become part of the core specification.

#### 4.6.1. Extension Declaration

Agents declare their supported extensions in the [`AgentCard`](#441-agentcard) using the `extensions` field, which contains an array of [`AgentExtension`](#444-agentextension) objects.

*Example: Agent declaring extension support in AgentCard:*
```json
{
  "name": "Research Assistant Agent",
  "description": "AI agent for academic research and fact-checking",
  "url": "https://research-agent.example.com/a2a/v1",
  "preferredTransport": "HTTP+JSON",
  "extensions": [
    {
      "identifier": "https://standards.org/extensions/citations/v1",
      "version": "1.0.0",
      "required": false,
      "documentationUrl": "https://standards.org/docs/citations-extension"
    },
    {
      "identifier": "https://example.com/extensions/geolocation/v1",
      "version": "1.2.0",
      "required": false,
      "documentationUrl": "https://example.com/docs/geolocation-ext"
    }
  ],
  "skills": [
    {
      "id": "academic-research",
      "name": "Academic Research Assistant",
      "description": "Provides research assistance with citations and source verification"
    }
  ]
}
```

Clients indicate their desire to opt into the use of specific extensions through transport-specific mechanisms such as HTTP headers, gRPC metadata, or JSON-RPC request parameters that identify the extension identifiers they wish to utilize during the interaction.

*Example: HTTP client opting into extensions using headers:*
```http
POST /v1/message:send HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer token
A2A-Extensions: https://example.com/extensions/geolocation/v1,https://standards.org/extensions/citations/v1

{
  "message": {
    "role": "user",
    "parts": [{"text": "Find restaurants near me"}],
    "extensions": ["https://example.com/extensions/geolocation/v1"],
    "metadata": {
      "https://example.com/extensions/geolocation/v1": {
        "latitude": 37.7749,
        "longitude": -122.4194
      }
    }
  }
}
```

#### 4.6.2. Extensions Points

Extensions can be integrated into the A2A protocol at several well-defined extension points:

**Message Extensions:**

Messages can be extended to allow clients to provide additional strongly typed context or parameters relevant to the message being sent, or TaskStatus Messages to include extra information about the task's progress.

*Example: A location extension using the extensions and metadata arrays:*
```json
{
  "role": "user",
  "parts": [
    {"text": "Find restaurants near me"}
  ],
  "extensions": ["https://example.com/extensions/geolocation/v1"],
  "metadata": {
    "https://example.com/extensions/geolocation/v1": {
      "latitude": 37.7749,
      "longitude": -122.4194,
      "accuracy": 10.0,
      "timestamp": "2025-10-21T14:30:00Z"
    }
  }
}
```

**Artifact Extensions:**

Artifacts can include extension data to provide strongly typed context or metadata about the generated content.

*Example: An artifact with citation extension for research sources:*
```json
{
  "artifactId": "research-summary-001",
  "name": "Climate Change Summary",
  "parts": [
    {
      "text": "Global temperatures have risen by 1.1°C since pre-industrial times, with significant impacts on weather patterns and sea levels."
    }
  ],
  "extensions": ["https://standards.org/extensions/citations/v1"],
  "metadata": {
    "https://standards.org/extensions/citations/v1": {
      "sources": [
        {
          "title": "Global Temperature Anomalies - 2023 Report",
          "authors": ["Smith, J.", "Johnson, M."],
          "url": "https://climate.gov/reports/2023-temperature",
          "accessDate": "2025-10-21",
          "relevantText": "Global temperatures have risen by 1.1°C"
        }
      ]
    }
  }
}
```

#### 4.6.2. Extension Versioning and Compatibility

Extensions **SHOULD** include version information in their URI identifier. This allows clients and agents to negotiate compatible versions of extensions during interactions. A new URI **MUST** be created for breaking changes to an extension.

If a client requests a versions of an extension that the agent does not support, the agent **SHOULD** ignore the extension for that interaction and proceed without it, unless the extension is marked as `required` in the AgentCard, in which case the agent **MUST** return an error indicating unsupported extension. It **MUST NOT** fall back to a previous version of the extension automatically.

## 5. Transport Compliance and Interoperability

### 5.1. Functional Equivalence Requirements

When an agent supports multiple transports, all supported transports **MUST**:

- **Identical Functionality**: Provide the same set of operations and capabilities
- **Consistent Behavior**: Return semantically equivalent results for the same requests
- **Same Error Handling**: Map errors consistently using appropriate transport-specific codes
- **Equivalent Authentication**: Support the same authentication schemes declared in the AgentCard

### 5.2. Transport Selection and Negotiation

- **Agent Declaration**: Agents **MUST** declare all supported transports in their AgentCard
- **Client Choice**: Clients **MAY** choose any transport declared by the agent
- **No Dynamic Negotiation**: A2A does not define runtime transport negotiation
- **Fallback Behavior**: Clients **SHOULD** implement fallback logic for alternative transports

### 5.3. Method Mapping Reference

| Functionality       | JSON-RPC Method                      | gRPC Method            | REST Endpoint                     |
| :------------------ | :----------------------------------- | :--------------------- | :-------------------------------- |
| Send message        | `message/send`                       | `SendMessage`          | `POST /v1/message:send`           |
| Stream message      | `message/stream`                     | `SendStreamingMessage` | `POST /v1/message:stream`         |
| Get task            | `tasks/get`                          | `GetTask`              | `GET /v1/tasks/{id}`              |
| List tasks          | `tasks/list`                         | `ListTasks`            | `GET /v1/tasks`                   |
| Cancel task         | `tasks/cancel`                       | `CancelTask`           | `POST /v1/tasks/{id}:cancel`      |
| Resubscribe to task | `tasks/resubscribe`                  | `TaskResubscription`   | `POST /v1/tasks/{id}:resubscribe` |
| Get agent card      | `agent/getAuthenticatedExtendedCard` | `GetAgentCard`         | `GET /v1/card`                    |

## 6. Common Workflows & Examples

This section provides illustrative examples of common A2A interactions across different transports.

### 6.1. Basic Task Execution

**Scenario:** Client asks a question and receives a completed task response.

#### HTTP Example

**Request:**
```http
POST /v1/message:send HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer token

{
  "message": {
    "role": "user",
    "parts": [{"text": "What is the weather today?"}],
    "messageId": "msg-uuid"
  }
}
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "task": {
    "id": "task-uuid",
    "contextId": "context-uuid",
    "status": {"state": "completed"},
    "artifacts": [{
      "artifactId": "artifact-uuid",
      "name": "Weather Report",
      "parts": [{"text": "Today will be sunny with a high of 75°F"}]
    }]
  }
}
```

### 6.2. Streaming Task Execution

**Scenario:** Client requests a long-running task with real-time updates.

#### HTTP SSE Example

**Request:**
```http
POST /v1/message:stream HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer token

{
  "message": {
    "role": "user",
    "parts": [{"text": "Write a detailed report on climate change"}],
    "messageId": "msg-uuid"
  }
}
```

**SSE Response Stream:**
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream

data: {"task": {"id": "task-uuid", "status": {"state": "working"}}}

data: {"artifactUpdate": {"taskId": "task-uuid", "artifact": {"parts": [{"text": "# Climate Change Report\n\n"}]}}}

data: {"statusUpdate": {"taskId": "task-uuid", "status": {"state": "completed"}, "final": true}}
```

### 6.3. Multi-Turn Interaction

**Scenario:** Agent requires additional input to complete a task.

**Initial Request:**
```http
POST /v1/message:send HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer token

{
  "message": {
    "role": "user",
    "parts": [{"text": "Book me a flight"}],
    "messageId": "msg-1"
  }
}
```

**Response (Input Required):**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "task": {
    "id": "task-uuid",
    "status": {
      "state": "input-required",
      "update": {
        "role": "agent",
        "parts": [{"text": "I need more details. Where would you like to fly from and to?"}]
      }
    }
  }
}
```

**Follow-up Request:**
```http
POST /v1/message:send HTTP/1.1
Host: agent.example.com
Content-Type: application/json
Authorization: Bearer token

{
  "message": {
    "taskId": "task-uuid",
    "role": "user",
    "parts": [{"text": "From San Francisco to New York"}],
    "messageId": "msg-2"
  }
}
```

## 7. Authentication and Authorization

A2A treats agents as standard enterprise applications, relying on established web security practices. Identity information is handled at the transport layer, not within A2A protocol payloads.

For a comprehensive guide on enterprise security aspects, see [Enterprise-Ready Features](./topics/enterprise-ready.md).

### 7.1. Transport Security

Production deployments **MUST** use encrypted transport (HTTPS for HTTP-based transports, TLS for gRPC). Implementations **SHOULD** use modern TLS configurations (TLS 1.3+ recommended) with strong cipher suites.

### 7.2. Server Identity Verification

A2A Clients **SHOULD** verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.

### 7.3. Client Authentication Process

1. **Discovery of Requirements:** The client discovers the server's required authentication schemes via the `security_schemes` field in the AgentCard.
2. **Credential Acquisition (Out-of-Band):** The client obtains the necessary credentials through an out-of-band process specific to the required authentication scheme.
3. **Credential Transmission:** The client includes these credentials in transport-appropriate headers or metadata for every A2A request.

### 7.4. Server Authentication Responsibilities

The A2A Server:

- **MUST** authenticate every incoming request based on the provided credentials and its declared authentication requirements.
- **SHOULD** use appropriate transport-specific error codes for authentication challenges or rejections.
- **SHOULD** provide relevant authentication challenge information with error responses.

### 7.5. In-Task Authentication (Secondary Credentials)

If an agent requires additional credentials during task execution:

1. It **SHOULD** transition the A2A task to the `TASK_STATE_AUTH_REQUIRED` state.
2. The accompanying `TaskStatus.update` **SHOULD** provide details about the required secondary authentication.
3. The A2A Client obtains these credentials out-of-band and provides them in a subsequent message request.

### 7.6. Authorization

Once authenticated, the A2A Server authorizes requests based on the authenticated identity and its own policies. Authorization logic is implementation-specific and **MAY** consider:

- Specific skills requested
- Actions attempted within tasks
- Data access policies
- OAuth scopes (if applicable)

## 8. Agent Discovery: The Agent Card

### 8.1. Purpose

A2A Servers **MUST** make an Agent Card available. The Agent Card describes the server's identity, capabilities, skills, and interaction requirements. Clients use this information for discovering suitable agents and configuring interactions.

For more on discovery strategies, see the [Agent Discovery guide](./topics/agent-discovery.md).

### 8.2. Discovery Mechanisms

Clients can find Agent Cards through:

- **Well-Known URI:** Accessing `https://{server_domain}/.well-known/agent-card.json`
- **Registries/Catalogs:** Querying curated catalogs of agents
- **Direct Configuration:** Pre-configured Agent Card URLs or content

### 8.3. Transport Declaration Requirements

The AgentCard **MUST** properly declare supported transports:

#### 8.3.1. Primary Interface Declaration

- The `url` field **MUST** specify the primary endpoint
- The `preferred_transport` field **MUST** match the transport available at the primary URL
- The primary URL **MUST** support the declared preferred transport

#### 8.3.2. Additional Interfaces

- `additional_interfaces` **SHOULD** declare all supported transport combinations
- Each interface **MUST** accurately declare its transport protocol
- URLs **MAY** be reused if multiple transports are available at the same endpoint

#### 8.3.3. Client Transport Selection

Clients **MUST** follow these rules:

1. Parse available transports from the AgentCard
2. Prefer the `preferred_transport` if supported
3. Fall back to any supported transport from `additional_interfaces`
4. Use the correct URL for the selected transport

### 8.4. Sample Agent Card

```json
{
  "protocolVersion": "0.2.9",
  "name": "GeoSpatial Route Planner Agent",
  "description": "Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.",
  "url": "https://georoute-agent.example.com/a2a/v1",
  "preferredTransport": "JSONRPC",
  "additionalInterfaces" : [
    {"url": "https://georoute-agent.example.com/a2a/v1", "transport": "JSONRPC"},
    {"url": "https://georoute-agent.example.com/a2a/grpc", "transport": "GRPC"},
    {"url": "https://georoute-agent.example.com/a2a/json", "transport": "HTTP+JSON"}
  ],
  "provider": {
    "organization": "Example Geo Services Inc.",
    "url": "https://www.examplegeoservices.com"
  },
  "iconUrl": "https://georoute-agent.example.com/icon.png",
  "version": "1.2.0",
  "documentationUrl": "https://docs.examplegeoservices.com/georoute-agent/api",
  "capabilities": {
    "streaming": true,
    "pushNotifications": true,
    "stateTransitionHistory": false
  },
  "securitySchemes": {
    "google": {
      "type": "openIdConnect",
      "openIdConnectUrl": "https://accounts.google.com/.well-known/openid-configuration"
    }
  },
  "security": [{ "google": ["openid", "profile", "email"] }],
  "defaultInputModes": ["application/json", "text/plain"],
  "defaultOutputModes": ["application/json", "image/png"],
  "skills": [
    {
      "id": "route-optimizer-traffic",
      "name": "Traffic-Aware Route Optimizer",
      "description": "Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).",
      "tags": ["maps", "routing", "navigation", "directions", "traffic"],
      "examples": [
        "Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.",
        "{\"origin\": {\"lat\": 37.422, \"lng\": -122.084}, \"destination\": {\"lat\": 37.7749, \"lng\": -122.4194}, \"preferences\": [\"avoid_ferries\"]}"
      ],
      "inputModes": ["application/json", "text/plain"],
      "outputModes": [
        "application/json",
        "application/vnd.geo+json",
        "text/html"
      ]
    },
    {
      "id": "custom-map-generator",
      "name": "Personalized Map Generator",
      "description": "Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.",
      "tags": ["maps", "customization", "visualization", "cartography"],
      "examples": [
        "Generate a map of my upcoming road trip with all planned stops highlighted.",
        "Show me a map visualizing all coffee shops within a 1-mile radius of my current location."
      ],
      "inputModes": ["application/json"],
      "outputModes": [
        "image/png",
        "image/jpeg",
        "application/json",
        "text/html"
      ]
    }
  ],
  "supportsAuthenticatedExtendedCard": true,
  "signatures": [
    {
      "protected": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0",
      "signature": "QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ"
    }
  ]
}
```

## 9. JSON-RPC Transport

The JSON-RPC transport provides a simple, HTTP-based interface using JSON-RPC 2.0 for method calls and Server-Sent Events for streaming.

### 9.1. Transport Requirements

- **Protocol:** JSON-RPC 2.0 over HTTP(S)
- **Content-Type:** `application/json` for requests and responses
- **Method Naming:** `{category}/{action}` pattern (e.g., `message/send`, `tasks/get`)
- **Streaming:** Server-Sent Events (`text/event-stream`)

### 9.2. Base Request Structure

All JSON-RPC requests **MUST** follow the standard JSON-RPC 2.0 format:

```json
{
  "jsonrpc": "2.0",
  "id": "unique-request-id",
  "method": "category/action",
  "params": { /* method-specific parameters */ }
}
```

### 9.3. Core Methods

#### 9.3.1. `message/send`

Sends a message to initiate or continue a task.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "message/send",
  "params": {
    "message": { /* Message object */ },
    "configuration": { /* MessageSendConfiguration object */ },
    "metadata": { /* optional metadata */ }
  }
}
```

**Referenced Objects:** [`Message`](#414-message), [`MessageSendConfiguration`](#331-messagesendconfiguration)

**Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": { /* Task or Message object */ }
}
```

**Referenced Objects:** [`Task`](#411-task), [`Message`](#414-message)

#### 9.3.2. `message/stream`

Sends a message and subscribes to real-time updates via Server-Sent Events.

**Request:** Same as `message/send`

**Response:** HTTP 200 with `Content-Type: text/event-stream`
```
data: {"jsonrpc": "2.0", "id": 1, "result": { /* Task | Message | TaskArtifactUpdateEvent | TaskStatusUpdateEvent */ }}

data: {"jsonrpc": "2.0", "id": 1, "result": { /* Task | Message | TaskArtifactUpdateEvent | TaskStatusUpdateEvent */ }}
```

Referenced Objects: [`Task`](#411-task), [`Message`](#414-message), [`TaskArtifactUpdateEvent`](#422-taskartifactupdateevent), [`TaskStatusUpdateEvent`](#421-taskstatusupdateevent)

#### 9.3.3. `tasks/get`

Retrieves the current state of a task.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tasks/get",
  "params": {
    "id": "task-uuid",
    "historyLength": 10
  }
}
```

#### 9.3.4. `tasks/list`

Lists tasks with optional filtering and pagination.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tasks/list",
  "params": {
    "contextId": "context-uuid",
    "status": "working",
    "pageSize": 50,
    "pageToken": "cursor-token"
  }
}
```

#### 9.3.5. `tasks/cancel`

Cancels an ongoing task.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "tasks/cancel",
  "params": {
    "id": "task-uuid"
  }
}
```

#### 9.3.6. `tasks/resubscribe`
<span id="936-tasksresubscribe"></span>

Reconnects to an SSE stream for an ongoing task.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "method": "tasks/resubscribe",
  "params": {
    "id": "task-uuid"
  }
}
```

**Response:** SSE stream (same format as `message/stream`)

#### 9.3.7. Push Notification Configuration Methods

- `tasks/pushNotificationConfig/set` - Set push notification configuration
- `tasks/pushNotificationConfig/get` - Get push notification configuration
- `tasks/pushNotificationConfig/list` - List push notification configurations
- `tasks/pushNotificationConfig/delete` - Delete push notification configuration

#### 9.3.8. `agent/getAuthenticatedExtendedCard`

Retrieves an authenticated, potentially extended Agent Card.

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 6,
  "method": "agent/getAuthenticatedExtendedCard"
}
```

### 9.4. Error Handling

A2A defines a set of errors that are specific to the semantics of the A2A protocol.

**A2A-Specific Errors:**

| Error Name                          | Description                                                                                                                                                       |
| :---------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `TaskNotFoundError`                 | The specified task ID does not correspond to an existing or accessible task. It might be invalid, expired, or already completed and purged.                       |
| `TaskNotCancelableError`            | An attempt was made to cancel a task that is not in a cancelable state (e.g., it has already reached a terminal state like `completed`, `failed`, or `canceled`). |
| `PushNotificationNotSupportedError` | Client attempted to use push notification features but the server agent does not support them (i.e., `AgentCard.capabilities.pushNotifications` is `false`).      |
| `UnsupportedOperationError`         | The requested operation or a specific aspect of it is not supported by this server agent implementation.                                                          |
| `ContentTypeNotSupportedError`      | A Media Type provided in the request's message parts or implied for an artifact is not supported by the agent or the specific skill being invoked.                |

## 10. gRPC Transport

The gRPC transport provides a high-performance, strongly-typed interface using Protocol Buffers over HTTP/2. The gRPC transport leverages the [API guidelines](https://google.aip.dev/general) to simplify gRPC to HTTP mapping.

### 10.1. Transport Requirements

- **Protocol:** gRPC over HTTP/2 with TLS
- **Definition:** Use the normative Protocol Buffers definition in `specification/grpc/a2a.proto`
- **Serialization:** Protocol Buffers version 3
- **Service:** Implement the `A2AService` gRPC service

### 10.2. Service Definition

```proto
service A2AService {
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
  rpc SendStreamingMessage(SendMessageRequest) returns (stream StreamResponse);
  rpc GetTask(GetTaskRequest) returns (Task);
  rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);
  rpc CancelTask(CancelTaskRequest) returns (Task);
  rpc TaskResubscription(TaskResubscriptionRequest) returns (stream StreamResponse);
  rpc CreateTaskPushNotificationConfig(CreateTaskPushNotificationConfigRequest) returns (TaskPushNotificationConfig);
  rpc GetTaskPushNotificationConfig(GetTaskPushNotificationConfigRequest) returns (TaskPushNotificationConfig);
  rpc ListTaskPushNotificationConfig(ListTaskPushNotificationConfigRequest) returns (ListTaskPushNotificationConfigResponse);
  rpc DeleteTaskPushNotificationConfig(DeleteTaskPushNotificationConfigRequest) returns (google.protobuf.Empty);
  rpc GetAgentCard(GetAgentCardRequest) returns (AgentCard);
}
```

### 10.3. Core Methods

#### 10.3.1. SendMessage

Sends a message to an agent.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:SendMessageRequest"
```

**Response:**
```proto
--8<-- "specification/grpc/a2a.proto:SendMessageResponse"
```

#### 10.3.2. SendStreamingMessage

Sends a message with streaming updates.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:SendMessageRequest"
```

**Response:** Server streaming [`StreamResponse`](#stream-response) objects.

#### 10.3.3. GetTask

Retrieves task status.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:GetTaskRequest"
```

**Response:** See [`Task`](#411-task) object definition.

#### 10.3.4. ListTasks

Lists tasks with filtering.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:ListTasksRequest"
```

**Response:**
```proto
--8<-- "specification/grpc/a2a.proto:ListTasksResponse"
```

#### 10.3.5. CancelTask

Cancels a running task.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:CancelTaskRequest"
```

**Response:** See [`Task`](#411-task) object definition.

#### 10.3.6. TaskResubscription

Resubscribe to task updates via streaming.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:TaskResubscriptionRequest"
```

**Response:** Server streaming [`StreamResponse`](#stream-response) objects.

#### 10.3.7. CreateTaskPushNotificationConfig

Creates a push notification configuration for a task.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:CreateTaskPushNotificationConfigRequest"
```

**Response:** See [`TaskPushNotificationConfig`](#432-taskpushnotificationconfig) object definition.

#### 10.3.8. GetTaskPushNotificationConfig

Retrieves an existing push notification configuration for a task.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:GetTaskPushNotificationConfigRequest"
```

**Response:** See [`TaskPushNotificationConfig`](#432-taskpushnotificationconfig) object definition.

#### 10.3.9. ListTaskPushNotificationConfig

Lists all push notification configurations for a task.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:ListTaskPushNotificationConfigRequest"
```

**Response:**
```proto
--8<-- "specification/grpc/a2a.proto:ListTaskPushNotificationConfigResponse"
```

#### 10.3.10. DeleteTaskPushNotificationConfig

Removes a push notification configuration for a task.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:DeleteTaskPushNotificationConfigRequest"
```

**Response:** `google.protobuf.Empty`

#### 10.3.11. GetAgentCard

Retrieves the agent's capability card.

**Request:**
```proto
--8<-- "specification/grpc/a2a.proto:GetAgentCardRequest"
```

**Response:** See [`AgentCard`](#441-agentcard) object definition.

### 10.4. Error Handling

A2A gRPC leverages the API [error standard](https://google.aip.dev/193) for formatting errors.

#### 10.4.1. A2A Error Mappings

| A2A Error Type                      | Description                      | gRPC Status Code      |
| :---------------------------------- | :------------------------------- | :-------------------- |
| `TaskNotFoundError`                 | Task ID not found                | `NOT_FOUND`           |
| `TaskNotCancelableError`            | Task not in cancelable state     | `FAILED_PRECONDITION` |
| `PushNotificationNotSupportedError` | Push notifications not supported | `UNIMPLEMENTED`       |
| `UnsupportedOperationError`         | Operation not supported          | `UNIMPLEMENTED`       |
| `ContentTypeNotSupportedError`      | Unsupported content type         | `INVALID_ARGUMENT`    |

**Example Error Response:**

```proto
// gRPC Status object
status {
  code: NOT_FOUND
  message: "Task with ID 'task-123' not found"
  details: [
    {
      type_url: "type.googleapis.com/a2a.TaskNotFoundError"
      value: {
        error_type: "TaskNotFoundError"
        task_id: "task-123"
        timestamp: "2025-10-19T14:30:00Z"
      }
    }
  ]
}
```

#### 10.4.2. Implementation Requirements

- **SHOULD** include structured error information in error responses
- **MUST** include human-readable error messages
- **MAY** include additional context for development environments
- **MUST** maintain semantic equivalence with A2A error conditions across transports

### 10.5. Streaming

gRPC streaming uses server streaming RPCs for real-time updates. The `StreamResponse` message provides a union of possible streaming events:


```proto
--8<-- "specification/grpc/a2a.proto:StreamResponse"
```

## 11. HTTP+JSON/REST Transport

The HTTP+JSON transport provides a RESTful interface using standard HTTP methods and JSON payloads.

### 11.1. Transport Requirements

- **Protocol:** HTTP(S) with JSON payloads
- **Content-Type:** `application/json` for requests and responses
- **Methods:** Standard HTTP verbs (GET, POST, PUT, DELETE)
- **URL Patterns:** RESTful resource-based URLs
- **Streaming:** Server-Sent Events for real-time updates

### 11.2. URL Patterns and HTTP Methods

#### 11.2.1. Message Operations

- `POST /v1/message:send` - Send message
- `POST /v1/message:stream` - Send message with streaming (SSE response)

#### 11.2.2. Task Operations

- `GET /v1/tasks/{id}` - Get task status
- `GET /v1/tasks` - List tasks (with query parameters)
- `POST /v1/tasks/{id}:cancel` - Cancel task
- `POST /v1/tasks/{id}:resubscribe` - Resubscribe to task updates (SSE response, streaming tasks only)

#### 11.2.3. Push Notification Configuration

- `POST /v1/tasks/{id}/pushNotificationConfigs` - Create configuration
- `GET /v1/tasks/{id}/pushNotificationConfigs/{configId}` - Get configuration
- `GET /v1/tasks/{id}/pushNotificationConfigs` - List configurations
- `DELETE /v1/tasks/{id}/pushNotificationConfigs/{configId}` - Delete configuration

#### 11.2.4. Agent Card

- `GET /v1/card` - Get authenticated extended agent card

### 11.3. Request/Response Format

All requests and responses use JSON objects structurally equivalent to the Protocol Buffer definitions.

**Example Send Message:**
```http
POST /v1/message:send
Content-Type: application/json

{
  "message": {
    "messageId": "uuid",
    "role": "user",
    "parts": [{"text": "Hello"}]
  },
  "configuration": {
    "acceptedOutputModes": ["text/plain"]
  }
}
```

**Referenced Objects:** [`Message`](#414-message), [`MessageSendConfiguration`](#331-messagesendconfiguration)

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "task": {
    "id": "task-uuid",
    "contextId": "context-uuid",
    "status": {
      "state": "completed"
    }
  }
}
```

**Referenced Objects:** [`Task`](#411-task)

### 11.4. Query Parameters

For GET operations, use query parameters for filtering and pagination:

```http
GET /v1/tasks?contextId=uuid&status=working&pageSize=50&pageToken=cursor
```

### 11.5. Error Handling

HTTP implementations **MUST** map A2A-specific error codes to appropriate HTTP status codes while preserving semantic meaning.

#### 11.5.1. A2A Error Mappings

| A2A Error Type                      | HTTP Status Code             | Error Code                         | Description                      |
| :---------------------------------- | :--------------------------- | :--------------------------------- | :------------------------------- |
| `TaskNotFoundError`                 | `404 Not Found`              | `TASK_NOT_FOUND`                   | Task not found                   |
| `TaskNotCancelableError`            | `409 Conflict`               | `TASK_NOT_CANCELABLE`              | Task cannot be canceled          |
| `PushNotificationNotSupportedError` | `501 Not Implemented`        | `PUSH_NOTIFICATIONS_NOT_SUPPORTED` | Push notifications not supported |
| `UnsupportedOperationError`         | `501 Not Implemented`        | `OPERATION_NOT_SUPPORTED`          | Operation not supported          |
| `ContentTypeNotSupportedError`      | `415 Unsupported Media Type` | `CONTENT_TYPE_NOT_SUPPORTED`       | Content type not supported       |

#### 11.5.2. Error Response Format

A2A error responses **MUST** include a JSON error object with the following structure:

```json
{
  "error": {
    "code": "TASK_NOT_FOUND",
    "message": "The specified task ID does not exist",
    "details": {
      "taskId": "invalid-task-id"
    }
  }
}
```

#### 11.5.3. Implementation Requirements

- **MUST** use appropriate HTTP status codes for each A2A error type
- **MUST** provide human-readable error messages
- **MUST** include structured error codes in the response body
- **MAY** include additional context in the `details` object

**Note:** Standard HTTP error handling (authentication, authorization, rate limiting, etc.) follows normal REST conventions and is not part of the A2A-specific error mapping.

### 11.6. Streaming
<span id="stream-response"></span>

REST streaming uses Server-Sent Events with the `data` field containing JSON serializations of the protocol data objects:

```http
POST /v1/message:stream
Content-Type: application/json

{
  "message": { /* Message object */ }
}
```

**Referenced Objects:** [`Message`](#414-message)

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream

data: {"task": { /* Task object */ }}

data: {"artifactUpdate": { /* TaskArtifactUpdateEvent */ }}

data: {"statusUpdate": { /* TaskStatusUpdateEvent */ }}
```
**Referenced Objects:** [`Task`](#411-task), [`TaskStatusUpdateEvent`](#421-taskstatusupdateevent), [`TaskArtifactUpdateEvent`](#422-taskartifactupdateevent)
<span id="4192-taskstatusupdateevent"></span><span id="4193-taskartifactupdateevent"></span>
Streaming responses are simple, linearly ordered sequences: first a `Task` (or single `Message`), then zero or more status or artifact update events until the task reaches a terminal or interrupted state, at which point the stream closes. Implementations SHOULD avoid re-ordering events and MAY optionally resend a final `Task` snapshot before closing.

---

## Appendix A. Migration & Legacy Compatibility

This appendix catalogs renamed protocol messages and objects, their legacy identifiers, and the planned deprecation/removal schedule. All legacy names and anchors MUST remain resolvable until the stated earliest removal version.

| Legacy Name                                     | Current Name                              | Earliest Removal Version | Notes                                                  |
| ----------------------------------------------- | ----------------------------------------- | ------------------------ | ------------------------------------------------------ |
| `MessageSendParams`                             | `SendMessageRequest`                      | >= 0.5.0                 | Request payload rename for clarity (request vs params) |
| `SendMessageSuccessResponse`                    | `SendMessageResponse`                     | >= 0.5.0                 | Unified success response naming                        |
| `SendStreamingMessageSuccessResponse`           | `StreamResponse`                          | >= 0.5.0                 | Shorter, transport-agnostic streaming response         |
| `SetTaskPushNotificationConfigRequest`          | `CreateTaskPushNotificationConfigRequest` | >= 0.5.0                 | Explicit creation intent                               |
| `ListTaskPushNotificationConfigSuccessResponse` | `ListTaskPushNotificationConfigResponse`  | >= 0.5.0                 | Consistent response suffix removal                     |
| `GetAuthenticatedExtendedCardRequest`           | `GetAgentCardRequest`                     | >= 0.5.0                 | Simplified, generalized naming                         |

Planned Lifecycle (example timeline; adjust per release strategy):

1. 0.3.x: New names introduced; legacy names documented; aliases added.
2. 0.4.x: Legacy names marked "deprecated" in SDKs and schemas; warning notes added.
3. ≥0.5.0: Legacy names eligible for removal after review; migration appendix updated.

### A.1 Legacy Documentation Anchors

Hidden anchor spans preserve old inbound links:

<!-- Legacy inbound link compatibility anchors (old spec numbering & names) -->
<span id="32-supported-transport-protocols"></span>
<span id="324-transport-extensions"></span>
<span id="35-method-mapping-and-naming-conventions"></span>
<span id="5-agent-discovery-the-agent-card"></span>
<span id="53-recommended-location"></span>
<span id="55-agentcard-object-structure"></span>
<span id="56-transport-declaration-and-url-relationships"></span>
<span id="563-client-transport-selection-rules"></span>
<span id="57-sample-agent-card"></span>
<span id="6-protocol-data-objects"></span>
<span id="61-task-object"></span>
<span id="610-taskpushnotificationconfig-object"></span>
<span id="611-json-rpc-structures"></span>
<span id="612-jsonrpcerror-object"></span>
<span id="63-taskstate-enum"></span>
<span id="69-pushnotificationauthenticationinfo-object"></span>
<span id="711-messagesendparams-object"></span>
<span id="72-messagestream"></span>
<span id="721-sendstreamingmessageresponse-object"></span>
<span id="731-taskqueryparams-object"></span>
<span id="741-listtasksparams-object"></span>
<span id="742-listtasksresult-object"></span>
<span id="751-taskidparams-object-for-taskscancel-and-taskspushnotificationconfigget"></span>
<span id="77-taskspushnotificationconfigget"></span>
<span id="771-gettaskpushnotificationconfigparams-object-taskspushnotificationconfigget"></span>
<span id="781-listtaskpushnotificationconfigparams-object-taskspushnotificationconfiglist"></span>
<span id="791-deletetaskpushnotificationconfigparams-object-taskspushnotificationconfigdelete"></span>
<span id="8-error-handling"></span>
<span id="82-a2a-specific-errors"></span>
<!-- Legacy renamed message/object name anchors -->
<span id="messagesendparams"></span>
<span id="sendmessagesuccessresponse"></span>
<span id="sendstreamingmessagesuccessresponse"></span>
<span id="settaskpushnotificationconfigrequest"></span>
<span id="listtaskpushnotificationconfigsuccessresponse"></span>
<span id="getauthenticatedextendedcardrequest"></span>

Each legacy span SHOULD be placed adjacent to the current object's heading (to be inserted during detailed object section edits). If an exact numeric-prefixed anchor existed (e.g., `#414-message`), add an additional span matching that historical form if known.

### A.2 Migration Guidance

Client Implementations SHOULD:

- Prefer new names immediately for all new integrations.
- Implement dual-handling where schemas/types permit (e.g., union type or backward-compatible decoder).
- Log a warning when receiving legacy-named objects after the first deprecation announcement release.

Server Implementations MAY:

- Accept both legacy and current request message forms during the overlap period.
- Emit only current form in responses (recommended) while providing explicit upgrade notes.

### A.3 Future Automation

Once the proto→schema generation pipeline lands, this appendix will be partially auto-generated (legacy mapping table sourced from a maintained manifest). Until then, edits MUST be manual and reviewed in PRs affecting `a2a.proto`.

---
