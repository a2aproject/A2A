--- START OF FILE docs/README.md ---

# A2A Docs

<https://a2a-protocol.org>

## Developing A2A docs

1. Clone this repository and `cd` into the repository directory
2. Run `pip install -r requirements-docs.txt`
3. Run `mkdocs serve`, edit `.md` files, and live preview
4. Contribute docs changes as usual

## How it works

- The A2A docs use [mkdocs](https://www.mkdocs.org/) and the
  [mkdocs-material theme](https://squidfunk.github.io/mkdocs-material/)
- All of the source documentation / Markdown files related to the A2A docs are
  in the `docs/` directory in the A2A repository
- `mkdocs.yml` in the repository root contains all of the docs config, including
  the site navigation and organization
- There is a GitHub Action in `.github/workflows/docs.yml` that builds and
  publishes the docs and pushes the built assets to the `gh-pages` branch in
  this repository using `mkdocs gh-deploy --force`. This happens automatically for all
  commits / merges to `main`.
- The A2A documentation is hosted in GitHub pages, and the settings for this are
  in the A2A repository settings in GitHub.

## Building the Python SDK Documentation

The Python SDK documentation is built using [Sphinx](https://www.sphinx-doc.org/).

### Prerequisites

Ensure you have installed the documentation dependencies:

```bash
pip install -r ../../requirements-docs.txt
```

### Building the Docs

1. Run the following command to build the HTML documentation:

   ```bash
   sphinx-build -b html docs/sdk/python docs/sdk/python/api
   ```

2. The generated HTML files will be in the `sdk/python/api` directory. You can open `sdk/python/api/index.html` in your browser to view the documentation.

=================================================

--- START OF FILE docs/community.md ---

# A2A Community Hub

Welcome to the official community hub for the **Agent2Agent (A2A) protocol**! A2A is an open, standardized protocol that enables seamless interoperability and collaboration between AI agents across all frameworks and vendors.

---

## Recent News & Blog Posts

Stay up-to-date with the latest announcements, tutorials, and insights from the A2A team and our community.

- **[Announcing Agent Payments Protocol (AP2)](https://cloud.google.com/blog/products/ai-machine-learning/announcing-agent-payments-protocol-ap2)** - *September 16*
- **[A2A Extensions Empowering Custom Agent Functionality](https://developers.googleblog.com/en/a2a-extensions-empowering-custom-agent-functionality/)** - *September 9*
- **[A2A protocol: Demystifying Tasks vs Messages](https://discuss.google.dev/t/a2a-protocol-demystifying-tasks-vs-messages/255879)** - *August 18*
- **[End-to-end evaluation of multi-agent systems on Vertex AI](https://discuss.google.dev/t/end-to-end-evaluation-of-multi-agent-systems-on-vertex-ai-with-cloud-run-deployment-for-a2a-agents/250552)** - *August 7*
- **[Agent2Agent (A2A) protocol is getting an upgrade](https://cloud.google.com/blog/products/ai-machine-learning/agent2agent-protocol-is-getting-an-upgrade?e=48754805)** - *July 26*

---

## Upcoming Events

Connect with us at these upcoming events to learn more about A2A, see live demos, and participate in hands-on hackathons.

- **University of Florida Hackathon**
    - *October (Date TBD)*
    - Join us for a hackathon focused on building innovative solutions with A2A.

- **S√£o Paulo Summit**
    - *September 10-11*
    - Featuring key announcements, including the new Agent Payments Protocol.

- **Mexico City Summit**
    - *September 3-4*
    - Explore the latest content and use cases for A2A.

- **Tokyo Summit**
    - *August 4*
    - Discover how A2A is being used to power the next generation of AI agents.

---

## Use Case Highlights

A2A unlocks powerful new ways for AI agents to collaborate and solve complex problems. Here are a few examples of what's possible:

- **Multi-Agent Workflows:** Chain specialized agents together to automate complex processes, like candidate sourcing for hiring or streamlining supply chain logistics.
- **Agent Marketplaces:** Create platforms where agents can discover and utilize the capabilities of other agents from different providers.
- **Cross-Platform Integration:** Connect agents built on different frameworks‚Äîlike LangGraph, BeeAI, and more‚Äîto work together seamlessly.
- **Evaluating Multi-Agent Systems:** Use frameworks like Vertex AI to assess the performance and success of collaborative agent trajectories.

---

## Community Spotlight

### Featured Contributions

A2A is an open-source protocol, and we thrive on community contributions. A huge thank you to everyone who has helped build and improve A2A! Here are some recent highlights:

- [Python Quickstart Tutorial (PR#202)](https://github.com/a2aproject/A2A/pull/202)
- [LlamaIndex sample implementation (PR#179)](https://github.com/a2aproject/A2A/pull/179)
- [Autogen sample server (PR#232)](https://github.com/a2aproject/A2A/pull/232)
- [AG2 + MCP example (PR#230)](https://github.com/a2aproject/A2A/pull/230)
- [PydanticAI example (PR#127)](https://github.com/a2aproject/A2A/pull/127)

### The Word on the Street

The launch of A2A has sparked lively discussions and positive reactions across various social and video platforms.

- **Microsoft's Semantic Kernel:** Asha Sharma, Head of AI Platform Product at Microsoft, [announced on LinkedIn](https://www.linkedin.com/posts/aboutasha_a2a-ugcPost-7318649411704602624-0C_8) that "Semantic Kernel now speaks A2A," enabling instant, secure interoperability.
- **Matt Pocock's Diagramming:** Well-known developer educator Matt Pocock [shared diagrams on X](https://x.com/mattpocockuk/status/1910002033018421400) explaining the A2A protocol, which were liked and reposted hundreds of times.
- **Craig McLuckie's "Hot Take":** Craig McLuckie shared his thoughts on [LinkedIn](https://www.linkedin.com/posts/craigmcluckie_hot-take-on-agent2agent-vs-mcp-google-just-activity-7315939233792176128-4rGQ), highlighting A2A's focus on interactions *between* agentic systems as a sensible approach.
- **Zachary Huang's Deep Dive:** In his [YouTube video](https://www.youtube.com/watch?v=wrCF8MoXC_I), Zachary explains how A2A complements MCP, with A2A handling communication between agents and MCP connecting agents to tools.

---

## A2A Integrations

These agentic frameworks have built-in A2A integration, making it easy to get started:

- [Agent Development Kit (ADK)](https://google.github.io/adk-docs/a2a/)
- [AG2](https://docs.ag2.ai/latest/docs/user-guide/a2a/)
- [BeeAI Framework](https://framework.beeai.dev/integrations/a2a)
- [LangGraph](https://docs.langchain.com/langgraph-platform/server-a2a)
- [Pydantic AI](https://ai.pydantic.dev/a2a/)

## The Future is Interoperable

The excitement surrounding Google's A2A protocol clearly indicates a strong belief in its potential to revolutionize multi-agent AI systems. By providing a standardized way for AI agents to communicate and collaborate, A2A is poised to unlock new levels of automation and innovation. As enterprises increasingly adopt AI agents, A2A represents a crucial step towards realizing the full power of interconnected AI ecosystems.

**Join the growing community building the future of AI interoperability with A2A!**

=================================================

--- START OF FILE docs/index.md ---

---
hide:
  - toc
---

<!-- markdownlint-disable MD041 -->
<div style="text-align: center;">
  <div class="centered-logo-text-group">
    <img src="assets/a2a-logo-black.svg" alt="Agent2Agent Protocol Logo" width="100">
    <h1>Agent2Agent (A2A) Protocol</h1>
  </div>
</div>

## What is A2A Protocol?

Welcome to the **official documentation** for the **Agent2Agent (A2A) Protocol**, an open standard designed to enable seamless communication and collaboration between AI agents.

Originally developed by Google and now donated to the Linux Foundation, A2A provides the definitive common language for agent interoperability in a world where agents are built using diverse frameworks and by different vendors.

!!! abstract ""
    Build with
    **[![ADK Logo](https://google.github.io/adk-docs/assets/agent-development-kit.png){class="twemoji lg middle"} ADK](https://google.github.io/adk-docs/)** _(or any framework)_,
    equip with **[![MCP Logo](https://modelcontextprotocol.io/mcp.png){class="twemoji lg middle"} MCP](https://modelcontextprotocol.io)** _(or any tool)_,
    and communicate with
    **![A2A Logo](./assets/a2a-logo-black.svg){class="twemoji sm middle"} A2A**,
    to remote agents, local agents, and humans.

## Get started with A2A

<div class="grid cards" markdown>

- :material-play-circle:{ .lg .middle } **Video** Intro in <8 min

    <iframe width="560" height="315" src="https://www.youtube.com/embed/Fbr_Solax1w?si=QxPMEEiO5kLr5_0F" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

- :material-book-open:{ .lg .middle } **Read the Introduction**

    Understand the core ideas behind A2A.

    [:octicons-arrow-right-24: What is A2A?](./topics/what-is-a2a.md)

    [:octicons-arrow-right-24: Key Concepts](./topics/key-concepts.md)

- :material-file-document-outline:{ .lg .middle } **Dive into the Specification**

    Explore the detailed technical definition of the A2A protocol.

    [:octicons-arrow-right-24: Protocol Specification](./specification.md)

- :material-application-cog-outline:{ .lg .middle } **Follow the Tutorials**

    Build your first A2A-compliant agent with our step-by-step Python quickstart.

    [:octicons-arrow-right-24: Python Tutorial](./tutorials/python/1-introduction.md)

- :material-code-braces:{ .lg .middle } **Explore Code Samples**

    See A2A in action with sample clients, servers, and agent framework integrations.

    [:fontawesome-brands-github: GitHub Samples](https://github.com/a2aproject/a2a-samples)

- :material-code-braces:{ .lg .middle } **Download the Official SDKs**

    [:fontawesome-brands-python: Python](https://github.com/a2aproject/a2a-python)

    [:fontawesome-brands-js: JavaScript](https://github.com/a2aproject/a2a-js)

    [:fontawesome-brands-java: Java](https://github.com/a2aproject/a2a-java)

    [:octicons-code-24: C#/.NET](https://github.com/a2aproject/a2a-dotnet)

    [:fontawesome-brands-golang: Golang](https://github.com/a2aproject/a2a-go)

</div>

## Why use the A2A Protocol

<div style="text-align:center">

```mermaid
graph LR
    User(üßë‚Äçüíª User) <--> ClientAgent(ü§ñ Client Agent)
    ClientAgent --> A2A1(**‚ÜîÔ∏è A2A**) --> RemoteAgent1(ü§ñ Remote Agent 1)
    ClientAgent --> A2A2(**‚ÜîÔ∏è A2A**) --> RemoteAgent2(ü§ñ Remote Agent 2)

    style User fill:#fdebd0,stroke:#e67e22,stroke-width:2px
    style ClientAgent fill:#d6eaf8,stroke:#3498db,stroke-width:2px
    style RemoteAgent1 fill:#d6eaf8,stroke:#3498db,stroke-width:2px
    style RemoteAgent2 fill:#d6eaf8,stroke:#3498db,stroke-width:2px
    style A2A1 fill:#ebedef,stroke:#909497,stroke-width:2px
    style A2A2 fill:#ebedef,stroke:#909497,stroke-width:2px
```

</div>

<div class="grid cards" markdown>

- :material-account-group-outline:{ .lg .middle } **Interoperability**

    Connect agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions) to create powerful, composite AI systems.

- :material-lan-connect:{ .lg .middle } **Complex Workflows**

    Enable agents to delegate sub-tasks, exchange information, and coordinate actions to solve complex problems that a single agent cannot.

- :material-shield-key-outline:{ .lg .middle } **Secure & Opaque**

    Agents interact without needing to share internal memory, tools, or proprietary logic, ensuring security and preserving intellectual property.

</div>

---

## How does A2A work with MCP?

![A2A MCP Graphic](assets/a2a-mcp-readme.png){width="60%"}
{style="text-align: center; margin-bottom:1em; margin-top:1em;"}

A2A and [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) are complementary standards for building robust agentic applications:

- **Model Context Protocol (MCP)**: Provides [agent-to-tool communication](https://cloud.google.com/discover/what-is-model-context-protocol). It's a complementary standard that standardizes how an agent connects to its tools, APIs, and resources to get information.
- **IBM ACP**: [Incorporated into the A2A Protocol](https://github.com/orgs/i-am-bee/discussions/5)
- **Cisco agntcy**: A framework for building the internal logic of a single, complex agent system, often with a supervisor/expert structure.
- **A2A**: Provides agent-to-agent communication. As a universal, decentralized standard, A2A acts as the public internet that allows [ai agents](https://cloud.google.com/discover/what-are-ai-agents)‚Äîincluding those using MCP, or built with frameworks like agntcy‚Äîto interoperate, collaborate, and share their findings.

=================================================

--- START OF FILE docs/partners.md ---

# Partners

Below is a list of partners (and a link to their A2A announcement or blog post,
if available) who are part of the A2A community and are helping build, codify,
and adopt A2A as the standard protocol for AI agents to communicate and
collaborate effectively with each other and with users.

- [Accelirate Inc](https://www.accelirate.com)
- [Accenture](https://www.accenture.com)
- [Activeloop](https://www.activeloop.ai/)
- [Adobe](https://www.adobe.com)
- [AG2AI](https://ag2.ai)
- [AI21 Labs](https://www.ai21.com/)
- [AI71](https://ai71.ai/)
- [Aisera](https://aisera.com/)
- [Almawave.it](https://www.almawave.com/it/)
- [AliCloud](http://www.alibabacloud.com)
- [ArcBlock](http://www.arcblock.io)
- [Arize](https://arize.com/blog/arize-ai-and-future-of-agent-interoperability-embracing-googles-a2a-protocol/)
- [Articul8](https://www.articul8.ai/blog/unleashing-the-next-frontier-of-enterprise-ai-introducing-model-mesh-dock-and-inter-lock-and-our-a2-a-partnership-with-google)
- [ask-ai.com](https://ask-ai.com)
- [Atlassian](https://www.atlassian.com)
- [Auth0](https://auth0.com/blog/auth0-google-a2a/)
- [Autodesk](https://www.autodesk.com)
- [AWS](https://aws.amazon.com/)
- [Beekeeper](http://beekeeper.io)
- [BCG](https://www.bcg.com)
- [Block Inc](https://block.xyz/)
- [Bloomberg LP](https://techatbloomberg.com/)
- [BLUEISH Inc](https://www.blueish.co.jp/)
- [BMC Software Inc](https://www.bmc.com/it-solutions/bmc-helix.html)
- [Boomi](https://boomi.com/)
- [Box](https://www.box.com)
- [Bridge2Things Automation Process GmbH](http://bridge2things.at)
- [Cafe 24](https://www.cafe24corp.com/en/company/about)
- [C3 AI](https://c3.ai)
- [Capgemini](https://www.capgemini.com)
- [Chronosphere](https://chronosphere.io)
- [Cisco](https://www.cisco.com/)
- [Codimite PTE LTD](https://codimite.ai/)
- [Cognigy](https://www.cognigy.com/)
- [Cognizant](https://www.cognizant.com)
- [Cohere](https://cohere.com)
- [Collibra](https://www.collibra.com)
- [Confluent](https://developer.confluent.io)
- [Contextual](https://contextual.ai)
- [Cotality](https://cotality.com) (fka Corelogic)
- [Crubyt](https://www.crubyt.com)
- [Cyderes](http://www.cyderes.com)
- [Datadog](https://www.datadoghq.com)
- [DataRobot](https://www.datarobot.com)
- [DataStax](https://www.datastax.com)
- [Decagon.ai](https://decagon.ai)
- [Deloitte](https://www.prnewswire.com/news-releases/deloitte-expands-alliances-with-google-cloud-and-servicenow-to-accelerate-agentic-ai-adoption-in-the-enterprise-302423941.html)
- [Devnagri](https://devnagri.com)
- [Deutsche Telekom](https://www.telekom.com/en)
- [Dexter Tech Labs](http://www.dextertechlabs.com)
- [Distyl.ai](https://distyl.ai)
- [Elastic](https://www.elastic.co)
- [Ema.co](https://ema.co)
- [EPAM](https://www.epam.com)
- [Eviden (Atos Group)](https://atos.net/)
- [fractal.ai](https://fractal.ai/new)
- [GenAI Nebula9.ai Solutions Pvt Ltd](http://nebula9.ai)
- [Glean](https://www.glean.com)
- [Global Logic](https://www.globallogic.com/)
- [Gravitee](https://www.gravitee.io/)
- [GrowthLoop](https://growthloop.com)
- [Guru](http://www.getguru.com)
- [Harness](https://harness.io)
- [HCLTech](https://www.hcltech.com)
- [Headwaters](https://www.headwaters.co.jp)
- [Hellotars](https://hellotars.com)
- [Hexaware](https://hexaware.com/)
- [HUMAN](https://www.humansecurity.com/)
- [IBM Research](https://lfaidata.foundation/communityblog/2025/08/29/acp-joins-forces-with-a2a-under-the-linux-foundations-lf-ai-data/)
- [Incorta](https://www.incorta.com)
- [Infinitus](https://www.infinitus.ai/)
- [InfoSys](https://www.infosys.com)
- [Intuit](https://www.intuit.com)
- [Iron Mountain](https://www.ironmountain.com/)
- [JetBrains](https://www.jetbrains.com)
- [JFrog](https://jfrog.com)
- [Kakao](https://www.kakaocorp.com)
- [King's College London](https://www.kcl.ac.uk/informatics)
- [KPMG](https://kpmg.com/us/en/media/news/kpmg-google-cloud-alliance-expansion-agentspace-adoption.html)
- [Kyndryl](http://www.kyndryl.com)
- [LabelBox](https://labelbox.com)
- [LangChain](https://www.langchain.com)
- [LG CNS](http://www.lgcns.com)
- [Livex.ai](https://livex.ai)
- [LlamaIndex](https://x.com/llama_index/status/1912949446322852185)
- [LTIMindTtree](https://www.ltimindtree.com)
- [Lumeris](https://www.lumeris.com/)
- [Lyzr.ai](https://lyzr.ai)
- [Magyar Telekom](https://www.telekom.hu/)
- [Microsoft](https://www.microsoft.com/en-us/microsoft-cloud/blog/2025/05/07/empowering-multi-agent-apps-with-the-open-agent2agent-a2a-protocol/)
- [MindsDB](https://mindsdb.com/blog/mindsdb-now-supports-the-agent2agent-(a2a)-protocol)
- [McKinsey](https://www.mckinsey.com)
- [MongoDB](https://www.mongodb.com)
- [Monite](https://monite.com/)
- [Neo4j](https://neo4j.com)
- [New Relic](https://newrelic.com)
- [Nisum](http://www.nisum.com)
- [Noorle Inc](http://www.noorle.com)
- [Optimizely Inc](https://www.optimizely.com/)
- [Oracle / NetSuite](https://www.oracle.com/netsuite)
- [Palo Alto Networks](https://www.paloaltonetworks.com/)
- [PancakeAI](https://www.pancakeai.tech/)
- [ParkourSC](https://www.parkoursc.com/)
- [Pendo](https://www.pendo.io)
- [PerfAI.ai](https://perfai.ai)
- [Personal AI](https://personal.ai)
- [Poppulo](https://www.poppulo.com/blog/poppulo-google-a2a-the-future-of-workplace-communication)
- [Productive Edge](https://www.productiveedge.com/)
- [Proofs](https://proofs.io)
- [Publicis Sapient](https://www.publicissapient.com/)
- [PWC](https://www.pwc.com)
- [Quantiphi](https://www.quantiphi.com)
- [Radix](https://radix.website/)
- [RagaAI Inc](https://raga.ai/)
- [Red Hat](https://www.redhat.com)
- [Reltio Inc](http://www.reltio.com)
- [S&P](https://www.spglobal.com)
- [Sage](https://www.sage.com/en-us/)
- [Salesforce](https://www.salesforce.com)
- [SAP](https://news.sap.com/2025/04/sap-google-cloud-enterprise-ai-open-agent-collaboration-model-choice-multimodal-intelligence/)
- [Sayone Technologies](https://www.sayonetech.com/)
- [ServiceNow](https://www.servicenow.com)
- [Siemens AG](https://siemens.com/)
- [SoftBank Corp](https://www.softbank.jp/en//)
- [Solace](https://solace.com/products/agent-mesh/)
- [Solo.io](https://www.solo.io/)
- [Stacklok, Inc](https://stacklok.com)
- [Supertab](https://www.supertab.co/post/supertab-connect-partners-with-google-cloud-to-enable-ai-agents)
- [Suzega](https://suzega.com/)
- [TCS](https://www.tcs.com)
- [Tech Mahindra](https://www.techmahindra.com/)
- [Telefonica](https://www.telefonica.com/)
- [Test Innovation Technology](https://www.test-it.com)
- [the artinet project](https://artinet.io/)
- [Think41](http://www.think41.com)
- [Thoughtworks](https://www.thoughtworks.com/)
- [Tredence](http://www.tredence.com)
- [Two Tall Totems Ltd. DBA TTT Studios](https://ttt.studio)
- [Typeface](https://typeface.ai)
- [UKG](https://www.ukg.com)
- [UiPath](https://www.uipath.com/newsroom/uipath-launches-first-enterprise-grade-platform-for-agentic-automation)
- [Upwork, Inc.](https://www.upwork.com/)
- [Ushur, Inc.](http://ushur.ai)
- [Valle AI](http://www.valleai.com.br)
- [Valtech](https://www.valtech.com/)
- [Vervelo](https://www.vervelo.com/)
- [VoltAgent](https://voltagent.dev/)
- [Weights & Biases](https://wandb.ai/wandb_fc/product-announcements-fc/reports/Powering-Agent-Collaboration-Weights-Biases-Partners-with-Google-Cloud-on-Agent2Agent-Interoperability-Protocol---VmlldzoxMjE3NDg3OA)
- [Wipro](https://www.wipro.com)
- [Workday](https://www.workday.com)
- [Writer](https://writer.com)
- [Zenity](https://zenity.io)
- [Zeotap](https://www.zeotap.com)
- [Zocket Technologies , Inc.](https://zocket.ai)
- [Zoom](https://www.zoom.us)
- [zyprova](http://www.zyprova.com)

=================================================

--- START OF FILE docs/roadmap.md ---

# A2A protocol roadmap

**Last updated:** Jul 16, 2025

## Near-term initiatives

- Release `0.3` version of the protocol which we intend to keep supported and without breaking changes for a significant amount of time with backward compatibility of the SDKs starting at version `0.3`. As part of this release there are a few known breaking changes including:
    - Update the `/.well-known/agent.json` path for hosting Agent Cards to `/.well-known/agent-card.json` based on feedback from IANA.
    - Refactor class fields to be more Pythonic and adopt `snake_case`. [PR 199](https://github.com/a2aproject/a2a-python/pull/199)
- Solidify the support for [A2A extensions](topics/extensions.md) with SDK support (starting with the Python SDK) and publishing sample extensions.
- Introduce support for signed Agent Cards [Discussion 199](https://github.com/a2aproject/A2A/discussions/199#discussioncomment-13770576) to allow verifying the integrity of Agent Card content.
- Enhance the client side support in SDK (starting with Python) to expose ready-to-use A2A clients, streamlined auth handling and improved handling of tasks.

To review recent protocol changes see [Release Notes](https://github.com/a2aproject/A2A/releases).

## Longer term (3-6 month period) roadmap

### Governance

The protocol has been [donated](https://www.linuxfoundation.org/press/linux-foundation-launches-the-agent2agent-protocol-project-to-enable-secure-intelligent-communication-between-ai-agents) to the Linux Foundation. The TSC is working on implementing a governance structure that prioritizes community-led development with standardized processes for contributing to the specification, SDKs and tooling. As part of the effort there will be dedicated working groups created for specific areas of the protocol.

### Agent Registry

Agent Registry enables the discovery of agents and is a critical component of a multi-agent system. There is an active and ongoing discussion in the community around the latest [Discussion 741](https://github.com/a2aproject/A2A/discussions/741).

### Validation

As the A2A ecosystem matures, it becomes critical for the A2A community to have tools to validate their agents. The community has launched two efforts to help with validation which the group will continue to enhance in the coming months. Learn more about [A2A Inspector](https://github.com/a2aproject/a2a-inspector) and the [A2A Protocol Technology Compatibility Kit](https://github.com/a2aproject/a2a-tck) (TCK).

### SDKs

A2A Project currently hosts SDKs in four languages (Python, JS, Java, .NET) and contributors are adding more including Go (in progress).

### Community best practices

As companies and individuals deploy A2A systems at an increasing pace, we are looking to accelerate the learning of the community by collecting and sharing the best practices and success stories that A2A enabled.

=================================================

--- START OF FILE docs/sdk/index.md ---

# A2A SDK

A2A currently hosts SDKs in four languages (Python, JS, Java, .NET) and contributors are adding more, including Go.

The following table lists the supported languages and their stability.

| Language   | Support  |
| :--------- | :------- |
| Python     | [Stable](https://github.com/a2aproject/a2a-python) |
| Java       | [Stable](https://github.com/a2aproject/a2a-java)   |
| JavaScript | [Stable](https://github.com/a2aproject/a2a-js)     |
| C#/.NET    | [Stable](https://github.com/a2aproject/a2a-dotnet) |
| Go         | [In Progress](https://github.com/a2aproject/a2a-go)|

The A2A project provides numerous samples across supported languages in the [a2a-samples repository](https://github.com/a2aproject/a2a-samples).

=================================================

--- START OF FILE docs/sdk/python/a2a.auth.rst ---

a2a.auth package
================

Submodules
----------

a2a.auth.user module
--------------------

.. automodule:: a2a.auth.user
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.auth
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.client.auth.rst ---

a2a.client.auth package
=======================

Submodules
----------

a2a.client.auth.credentials module
----------------------------------

.. automodule:: a2a.client.auth.credentials
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.auth.interceptor module
----------------------------------

.. automodule:: a2a.client.auth.interceptor
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.client.auth
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.client.rst ---

a2a.client package
==================

Subpackages
-----------

.. toctree::
   :maxdepth: 4

   a2a.client.auth
   a2a.client.transports

Submodules
----------

a2a.client.base\_client module
------------------------------

.. automodule:: a2a.client.base_client
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.card\_resolver module
--------------------------------

.. automodule:: a2a.client.card_resolver
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.client module
------------------------

.. automodule:: a2a.client.client
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.client\_factory module
---------------------------------

.. automodule:: a2a.client.client_factory
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.client\_task\_manager module
---------------------------------------

.. automodule:: a2a.client.client_task_manager
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.errors module
------------------------

.. automodule:: a2a.client.errors
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.helpers module
-------------------------

.. automodule:: a2a.client.helpers
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.legacy module
------------------------

.. automodule:: a2a.client.legacy
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.legacy\_grpc module
------------------------------

.. automodule:: a2a.client.legacy_grpc
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.middleware module
----------------------------

.. automodule:: a2a.client.middleware
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.optionals module
---------------------------

.. automodule:: a2a.client.optionals
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.client
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.client.transports.rst ---

a2a.client.transports package
=============================

Submodules
----------

a2a.client.transports.base module
---------------------------------

.. automodule:: a2a.client.transports.base
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.transports.grpc module
---------------------------------

.. automodule:: a2a.client.transports.grpc
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.transports.jsonrpc module
------------------------------------

.. automodule:: a2a.client.transports.jsonrpc
   :members:
   :show-inheritance:
   :undoc-members:

a2a.client.transports.rest module
---------------------------------

.. automodule:: a2a.client.transports.rest
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.client.transports
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.extensions.rst ---

a2a.extensions package
======================

Submodules
----------

a2a.extensions.common module
----------------------------

.. automodule:: a2a.extensions.common
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.extensions
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.grpc.rst ---

a2a.grpc package
================

Submodules
----------

a2a.grpc.a2a\_pb2 module
------------------------

.. automodule:: a2a.grpc.a2a_pb2
   :members:
   :show-inheritance:
   :undoc-members:

a2a.grpc.a2a\_pb2\_grpc module
------------------------------

.. automodule:: a2a.grpc.a2a_pb2_grpc
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.grpc
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.rst ---

a2a package
===========

Subpackages
-----------

.. toctree::
   :maxdepth: 4

   a2a.auth
   a2a.client
   a2a.extensions
   a2a.grpc
   a2a.server
   a2a.utils

Submodules
----------

a2a.types module
----------------

.. automodule:: a2a.types
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.agent_execution.rst ---

a2a.server.agent\_execution package
===================================

Submodules
----------

a2a.server.agent\_execution.agent\_executor module
--------------------------------------------------

.. automodule:: a2a.server.agent_execution.agent_executor
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.agent\_execution.context module
------------------------------------------

.. automodule:: a2a.server.agent_execution.context
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.agent\_execution.request\_context\_builder module
------------------------------------------------------------

.. automodule:: a2a.server.agent_execution.request_context_builder
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.agent\_execution.simple\_request\_context\_builder module
--------------------------------------------------------------------

.. automodule:: a2a.server.agent_execution.simple_request_context_builder
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server.agent_execution
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.apps.jsonrpc.rst ---

a2a.server.apps.jsonrpc package
===============================

Submodules
----------

a2a.server.apps.jsonrpc.fastapi\_app module
-------------------------------------------

.. automodule:: a2a.server.apps.jsonrpc.fastapi_app
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.apps.jsonrpc.jsonrpc\_app module
-------------------------------------------

.. automodule:: a2a.server.apps.jsonrpc.jsonrpc_app
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.apps.jsonrpc.starlette\_app module
---------------------------------------------

.. automodule:: a2a.server.apps.jsonrpc.starlette_app
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server.apps.jsonrpc
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.apps.rest.rst ---

a2a.server.apps.rest package
============================

Submodules
----------

a2a.server.apps.rest.fastapi\_app module
----------------------------------------

.. automodule:: a2a.server.apps.rest.fastapi_app
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.apps.rest.rest\_adapter module
-----------------------------------------

.. automodule:: a2a.server.apps.rest.rest_adapter
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server.apps.rest
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.apps.rst ---

a2a.server.apps package
=======================

Subpackages
-----------

.. toctree::
   :maxdepth: 4

   a2a.server.apps.jsonrpc
   a2a.server.apps.rest

Module contents
---------------

.. automodule:: a2a.server.apps
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.events.rst ---

a2a.server.events package
=========================

Submodules
----------

a2a.server.events.event\_consumer module
----------------------------------------

.. automodule:: a2a.server.events.event_consumer
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.events.event\_queue module
-------------------------------------

.. automodule:: a2a.server.events.event_queue
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.events.in\_memory\_queue\_manager module
---------------------------------------------------

.. automodule:: a2a.server.events.in_memory_queue_manager
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.events.queue\_manager module
---------------------------------------

.. automodule:: a2a.server.events.queue_manager
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server.events
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.request_handlers.rst ---

a2a.server.request\_handlers package
====================================

Submodules
----------

a2a.server.request\_handlers.default\_request\_handler module
-------------------------------------------------------------

.. automodule:: a2a.server.request_handlers.default_request_handler
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.request\_handlers.grpc\_handler module
-------------------------------------------------

.. automodule:: a2a.server.request_handlers.grpc_handler
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.request\_handlers.jsonrpc\_handler module
----------------------------------------------------

.. automodule:: a2a.server.request_handlers.jsonrpc_handler
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.request\_handlers.request\_handler module
----------------------------------------------------

.. automodule:: a2a.server.request_handlers.request_handler
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.request\_handlers.response\_helpers module
-----------------------------------------------------

.. automodule:: a2a.server.request_handlers.response_helpers
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.request\_handlers.rest\_handler module
-------------------------------------------------

.. automodule:: a2a.server.request_handlers.rest_handler
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server.request_handlers
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.rst ---

a2a.server package
==================

Subpackages
-----------

.. toctree::
   :maxdepth: 4

   a2a.server.agent_execution
   a2a.server.apps
   a2a.server.events
   a2a.server.request_handlers
   a2a.server.tasks

Submodules
----------

a2a.server.context module
-------------------------

.. automodule:: a2a.server.context
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.id\_generator module
-------------------------------

.. automodule:: a2a.server.id_generator
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.models module
------------------------

.. automodule:: a2a.server.models
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.server.tasks.rst ---

a2a.server.tasks package
========================

Submodules
----------

a2a.server.tasks.base\_push\_notification\_sender module
--------------------------------------------------------

.. automodule:: a2a.server.tasks.base_push_notification_sender
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.database\_push\_notification\_config\_store module
-------------------------------------------------------------------

.. automodule:: a2a.server.tasks.database_push_notification_config_store
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.database\_task\_store module
---------------------------------------------

.. automodule:: a2a.server.tasks.database_task_store
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.inmemory\_push\_notification\_config\_store module
-------------------------------------------------------------------

.. automodule:: a2a.server.tasks.inmemory_push_notification_config_store
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.inmemory\_task\_store module
---------------------------------------------

.. automodule:: a2a.server.tasks.inmemory_task_store
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.push\_notification\_config\_store module
---------------------------------------------------------

.. automodule:: a2a.server.tasks.push_notification_config_store
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.push\_notification\_sender module
--------------------------------------------------

.. automodule:: a2a.server.tasks.push_notification_sender
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.result\_aggregator module
------------------------------------------

.. automodule:: a2a.server.tasks.result_aggregator
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.task\_manager module
-------------------------------------

.. automodule:: a2a.server.tasks.task_manager
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.task\_store module
-----------------------------------

.. automodule:: a2a.server.tasks.task_store
   :members:
   :show-inheritance:
   :undoc-members:

a2a.server.tasks.task\_updater module
-------------------------------------

.. automodule:: a2a.server.tasks.task_updater
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.server.tasks
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/a2a.utils.rst ---

a2a.utils package
=================

Submodules
----------

a2a.utils.artifact module
-------------------------

.. automodule:: a2a.utils.artifact
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.constants module
--------------------------

.. automodule:: a2a.utils.constants
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.error\_handlers module
--------------------------------

.. automodule:: a2a.utils.error_handlers
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.errors module
-----------------------

.. automodule:: a2a.utils.errors
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.helpers module
------------------------

.. automodule:: a2a.utils.helpers
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.message module
------------------------

.. automodule:: a2a.utils.message
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.parts module
----------------------

.. automodule:: a2a.utils.parts
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.proto\_utils module
-----------------------------

.. automodule:: a2a.utils.proto_utils
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.task module
---------------------

.. automodule:: a2a.utils.task
   :members:
   :show-inheritance:
   :undoc-members:

a2a.utils.telemetry module
--------------------------

.. automodule:: a2a.utils.telemetry
   :members:
   :show-inheritance:
   :undoc-members:

Module contents
---------------

.. automodule:: a2a.utils
   :members:
   :show-inheritance:
   :undoc-members:

=================================================

--- START OF FILE docs/sdk/python/index.rst ---

A2A Python SDK Reference
========================

This page contains the SDK documentation for the ``a2a-sdk`` Python package.

.. code-block:: sh

   pip install a2a-sdk

.. toctree::
   :maxdepth: 4

   a2a

=================================================

--- START OF FILE docs/sdk/python/modules.rst ---

a2a
===

.. toctree::
   :maxdepth: 4

   a2a

=================================================

--- START OF FILE docs/specification.md ---

# Agent2Agent (A2A) Protocol Official Specification

{% macro render_spec_tabs(region_tag) %}
=== "JSON-RPC"

    ```ts { .no-copy }
    --8<-- "types/src/types.ts:{{ region_tag }}"
    ```

=== "gRPC"

    ```proto { .no-copy }
    --8<-- "specification/grpc/a2a.proto:{{ region_tag }}"
    ```
{% endmacro %}

??? note "**Latest Released Version** [`0.3.0`](https://a2a-protocol.org/v0.3.0/specification)"

    **Previous Versions**

    - [`0.2.6`](https://a2a-protocol.org/v0.2.6/specification)
    - [`0.2.5`](https://a2a-protocol.org/v0.2.5/specification)
    - [`0.2.4`](https://a2a-protocol.org/v0.2.4/specification)
    - [`0.2.0`](https://a2a-protocol.org/v0.2.0/specification)
    - [`0.1.0`](https://a2a-protocol.org/v0.1.0/specification)

See [Release Notes](https://github.com/a2aproject/A2A/releases) for changes made between versions.

## 1. Introduction

The Agent2Agent (A2A) Protocol is an open standard designed to facilitate communication and interoperability between independent, potentially opaque AI agent systems. In an ecosystem where agents might be built using different frameworks, languages, or by different vendors, A2A provides a common language and interaction model.

This document provides the detailed technical specification for the A2A protocol. Its primary goal is to enable agents to:

- Discover each other's capabilities.
- Negotiate interaction modalities (text, files, structured data).
- Manage collaborative tasks.
- Securely exchange information to achieve user goals **without needing access to each other's internal state, memory, or tools.**

### 1.1. Key Goals of A2A

- **Interoperability:** Bridge the communication gap between disparate agentic systems.
- **Collaboration:** Enable agents to delegate tasks, exchange context, and work together on complex user requests.
- **Discovery:** Allow agents to dynamically find and understand the capabilities of other agents.
- **Flexibility:** Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.
- **Security:** Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.
- **Asynchronicity:** Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.

### 1.2. Guiding Principles

- **Simple:** Reuse existing, well-understood standards (HTTP, JSON-RPC 2.0, Server-Sent Events).
- **Enterprise Ready:** Address authentication, authorization, security, privacy, tracing, and monitoring by aligning with established enterprise practices.
- **Async First:** Designed for (potentially very) long-running tasks and human-in-the-loop interactions.
- **Modality Agnostic:** Support exchange of diverse content types including text, audio/video (via file references), structured data/forms, and potentially embedded UI components (e.g., iframes referenced in parts).
- **Opaque Execution:** Agents collaborate based on declared capabilities and exchanged information, without needing to share their internal thoughts, plans, or tool implementations.

For a broader understanding of A2A's purpose and benefits, see [What is A2A?](./topics/what-is-a2a.md).

## 2. Core Concepts Summary

A2A revolves around several key concepts. For detailed explanations, please refer to the [Key Concepts guide](./topics/key-concepts.md).

- **A2A Client:** An application or agent that initiates requests to an A2A Server on behalf of a user or another system.
- **A2A Server (Remote Agent):** An agent or agentic system that exposes an A2A-compliant HTTP endpoint, processing tasks and providing responses.
- **Agent Card:** A JSON metadata document published by an A2A Server, describing its identity, capabilities, skills, service endpoint, and authentication requirements.
- **Message:** A communication turn between a client and a remote agent, having a `role` ("user" or "agent") and containing one or more `Parts`.
- **Task:** The fundamental unit of work managed by A2A, identified by a unique ID. Tasks are stateful and progress through a defined lifecycle.
- **Part:** The smallest unit of content within a Message or Artifact (e.g., `TextPart`, `FilePart`, `DataPart`).
- **Artifact:** An output (e.g., a document, image, structured data) generated by the agent as a result of a task, composed of `Parts`.
- **Streaming (SSE):** Real-time, incremental updates for tasks (status changes, artifact chunks) delivered via Server-Sent Events.
- **Push Notifications:** Asynchronous task updates delivered via server-initiated HTTP POST requests to a client-provided webhook URL, for long-running or disconnected scenarios.
- **Context:** An optional, server-generated identifier to logically group related tasks.
- **Extension:** A mechanism for agents to provide additional functionality or data beyond the core A2A specification.

## 3. Transport and Format

### 3.1. Transport Layer Requirements

A2A supports multiple transport protocols, all operating over **HTTP(S)**. Agents have flexibility in choosing which transport protocols to implement based on their specific requirements and use cases:

- A2A communication **MUST** occur over **HTTP(S)**.
- The A2A Server exposes its service at one or more URLs defined in its `AgentCard`.
- Agents **MUST** implement at least one of the three core transport protocols defined in this specification.
- All supported transport protocols are considered equal in status and capability.

### 3.2. Supported Transport Protocols

A2A defines three core transport protocols. **A2A-compliant agents SHOULD implement at least one of these transport protocols. They MAY be compliant implementing a transport extension as defined in [3.2.4](#324-transport-extensions)** All three protocols are considered equal in status, and agents may choose to implement any combination of them based on their requirements.

#### 3.2.1. JSON-RPC 2.0 Transport

Agents **MAY** support JSON-RPC 2.0 transport. If implemented, it **MUST** conform to these requirements:

- The primary data format is **[JSON-RPC 2.0](https://www.jsonrpc.org/specification)** for all requests and responses (excluding SSE stream wrapper).
- Client requests and server responses **MUST** adhere to the JSON-RPC 2.0 specification.
- The `Content-Type` header for HTTP requests and responses containing JSON-RPC payloads **MUST** be `application/json`.
- Method names follow the pattern `{category}/{action}` (e.g., `"message/send"`, `"tasks/get"`).

#### 3.2.2. gRPC Transport

Agents **MAY** support gRPC transport. If implemented, it **MUST** conform to these requirements:

- **Protocol Definition**: **MUST** use the normative Protocol Buffers definition in [`specification/grpc/a2a.proto`](https://github.com/a2aproject/A2A/blob/main/specification/grpc/a2a.proto).
- **Message Serialization**: **MUST** use Protocol Buffers version 3 for message serialization.
- **Service Definition**: **MUST** implement the `A2AService` gRPC service as defined in the proto file.
- **Method Coverage**: **MUST** provide all methods with functionally equivalent behavior to other supported transports.
- **Field Mapping**: **MUST** use the `json_name` annotations for HTTP/JSON transcoding compatibility.
- **Error Handling**: **MUST** map A2A error codes to appropriate gRPC status codes as defined in the proto annotations.
- **Transport Security**: **MUST** support TLS encryption (gRPC over HTTP/2 with TLS).

#### 3.2.3. HTTP+JSON/REST Transport

Agents **MAY** support REST-style HTTP+JSON transport. If implemented, it **MUST** conform to these requirements:

- **HTTP Methods**: **MUST** use appropriate HTTP verbs (GET for queries, POST for actions, PUT for updates, DELETE for removal).
- **URL Patterns**: **MUST** follow the URL patterns documented in each method section (e.g., `/v1/message:send`, `/v1/tasks/{id}`).
- **Content-Type**: **MUST** use `application/json` for request and response bodies.
- **HTTP Status Codes**: **MUST** use appropriate HTTP status codes (200, 400, 401, 403, 404, 500, etc.) that correspond to A2A error types.
- **Request/Response Format**: **MUST** use JSON objects that are structurally equivalent to the core A2A data structures.
- **Method Coverage**: **MUST** provide all methods with functionally equivalent behavior to other supported transports.
- **Error Format**: **MUST** return error responses in a consistent JSON format that maps to A2A error types.

#### 3.2.4. Transport Extensions

Additional transport protocols **MAY** be defined as extensions to the core A2A specification. Such extensions:

- **MUST** maintain functional equivalence with the core transports
- **MUST** use clear namespace identifiers to avoid conflicts
- **MUST** be clearly documented and specified
- **SHOULD** provide migration paths from core transports

### 3.3. Streaming Transport (Server-Sent Events)

Streaming capabilities are **transport-specific**:

#### 3.3.1. JSON-RPC 2.0 Streaming

When streaming is used for methods like `message/stream` or `tasks/resubscribe`:

- The server responds with an HTTP `200 OK` status and a `Content-Type` header of `text/event-stream`.
- The body of this HTTP response contains a stream of **[Server-Sent Events (SSE)](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events)** as defined by the W3C.
- Each SSE `data` field contains a complete JSON-RPC 2.0 Response object (specifically, a [`SendStreamingMessageResponse`](#721-sendstreamingmessageresponse-object)).

#### 3.3.2. gRPC Streaming

gRPC transport uses **server streaming RPCs** for streaming operations as defined in the Protocol Buffers specification.

#### 3.3.3. HTTP+JSON/REST Streaming

If REST transport is supported it **MUST** implement streaming using Server-Sent Events similar to JSON-RPC.

### 3.4. Transport Compliance and Interoperability

#### 3.4.1. Functional Equivalence Requirements

When an agent supports multiple transports, all supported transports **MUST**:

- **Identical Functionality**: Provide the same set of operations and capabilities.
- **Consistent Behavior**: Return semantically equivalent results for the same requests.
- **Same Error Handling**: Map errors consistently across transports using the error codes defined in [Section 8](#8-error-handling).
- **Equivalent Authentication**: Support the same authentication schemes declared in the `AgentCard`.

#### 3.4.2. Transport Selection and Negotiation

- **Agent Declaration**: Agents **MUST** declare all supported transports in their `AgentCard` using the `preferredTransport` and `additionalInterfaces` fields.
- **Client Choice**: Clients **MAY** choose any transport declared by the agent.
- **No Transport Negotiation**: A2A does not define a dynamic transport negotiation protocol. Clients select a transport based on the static `AgentCard` information.
- **Fallback Behavior**: Clients **SHOULD** implement fallback logic to try alternative transports if their preferred transport fails. The specific fallback strategy is implementation-dependent.

#### 3.4.3. Transport-Specific Extensions

Transports **MAY** provide transport-specific optimizations or extensions that do not compromise functional equivalence:

- **gRPC**: May leverage gRPC-specific features like bidirectional streaming, metadata, or custom status codes.
- **REST**: May provide additional HTTP caching headers or support HTTP conditional requests.
- **JSON-RPC**: May include additional fields in the JSON-RPC request/response objects that do not conflict with the core specification.

Such extensions **MUST** be backward-compatible and **MUST NOT** break interoperability with clients that do not support the extensions.

### 3.5. Method Mapping and Naming Conventions

To ensure consistency and predictability across different transports, A2A defines normative method mapping rules.

#### 3.5.1. JSON-RPC Method Naming

JSON-RPC methods **MUST** follow the pattern: `{category}/{action}` where:

- `category` represents the resource type (e.g., "message", "tasks", "agent")
- `action` represents the operation (e.g., "send", "get", "cancel")
- Nested actions use forward slashes (e.g., "tasks/pushNotificationConfig/set")

#### 3.5.2. gRPC Method Naming

gRPC methods **MUST** follow Protocol Buffers service conventions using PascalCase:

- Convert JSON-RPC category/action to PascalCase compound words
- Use standard gRPC method prefixes (Get, Set, List, Create, Delete, Cancel)

#### 3.5.3. HTTP+JSON/REST Method Naming

REST endpoints **MUST** follow RESTful URL patterns with appropriate HTTP verbs:

- Use resource-based URLs: `/v1/{resource}[/{id}][:{action}]`
- Use standard HTTP methods aligned with REST semantics
- Use colon notation for non-CRUD actions

#### 3.5.4. Method Mapping Compliance

When implementing multiple transports, agents **MUST**:

- **Use standard mappings**: Follow the method mappings defined in sections 3.5.2 and 3.5.3.
- **Maintain functional equivalence**: Each transport-specific method **MUST** provide identical functionality across all supported transports.
- **Consistent parameters**: Use equivalent parameter structures across transports (accounting for transport-specific serialization differences).
- **Equivalent responses**: Return semantically equivalent responses across all transports for the same operation.

#### 3.5.5. Extension Method Naming

For custom or extension methods not defined in the core A2A specification:

- **JSON-RPC**: Follow the `{category}/{action}` pattern with a clear namespace (e.g., `myorg.extension/action`)
- **gRPC**: Use appropriate service and method names following Protocol Buffers conventions
- **REST**: Use clear resource-based URLs with appropriate HTTP methods

Extension methods **MUST** be clearly documented and **MUST NOT** conflict with core A2A method names or semantics.

#### 3.5.6. Method Mapping Reference Table

For quick reference, the following table summarizes the method mappings across all transports:

| JSON-RPC Method | gRPC Method | REST Endpoint | Description |
|:----------------|:------------|:--------------|:------------|
| `message/send` | `SendMessage` | `POST /v1/message:send` | Send message to agent |
| `message/stream` | `SendStreamingMessage` | `POST /v1/message:stream` | Send message with streaming |
| `tasks/get` | `GetTask` | `GET /v1/tasks/{id}` | Get task status |
| `tasks/list` | `ListTask` | `GET /v1/tasks` | List tasks (gRPC/REST only) |
| `tasks/cancel` | `CancelTask` | `POST /v1/tasks/{id}:cancel` | Cancel task |
| `tasks/resubscribe` | `TaskSubscription` | `POST /v1/tasks/{id}:subscribe` | Resume task streaming |
| `tasks/pushNotificationConfig/set` | `CreateTaskPushNotification` | `POST /v1/tasks/{id}/pushNotificationConfigs` | Set push notification config |
| `tasks/pushNotificationConfig/get` | `GetTaskPushNotification` | `GET /v1/tasks/{id}/pushNotificationConfigs/{configId}` | Get push notification config |
| `tasks/pushNotificationConfig/list` | `ListTaskPushNotification` | `GET /v1/tasks/{id}/pushNotificationConfigs` | List push notification configs |
| `tasks/pushNotificationConfig/delete` | `DeleteTaskPushNotification` | `DELETE /v1/tasks/{id}/pushNotificationConfigs/{configId}` | Delete push notification config |
| `agent/getAuthenticatedExtendedCard` | `GetAgentCard` | `GET /v1/card` | Get authenticated agent card |

## 4. Authentication and Authorization

A2A treats agents as standard enterprise applications, relying on established web security practices. Identity information is **not** transmitted within A2A JSON-RPC payloads; it is handled at the HTTP transport layer.

For a comprehensive guide on enterprise security aspects, see [Enterprise-Ready Features](./topics/enterprise-ready.md).

### 4.1. Transport Security

As stated in section 3.1, production deployments **MUST** use HTTPS. Implementations **SHOULD** use modern [TLS](https://datatracker.ietf.org/doc/html/rfc8446) configurations (TLS 1.3+ recommended) with strong cipher suites.

### 4.2. Server Identity Verification

A2A Clients **SHOULD** verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.

### 4.3. Client/User Identity & Authentication Process

1. **Discovery of Requirements:** The client discovers the server's required authentication schemes via the `authentication` field in the [`AgentCard`](#55-agentcard-object-structure). Scheme names often align with [OpenAPI Authentication methods](https://swagger.io/docs/specification/authentication/) (e.g., "Bearer" for OAuth 2.0 tokens, "Basic" for Basic Auth, "ApiKey" for API keys).
2. **Credential Acquisition (Out-of-Band):** The client obtains the necessary credentials (e.g., API keys, OAuth tokens, JWTs) through an **out-of-band process** specific to the required authentication scheme and the identity provider. This process is outside the scope of the A2A protocol itself.
3. **Credential Transmission:** The client includes these credentials in the appropriate [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) (e.g., `Authorization: Bearer <token>`, `X-API-Key: <value>`) of every A2A request sent to the server.

### 4.4. Server Responsibilities for Authentication

The A2A Server:

- **MUST** authenticate every incoming request based on the provided HTTP credentials and its declared authentication requirements from its Agent Card.
- **SHOULD** use standard HTTP status codes like [`401 Unauthorized`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401) or [`403 Forbidden`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403) for authentication challenges or rejections.
- **SHOULD** include relevant HTTP headers (e.g., [`WWW-Authenticate`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate)) with `401 Unauthorized` responses to indicate the required authentication scheme(s), guiding the client.
- **SHOULD** verify the Client's webhook server identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.

### 4.5. In-Task Authentication (Secondary Credentials)

If an agent, during the execution of a task, requires _additional_ credentials for a _different_ system or resource (e.g., to access a specific tool on behalf of the user that requires its own auth):

1. It **SHOULD** transition the A2A task to the `auth-required` state (see [`TaskState`](#63-taskstate-enum)).
2. The accompanying `TaskStatus.message` (often a [`DataPart`](#653-datapart-object)) **SHOULD** provide details about the required secondary authentication, potentially using an [`PushNotificationAuthenticationInfo`](#69-pushnotificationauthenticationinfo-object)-like structure to describe the need.
3. The A2A Client then obtains these new credentials out-of-band and provides them in a subsequent [`message/send`](#71-messagesend) or [`message/stream`](#72-messagestream) request. How these credentials are used (e.g., passed as data within the A2A message if the agent is proxying, or used by the client to interact directly with the secondary system) depends on the specific scenario.

### 4.6. Authorization

Once a client is authenticated, the A2A Server is responsible for authorizing the request based on the authenticated client/user identity and its own policies. Authorization logic is implementation-specific and MAY be enforced based on:

- The specific skills requested (e.g., as identified by `AgentSkill.id` from the Agent Card).
- The actions attempted within the task.
- Data access policies relevant to the resources the agent manages.
- OAuth scopes associated with the presented token, if applicable.

Servers should implement the principle of least privilege.

## 5. Agent Discovery: The Agent Card

### 5.1. Purpose

A2A Servers **MUST** make an Agent Card available. The Agent Card is a JSON document that describes the server's identity, capabilities, skills, service endpoint URL, and how clients should authenticate and interact with it. Clients use this information for discovering suitable agents and for configuring their interactions.

For more on discovery strategies, see the [Agent Discovery guide](./topics/agent-discovery.md).

### 5.2. Discovery Mechanisms

Clients can find Agent Cards through various methods, including but not limited to:

- **Well-Known URI:** Accessing a predefined path on the agent's domain (see [Section 5.3](#53-recommended-location)).
- **Registries/Catalogs:** Querying curated catalogs or registries of agents (which might be enterprise-specific, public, or domain-specific).
- **Direct Configuration:** Clients may be pre-configured with the Agent Card URL or the card content itself.

### 5.3. Recommended Location

If using the well-known URI strategy, the recommended location for an agent's Agent Card is:
`https://{server_domain}/.well-known/agent-card.json`
This follows the principles of [RFC 8615](https://datatracker.ietf.org/doc/html/rfc8615) for well-known URIs.

### 5.4. Security of Agent Cards

Agent Cards themselves might contain information that is considered sensitive.

- If an Agent Card contains sensitive information, the endpoint serving the card **MUST** be protected by appropriate access controls (e.g., mTLS, network restrictions, authentication required to fetch the card).
- It is generally **NOT RECOMMENDED** to include plaintext secrets (like static API keys) directly in an Agent Card. Prefer authentication schemes where clients obtain dynamic credentials out-of-band.

### 5.5. `AgentCard` Object Structure

{{ render_spec_tabs('AgentCard') }}

#### 5.5.1. `AgentProvider` Object

Information about the organization or entity providing the agent.

{{ render_spec_tabs('AgentProvider') }}

#### 5.5.2. `AgentCapabilities` Object

Specifies optional A2A protocol features supported by the agent.

{{ render_spec_tabs('AgentCapabilities') }}

#### 5.5.2.1. `AgentExtension` Object

Specifies an extension to the A2A protocol supported by the agent.

{{ render_spec_tabs('AgentExtension') }}

#### 5.5.3. `SecurityScheme` Object

Describes the authentication requirements for accessing the agent's `url` endpoint. Refer [Sample Agent Card](#57-sample-agent-card) for an example.

{{ render_spec_tabs('SecurityScheme') }}

#### 5.5.4. `AgentSkill` Object

Describes a specific capability, function, or area of expertise the agent can perform or address.

{{ render_spec_tabs('AgentSkill') }}

#### 5.5.5. `AgentInterface` Object

Provides a declaration of a combination of the target URL and the supported transport to interact with the agent. This enables agents to expose the same functionality through multiple transport protocols.

```ts { .no-copy }
--8<-- "types/src/types.ts:TransportProtocol"
```

{{ render_spec_tabs('AgentInterface') }}

The `transport` field **SHOULD** use one of the core A2A transport protocol values:

- `"JSONRPC"`: JSON-RPC 2.0 over HTTP
- `"GRPC"`: gRPC over HTTP/2
- `"HTTP+JSON"`: REST-style HTTP with JSON

Additional transport values **MAY** be used for future extensions, but such extensions **MUST** not conflict with core A2A protocol functionality.

#### 5.5.6. `AgentCardSignature` Object

Represents a JSON Web Signature (JWS) used to verify the integrity of the AgentCard.

{{ render_spec_tabs('AgentCardSignature') }}

### 5.6. Transport Declaration and URL Relationships

The AgentCard **MUST** properly declare the relationship between URLs and transport protocols:

#### 5.6.1. Main URL and Preferred Transport

- **Main URL requirement**: The `url` field **MUST** specify the primary endpoint for the agent.
- **Transport correspondence**: The transport protocol available at the main `url` **MUST** match the `preferredTransport` field.
- **Required declaration**: The `preferredTransport` field is **REQUIRED** and **MUST** be present in every `AgentCard`.
- **Transport availability**: The main `url` **MUST** support the transport protocol declared in `preferredTransport`.

#### 5.6.2. Additional Interfaces

- **URL uniqueness**: Each `AgentInterface` in `additionalInterfaces` **SHOULD** specify a distinct URL for clarity, but **MAY** reuse URLs if multiple transport protocols are available at the same endpoint.
- **Transport declaration**: Each `AgentInterface` **MUST** accurately declare the transport protocol available at its specified URL.
- **Completeness**: The `additionalInterfaces` array **SHOULD** include all supported transports, including the main URL's transport for completeness.

#### 5.6.3. Client Transport Selection Rules

Clients **MUST** follow these rules when selecting a transport:

1. **Parse transport declarations**: Extract available transports from both the main `url`/`preferredTransport` combination and all `additionalInterfaces`.
2. **Prefer declared preference**: If the client supports the `preferredTransport`, it **SHOULD** use the main `url`.
3. **Fallback selection**: If the preferred transport is not supported by the client, it **MAY** select any supported transport from `additionalInterfaces`.
4. **Graceful degradation**: Clients **SHOULD** implement fallback logic to try alternative transports if their first choice fails.
5. **URL-transport matching**: Clients **MUST** use the correct URL for the selected transport protocol as declared in the AgentCard.

#### 5.6.4. Validation Requirements

Agent Cards **MUST** satisfy these validation requirements:

- **Transport consistency**: The `preferredTransport` value **MUST** be present and **MUST** be available at the main `url`.
- **Interface completeness**: If `additionalInterfaces` is provided, it **SHOULD** include an entry corresponding to the main `url` and `preferredTransport`.
- **No conflicts**: The same URL **MUST NOT** declare conflicting transport protocols across different interface declarations.
- **Minimum transport requirement**: The agent **MUST** declare at least one supported transport protocol through either the main `url`/`preferredTransport` combination or `additionalInterfaces`.

### 5.7. Sample Agent Card

```json
{
  "protocolVersion": "0.2.9",
  "name": "GeoSpatial Route Planner Agent",
  "description": "Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.",
  "url": "https://georoute-agent.example.com/a2a/v1",
  "preferredTransport": "JSONRPC",
  "additionalInterfaces" : [
    {"url": "https://georoute-agent.example.com/a2a/v1", "transport": "JSONRPC"},
    {"url": "https://georoute-agent.example.com/a2a/grpc", "transport": "GRPC"},
    {"url": "https://georoute-agent.example.com/a2a/json", "transport": "HTTP+JSON"}
  ],
  "provider": {
    "organization": "Example Geo Services Inc.",
    "url": "https://www.examplegeoservices.com"
  },
  "iconUrl": "https://georoute-agent.example.com/icon.png",
  "version": "1.2.0",
  "documentationUrl": "https://docs.examplegeoservices.com/georoute-agent/api",
  "capabilities": {
    "streaming": true,
    "pushNotifications": true,
    "stateTransitionHistory": false
  },
  "securitySchemes": {
    "google": {
      "type": "openIdConnect",
      "openIdConnectUrl": "https://accounts.google.com/.well-known/openid-configuration"
    }
  },
  "security": [{ "google": ["openid", "profile", "email"] }],
  "defaultInputModes": ["application/json", "text/plain"],
  "defaultOutputModes": ["application/json", "image/png"],
  "skills": [
    {
      "id": "route-optimizer-traffic",
      "name": "Traffic-Aware Route Optimizer",
      "description": "Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).",
      "tags": ["maps", "routing", "navigation", "directions", "traffic"],
      "examples": [
        "Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.",
        "{\"origin\": {\"lat\": 37.422, \"lng\": -122.084}, \"destination\": {\"lat\": 37.7749, \"lng\": -122.4194}, \"preferences\": [\"avoid_ferries\"]}"
      ],
      "inputModes": ["application/json", "text/plain"],
      "outputModes": [
        "application/json",
        "application/vnd.geo+json",
        "text/html"
      ]
    },
    {
      "id": "custom-map-generator",
      "name": "Personalized Map Generator",
      "description": "Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.",
      "tags": ["maps", "customization", "visualization", "cartography"],
      "examples": [
        "Generate a map of my upcoming road trip with all planned stops highlighted.",
        "Show me a map visualizing all coffee shops within a 1-mile radius of my current location."
      ],
      "inputModes": ["application/json"],
      "outputModes": [
        "image/png",
        "image/jpeg",
        "application/json",
        "text/html"
      ]
    }
  ],
  "supportsAuthenticatedExtendedCard": true,
  "signatures": [
    {
      "protected": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpPU0UiLCJraWQiOiJrZXktMSIsImprdSI6Imh0dHBzOi8vZXhhbXBsZS5jb20vYWdlbnQvandrcy5qc29uIn0",
      "signature": "QFdkNLNszlGj3z3u0YQGt_T9LixY3qtdQpZmsTdDHDe3fXV9y9-B3m2-XgCpzuhiLt8E0tV6HXoZKHv4GtHgKQ"
    }
  ]
}
```

## 6. Protocol Data Objects

These objects define the structure of data exchanged within the JSON-RPC methods of the A2A protocol.

### 6.1. `Task` Object

Represents the stateful unit of work being processed by the A2A Server for an A2A Client. A task encapsulates the entire interaction related to a specific goal or request. A task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Tasks in completed state SHOULD use artifacts for returning the generated output to the clients. For more information, refer to the [Life of a Task guide](./topics/life-of-a-task.md).

{{ render_spec_tabs('Task') }}

### 6.2. `TaskStatus` Object

Represents the current state and associated context (e.g., a message from the agent) of a `Task`.

{{ render_spec_tabs('TaskStatus') }}

### 6.3. `TaskState` Enum

Defines the possible lifecycle states of a `Task`.

{{ render_spec_tabs('TaskState') }}

### 6.4. `Message` Object

Represents a single communication turn or a piece of contextual information between a client and an agent. Messages are used for instructions, prompts, replies, and status updates.

{{ render_spec_tabs('Message') }}

### 6.5. `Part` Union Type

Represents a distinct piece of content within a `Message` or `Artifact`. A `Part` is a union type representing exportable content as either `TextPart`, `FilePart`, or `DataPart`. All `Part` types also include an optional `metadata` field (`Record<string, any>`) for part-specific metadata.

{{ render_spec_tabs('Part') }}

```ts { .no-copy }
--8<-- "types/src/types.ts:PartBase"
```

It **MUST** be one of the following:

#### 6.5.1. `TextPart` Object

For conveying plain textual content.

```ts { .no-copy }
--8<-- "types/src/types.ts:TextPart"
```

#### 6.5.2. `FilePart` Object

For conveying file-based content.

{{ render_spec_tabs('FilePart') }}

#### 6.5.3. `DataPart` Object

For conveying structured JSON data. Useful for forms, parameters, or any machine-readable information.

{{ render_spec_tabs('DataPart') }}

### 6.6 `FileBase` Object

Base entity for File Contents.

```ts { .no-copy }
--8<-- "types/src/types.ts:FileBase"
```

#### 6.6.1 `FileWithBytes` Object

Represents the data for a file, used within a `FilePart`.

```ts { .no-copy }
--8<-- "types/src/types.ts:FileWithBytes"
```

#### 6.6.2 `FileWithUri` Object

Represents the URI for a file, used within a `FilePart`.

```ts { .no-copy }
--8<-- "types/src/types.ts:FileWithUri"
```

### 6.7. `Artifact` Object

Represents a tangible output generated by the agent during a task. Artifacts are the results or products of the agent's work.

{{ render_spec_tabs('Artifact') }}

### 6.8. `PushNotificationConfig` Object

Configuration provided by the client to the server for sending asynchronous push notifications about task updates.

{{ render_spec_tabs('PushNotificationConfig') }}

### 6.9. `PushNotificationAuthenticationInfo` Object

A generic structure for specifying authentication requirements, typically used within `PushNotificationConfig` to describe how the A2A Server should authenticate to the client's webhook.

{{ render_spec_tabs('PushNotificationAuthenticationInfo') }}

### 6.10. `TaskPushNotificationConfig` Object

Used as the `params` object for the [`tasks/pushNotificationConfig/set`](#76-taskspushnotificationconfigset) method and as the `result` object for the [`tasks/pushNotificationConfig/get`](#77-taskspushnotificationconfigget) method.

{{ render_spec_tabs('TaskPushNotificationConfig') }}

### 6.11. JSON-RPC Structures

A2A adheres to the standard [JSON-RPC 2.0](https://www.jsonrpc.org/specification) structures for requests and responses.

#### 6.11.1. `JSONRPCRequest` Object

All A2A method calls are encapsulated in a JSON-RPC Request object.

- `jsonrpc`: A String specifying the version of the JSON-RPC protocol. **MUST** be exactly `"2.0"`.
- `method`: A String containing the name of the method to be invoked (e.g., `"message/send"`, `"tasks/get"`).
- `params`: A Structured value that holds the parameter values to be used during the invocation of the method. This member **MAY** be omitted if the method expects no parameters. A2A methods typically use an `object` for `params`.
- `id`: An identifier established by the Client that **MUST** contain a String, Number, or `NULL` value if included. If it is not included it is assumed to be a notification. The value **SHOULD NOT** be `NULL` for requests expecting a response, and Numbers **SHOULD NOT** contain fractional parts. The Server **MUST** reply with the same value in the Response object if included. This member is used to correlate the context between the two objects. A2A methods typically expect a response or stream, so `id` will usually be present and non-null.

#### 6.11.2. `JSONRPCResponse` Object

Responses from the A2A Server are encapsulated in a JSON-RPC Response object.

- `jsonrpc`: A String specifying the version of the JSON-RPC protocol. **MUST** be exactly `"2.0"`.
- `id`: This member is **REQUIRED**. It **MUST** be the same as the value of the `id` member in the Request Object. If there was an error in detecting the `id` in the Request object (e.g. Parse error/Invalid Request), it **MUST** be `null`.
- **EITHER** `result`: This member is **REQUIRED** on success. This member **MUST NOT** exist if there was an error invoking the method. The value of this member is determined by the method invoked on the Server.
- **OR** `error`: This member is **REQUIRED** on failure. This member **MUST NOT** exist if there was no error triggered during invocation. The value of this member **MUST** be an [`JSONRPCError`](#612-jsonrpcerror-object) object.
- The members `result` and `error` are mutually exclusive: one **MUST** be present, and the other **MUST NOT**.

### 6.12. `JSONRPCError` Object

When a JSON-RPC call encounters an error, the Response Object will contain an `error` member with a value of this structure.

```ts { .no-copy }
--8<-- "types/src/types.ts:JSONRPCError"
```

## 7. Protocol RPC Methods

All A2A RPC methods are invoked by the A2A Client by sending an HTTP POST request to the A2A Server's `url` (as specified in its `AgentCard`). The body of the HTTP POST request **MUST** be a `JSONRPCRequest` object, and the `Content-Type` header **MUST** be `application/json`.

The A2A Server's HTTP response body **MUST** be a `JSONRPCResponse` object (or, for streaming methods, an SSE stream where each event's data is a `JSONRPCResponse`). The `Content-Type` for JSON-RPC responses is `application/json`. For SSE streams, it is `text/event-stream`.

### 7.1. `message/send`

Sends a message to an agent to initiate a new interaction or to continue an existing one. This method is suitable for synchronous request/response interactions or when client-side polling (using `tasks/get`) is acceptable for monitoring longer-running tasks. A task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Sending a message to such a task will result in an error. For more information, refer to the [Life of a Task guide](./topics/life-of-a-task.md).

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `message/send`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`MessageSendParams`](#711-messagesendparams-object)
    -   **Response**: [`Task` | `Message`](#61-task-object) (A message object or the current or final state of the task after processing the message).

=== "gRPC"
    -   **URL:** `SendMessage`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message SendMessageRequest {
          Message msg = 1;
          SendMessageConfiguration configuration = 2;
        }
        ```
    -   **Response:**
        ```proto
        message SendMessageResponse {
          oneof payload {
            Task task = 1;
            Message msg = 2;
          }
        }
        ```

=== "REST"
    -   **URL:** `/v1/message:send`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```typescript
        {
          message: Message,
          configuration?: MessageSendConfiguration,
          metadata?: { [key: string]: any }
        }
        ```
    -   **Response:**
        ```typescript
        // Returns one of a message or a task
        {
          message?: Message,
          task?: Task
        }
        ```

</div>

The `error` response for all transports in case of failure is a [`JSONRPCError`](#612-jsonrpcerror-object) or equivalent.

#### 7.1.1. `MessageSendParams` Object

{{ render_spec_tabs('MessageSendParams') }}

#### 7.1.2 `MessageSendConfiguration` Object

{{ render_spec_tabs('MessageSendConfiguration') }}

### 7.2. `message/stream`

Sends a message to an agent to initiate/continue a task AND subscribes the client to real-time updates for that task via Server-Sent Events (SSE). This method requires the server to have `AgentCard.capabilities.streaming: true`. Just like `message/send`, a task which has reached a terminal state (completed, canceled, rejected, or failed) can't be restarted. Sending a message to such a task will result in an error. For more information, refer to the [Life of a Task guide](./topics/life-of-a-task.md).

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `message/stream`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`MessageSendParams`](#711-messagesendparams-object) (same as `message/send`)
    -   **Response**: A stream of Server-Sent Events. Each SSE `data` field contains a [`SendStreamingMessageResponse`](#721-sendstreamingmessageresponse-object)

=== "gRPC"
    -   **URL:** `SendStreamingMessage`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message SendMessageRequest {
          Message msg = 1;
          SendMessageConfiguration configuration = 2;
        }
        ```
    -   **Response:**
        ```proto
        message StreamResponse {
          oneof payload {
            Task task;
            Message msg;
            TaskStatusUpdateEvent status_update;
            TaskArtifactUpdateEvent artifact_update;
          }
        }
        ```

=== "REST"
    -   **URL:** `/v1/message:stream`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```typescript
        {
          message: Message,
          configuration?: MessageSendConfiguration,
          metadata?: { [key: string]: any }
        }
        ```
    -   **Response:**
        ```typescript
        {
          message?: Message
          task?: Task
          statusUpdate?: TaskStatusUpdateEvent
          artifactUpdate?: TaskArtifactUpdateEvent
        }
        ```

</div>

#### 7.2.1. `SendStreamingMessageResponse` Object

This is the structure of the JSON object found in the `data` field of each Server-Sent Event sent by the server for a `message/stream` request or `tasks/resubscribe` request.

```ts { .no-copy }
--8<-- "types/src/types.ts:SendStreamingMessageResponse"
```

{{ render_spec_tabs('SendStreamingMessageSuccessResponse') }}

#### 7.2.2. `TaskStatusUpdateEvent` Object

Carries information about a change in the task's status during streaming. This is one of the possible `result` types in a `SendStreamingMessageSuccessResponse`.

{{ render_spec_tabs('TaskStatusUpdateEvent') }}

#### 7.2.3. `TaskArtifactUpdateEvent` Object

Carries a new or updated artifact (or a chunk of an artifact) generated by the task during streaming. This is one of the possible `result` types in a `SendTaskStreamingResponse`.

{{ render_spec_tabs('TaskArtifactUpdateEvent') }}

### 7.3. `tasks/get`

Retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task. This is typically used for polling the status of a task initiated with `message/send`, or for fetching the final state of a task after being notified via a push notification or after an SSE stream has ended.

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `tasks/get`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`TaskQueryParams`](#731-taskqueryparams-object)
    -   **Response**: `Task`

=== "gRPC"
    -   **URL:** `GetTask`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message GetTaskRequest {
          // name=tasks/{id}
          string name;
          int32 history_length;
        }
        ```
    -   **Response**: `Task`

=== "REST"
    -   **URL:** `v1/tasks/{id}?historyLength={historyLength}`
    -   **HTTP Method:** `GET`
    -   **Payload:** None
    -   **Response**: `Task`

</div>

#### 7.3.1. `TaskQueryParams` Object

{{ render_spec_tabs('TaskQueryParams') }}

### 7.4. `tasks/list`

Retrieves a list of tasks with optional filtering and pagination capabilities. This method allows clients to discover and manage multiple tasks across different contexts or with specific status criteria.

**Pagination Strategy:** This method uses cursor-based pagination (via `pageToken`/`nextPageToken`) rather than offset-based pagination for better performance and consistency, especially with large datasets. Cursor-based pagination avoids the "deep pagination problem" where skipping large numbers of records becomes inefficient for databases. This approach is consistent with the gRPC specification, which also uses cursor-based pagination (`page_token`/`next_page_token`).

**Ordering:** Implementations **MUST** return tasks sorted by their last update time in descending order (most recently updated tasks first). This ensures consistent pagination and allows clients to efficiently monitor recent task activity.

**Security Note:** Implementations **MUST** ensure appropriate scope limitation based on the authenticated user's permissions. Servers **SHOULD NOT** return tasks from other users or unauthorized contexts. Even when `contextId` is not specified in the request, the implementation **MUST** still scope results to the caller's authorization and tenancy boundaries. The implementation **MAY** choose to limit results to tasks created by the current authenticated user, tasks within a default user context, or return an authorization error if the scope cannot be safely determined.

- **Request `params` type**: [`ListTasksParams`](#741-listtasksparams-object) (Optional parameters for filtering and pagination)
- **Response `result` type (on success)**: [`ListTasksResult`](#742-listtasksresult-object) (A paginated list of tasks matching the criteria)
- **Response `error` type (on failure)**: [`JSONRPCError`](#612-jsonrpcerror-object) (see specific error cases below)

**Error Cases for `tasks/list`:**

The following table details specific error conditions that should result in an `InvalidParamsError` (-32602) response:

| Parameter | Invalid Condition | Error Details | Example |
|-----------|------------------|---------------|---------|
| `pageSize` | Value outside 1‚Äì100 range | Must be between 1 and 100 inclusive | `pageSize: 0` or `pageSize: 101` |
| `pageToken` | Malformed token format | Token is not a valid base64-encoded cursor | `pageToken: "invalid!@#"` |
| `pageToken` | Expired token | Token has exceeded its validity period | `pageToken: "<expired-token>"` |
| `historyLength` | Negative value | Must be non-negative integer | `historyLength: -1` |
| `status` | Invalid enum value | Must be one of: `pending`, `working`, `completed`, `failed`, `canceled` | `status: "running"` |
| `lastUpdatedAfter` | Invalid timestamp format | Must be a valid Unix timestamp in milliseconds | `lastUpdatedAfter: "not-a-number"` |
| `lastUpdatedAfter` | Future timestamp | Timestamp is in the future (optional validation) | `lastUpdatedAfter: 4102444800000` (year 2100) |

**Additional Error Responses:**

- **`-32001` (`TaskNotFoundError`)**: When `contextId` refers to a nonexistent or inaccessible context
- **`-32600` (`InvalidRequest`)**: When the request structure is malformed
- **`-32603` (`InternalError`)**: When a server-side error occurs during task retrieval

#### 7.4.1. `ListTasksParams` Object

Parameters for filtering and paginating task results.

```ts { .no-copy }
--8<-- "types/src/types.ts:ListTasksParams"
```

**Note on `includeArtifacts` parameter:** When `includeArtifacts` is `false` (the default), the `artifacts` field **MUST** be omitted entirely from each `Task` object in the response. The field should not be present as an empty array or null value. When `includeArtifacts` is `true`, the `artifacts` field should be included with its actual content (which may be an empty array if the task has no artifacts).

#### 7.4.2. `ListTasksResult` Object

Result object containing the filtered tasks and pagination information.

```ts { .no-copy }
--8<-- "types/src/types.ts:ListTasksResult"
```

**Note on `nextPageToken`:** The `nextPageToken` field **MUST** always be present in the response. When there are no more results to retrieve (i.e., this is the final page), the field **MUST** be set to an empty string (`""`). Clients should check for an empty string to determine if more pages are available.

### 7.5. `tasks/cancel`

Requests the cancellation of an ongoing task. The server will attempt to cancel the task, but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `tasks/cancel`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`TaskIdParams`](#751-taskidparams-object-for-taskscancel-and-taskspushnotificationconfigget)
    -   **Response**: [`Task`](#61-task-object)

=== "gRPC"
    -   **URL:** `CancelTask`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message CancelTaskRequest{
          // name=tasks/{id}
          string name;
        }
        ```
    -   **Response**: [`Task`](#61-task-object)

=== "REST"
    -   **URL:** `/v1/tasks/{id}:cancel`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```typescript
        {
          name: string
        }
        ```
    -   **Response**: [`Task`](#61-task-object)

</div>

- **Response `error` type (on failure)**: [`JSONRPCError`](#612-jsonrpcerror-object) (e.g., [`TaskNotFoundError`](#82-a2a-specific-errors), [`TaskNotCancelableError`](#82-a2a-specific-errors)).

#### 7.5.1. `TaskIdParams` Object (for `tasks/cancel` and `tasks/pushNotificationConfig/get`)

A simple object containing just the task ID and optional metadata.

{{ render_spec_tabs('TaskIdParams') }}

### 7.6. `tasks/pushNotificationConfig/set`

Sets or updates the push notification configuration for a specified task. This allows the client to tell the server where and how to send asynchronous updates for the task. Requires the server to have `AgentCard.capabilities.pushNotifications: true`.

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `tasks/pushNotificationConfig/set`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`TaskPushNotificationConfig`](#610-taskpushnotificationconfig-object)
    -   **Response**: [`TaskPushNotificationConfig`](#610-taskpushnotificationconfig-object)

=== "gRPC"
    -   **URL:** `CreateTaskPushNotification`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message SetTaskPushNotificationRequest {
          TaskPushNotificationConfig config = 1;
        }
        ```
    -   **Response**: `TaskPushNotificationConfig`

=== "REST"
    -   **URL:** `/v1/tasks/{id}/pushNotificationConfigs`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```typescript
        {
          config: TaskPushNotificationConfig
        }
        ```
    -   **Response**: `TaskPushNotificationConfig`

</div>

### 7.7. `tasks/pushNotificationConfig/get`

Retrieves the current push notification configuration for a specified task. Requires the server to have `AgentCard.capabilities.pushNotifications: true`.

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `tasks/pushNotificationConfig/get`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`GetTaskPushNotificationConfigParams`](#771-gettaskpushnotificationconfigparams-object-taskspushnotificationconfigget)
    -   **Response**: [`TaskPushNotificationConfig`](#610-taskpushnotificationconfig-object)

=== "gRPC"
    -   **URL:** `GetTaskPushNotification`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message TaskSubscriptionRequest {
          // name=tasks/{id}/pushNotification/{id}
          string name;
        }
        ```
    -   **Response**: `TaskPushNotificationConfig`

=== "REST"
    -   **URL:** `/v1/tasks/{taskId}/pushNotificationConfigs/{configId}`
    -   **HTTP Method:** `GET`
    -   **Payload:** None
    -   **Response**: `TaskPushNotificationConfig`

</div>

**Response `error` type (on failure)**: [`JSONRPCError`](#612-jsonrpcerror-object) (e.g., [`PushNotificationNotSupportedError`](#82-a2a-specific-errors), [`TaskNotFoundError`](#82-a2a-specific-errors)).

#### 7.7.1. `GetTaskPushNotificationConfigParams` Object (`tasks/pushNotificationConfig/get`)

A object for fetching the push notification configuration for a task.

{{ render_spec_tabs('GetTaskPushNotificationConfigParams') }}

### 7.8. `tasks/pushNotificationConfig/list`

Retrieves the associated push notification configurations for a specified task. Requires the server to have `AgentCard.capabilities.pushNotifications: true`.

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `tasks/pushNotificationConfig/list`
    -   **HTTP Method:** `POST`
    -   **Payload:** [`ListTaskPushNotificationConfigParams`](#781-listtaskpushnotificationconfigparams-object-taskspushnotificationconfiglist)
    -   **Response**: `TaskPushNotificationConfig[]`

=== "gRPC"
    -   **URL:** `ListTaskPushNotification`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message ListTaskPushNotificationRequest {
          // parent=tasks/{id}
          string parent = 1;
        }
        ```
    -   **Response**: `repeated TaskPushNotificationConfig`

=== "REST"
    -   **URL:** `/v1/tasks/{id}/pushNotificationConfigs`
    -   **HTTP Method:** `GET`
    -   **Payload:**: None
    -   **Response**: `[TaskPushNotificationConfig]`

</div>

- **Response `error` type (on failure)**: [`JSONRPCError`](#612-jsonrpcerror-object) (e.g., [`PushNotificationNotSupportedError`](#82-a2a-specific-errors), [`TaskNotFoundError`](#82-a2a-specific-errors)).

#### 7.8.1. `ListTaskPushNotificationConfigParams` Object (`tasks/pushNotificationConfig/list`)

A object for fetching the push notification configurations for a task.

{{ render_spec_tabs('ListTaskPushNotificationConfigParams') }}

### 7.9. `tasks/pushNotificationConfig/delete`

Deletes an associated push notification configuration for a task. Requires the server to have `AgentCard.capabilities.pushNotifications: true`.

- **Request `params` type**: [`DeleteTaskPushNotificationConfigParams`](#791-deletetaskpushnotificationconfigparams-object-taskspushnotificationconfigdelete)
- **Response `result` type (on success)**: [`null`]
- **Response `error` type (on failure)**: [`JSONRPCError`](#612-jsonrpcerror-object) (e.g., [`PushNotificationNotSupportedError`](#82-a2a-specific-errors), [`TaskNotFoundError`](#82-a2a-specific-errors)).

#### 7.9.1. `DeleteTaskPushNotificationConfigParams` Object (`tasks/pushNotificationConfig/delete`)

A object for deleting an associated push notification configuration for a task.

{{ render_spec_tabs('DeleteTaskPushNotificationConfigParams') }}

### 7.10. `tasks/resubscribe`

Allows a client to reconnect to an SSE stream for an ongoing task after a previous connection (from `message/stream` or an earlier `tasks/resubscribe`) was interrupted. Requires the server to have `AgentCard.capabilities.streaming: true`.

The purpose is to resume receiving _subsequent_ updates. The server's behavior regarding events missed during the disconnection period (e.g., whether it attempts to backfill some missed events or only sends new ones from the point of resubscription) is implementation-dependent and not strictly defined by this specification.

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `tasks/resubscribe`
    -   **HTTP Method:** `POST`
    -   **Payload**: [`TaskIdParams`](#751-taskidparams-object-for-taskscancel-and-taskspushnotificationconfigget)
    -   **Response**: A stream of Server-Sent Events. Each SSE `data` field contains a [`SendStreamingMessageResponse`](#721-sendstreamingmessageresponse-object)

=== "gRPC"
    -   **URL:** `TaskSubscription`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```proto
        message TaskSubscriptionRequest{
          // name=tasks/{id}
          string name;
        }
        ```
    -   **Response:**
        ```proto
        message StreamResponse {
          oneof payload {
            Task task;
            Message msg;
            TaskStatusUpdateEvent status_update;
            TaskArtifactUpdateEvent artifact_update;
          }
        }
        ```

=== "REST"
    -   **URL:** `/v1/tasks/{id}:subscribe`
    -   **HTTP Method:** `POST`
    -   **Payload:**
        ```typescript
        {
          name: string
        }
        ```
    -   **Response:**
        ```typescript
        {
          message?: Message
          task?: Task
          statusUpdate?: TaskStatusUpdateEvent
          artifactUpdate?: TaskArtifactUpdateEvent
        }
        ```

</div>

### 7.10. `agent/getAuthenticatedExtendedCard`

Retrieves a potentially more detailed version of the Agent Card after the client has authenticated. This endpoint is available only if `AgentCard.supportsAuthenticatedExtendedCard` is `true`.

- **Authentication**: The client **MUST** authenticate the request using one of the schemes declared in the public `AgentCard.securitySchemes` and `AgentCard.security` fields.
- **Response `result` type (on success)**: `AgentCard` (A complete Agent Card object, which may contain additional details or skills not present in the public card).
- **Response `error` type (on failure)**: Standard HTTP error codes.
    - `401 Unauthorized`: Authentication failed (missing or invalid credentials). The server **SHOULD** include a `WWW-Authenticate` header.

<div class="grid cards" markdown>

=== "JSON-RPC"
    -   **URL:** `agent/getAuthenticatedExtendedCard`
    -   **HTTP Method:** `POST`
    -   **Payload:** None
    -   **Response:** `AgentCard`

=== "gRPC"
    -   **URL:** `GetAgentCard`
    -   **HTTP Method:** `POST`
    -   **Payload:** None
    -   **Response:** `AgentCard`

=== "REST"
    -   **URL:** `/v1/card`
    -   **HTTP Method:** `GET`
    -   **Payload:** None
    -   **Response:** `AgentCard`

</div>

Clients retrieving this authenticated card **SHOULD** replace their cached public Agent Card with the content received from this endpoint for the duration of their authenticated session or until the card's version changes.

```ts { .no-copy }
--8<-- "types/src/types.ts:GetAuthenticatedExtendedCardSuccessResponse"
```

## 8. Error Handling

A2A uses standard [JSON-RPC 2.0 error codes and structure](https://www.jsonrpc.org/specification#error_object) for reporting errors. Errors are returned in the `error` member of the `JSONRPCErrorResponse` object. See [`JSONRPCError` Object definition](#612-jsonrpcerror-object).

### 8.1. Standard JSON-RPC Errors

These are standard codes defined by the JSON-RPC 2.0 specification.

| Code                 | JSON-RPC Spec Meaning | Typical A2A `message`     | Description                                                                                  |
| :------------------- | :-------------------- | :------------------------ | :------------------------------------------------------------------------------------------- |
| `-32700`             | Parse error           | Invalid JSON payload      | Server received JSON that was not well-formed.                                               |
| `-32600`             | Invalid Request       | Invalid JSON-RPC Request  | The JSON payload was valid JSON, but not a valid JSON-RPC Request object.                    |
| `-32601`             | Method not found      | Method not found          | The requested A2A RPC `method` (e.g., `"tasks/foo"`) does not exist or is not supported.     |
| `-32602`             | Invalid params        | Invalid method parameters | The `params` provided for the method are invalid (e.g., wrong type, missing required field). |
| `-32603`             | Internal error        | Internal server error     | An unexpected error occurred on the server during processing.                                |
| `-32000` to `-32099` | Server error          | _(Server-defined)_        | Reserved for implementation-defined server-errors. A2A-specific errors use this range.       |

### 8.2. A2A-Specific Errors

These are custom error codes defined within the JSON-RPC server error range (`-32000` to `-32099`) to provide more specific feedback about A2A-related issues. Servers **SHOULD** use these codes where applicable.

| Code     | Error Name (Conceptual)             | Typical `message` string           | Description                                                                                                                                                                                                                          |
| :------- | :---------------------------------- | :--------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-32001` | `TaskNotFoundError`                 | Task not found                     | The specified task `id` does not correspond to an existing or active task. It might be invalid, expired, or already completed and purged.                                                                                            |
| `-32002` | `TaskNotCancelableError`            | Task cannot be canceled            | An attempt was made to cancel a task that is not in a cancelable state (e.g., it has already reached a terminal state like `completed`, `failed`, or `canceled`).                                                                    |
| `-32003` | `PushNotificationNotSupportedError` | Push Notification is not supported | Client attempted to use push notification features (e.g., `tasks/pushNotificationConfig/set`) but the server agent does not support them (i.e., `AgentCard.capabilities.pushNotifications` is `false`).                              |
| `-32004` | `UnsupportedOperationError`         | This operation is not supported    | The requested operation or a specific aspect of it (perhaps implied by parameters) is not supported by this server agent implementation. Broader than just method not found.                                                         |
| `-32005` | `ContentTypeNotSupportedError`      | Incompatible content types         | A [Media Type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) provided in the request's `message.parts` (or implied for an artifact) is not supported by the agent or the specific skill being invoked. |
| `-32006` | `InvalidAgentResponseError`         | Invalid agent response type        | Agent generated an invalid response for the requested method                                                                                                                                                                         |
| `-32007` | `AuthenticatedExtendedCardNotConfiguredError`         | Authenticated Extended Card not configured        | The agent does not have an Authenticated Extended Card configured.|

Servers MAY define additional error codes within the `-32000` to `-32099` range for more specific scenarios not covered above, but they **SHOULD** document these clearly. The `data` field of the `JSONRPCError` object can be used to provide more structured details for any error.

## 9. Common Workflows & Examples

This section provides illustrative JSON examples of common A2A interactions. Timestamps, context IDs, and request/response IDs are for demonstration purposes. For brevity, some optional fields might be omitted if not central to the example.

### 9.1. Fetching Authenticated Extended Agent Card

**Scenario:** A client discovers a public Agent Card indicating support for an authenticated extended card and wants to retrieve the full details.

1. **Client fetches the public Agent Card:**

   ```none
   GET https://example.com/.well-known/agent-card.json
   ```

   _Server responds with the public Agent Card (like the example in Section 5.6), including `supportsAuthenticatedExtendedCard: true` (at the root level) and `securitySchemes`._

2. **Client identifies required authentication from the public card.**

3. **Client obtains necessary credentials out-of-band (e.g., performs OAuth 2.0 flow with Google, resulting in an access token).**

4. **Client fetches the authenticated extended Agent Card using `agent/getAuthenticatedExtendedCard` request:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 1,
     "method": "agent/getAuthenticatedExtendedCard"
   }
   ```

5. **Server authenticates and authorizes the request.**

6. **Server responds with the full Agent Card as the JSON-RPC result:**

### 9.2. Basic Execution (Synchronous / Polling Style)

**Scenario:** Client asks a simple question, and the agent responds quickly with a task

1. **Client sends a message using `message/send`:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 1,
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "tell me a joke"
           }
         ],
         "messageId": "9229e770-767c-417b-a0b0-f0741243c589"
       },
       "metadata": {}
     }
   }
   ```

2. **Server processes the request, creates a task and responds (task completes quickly)**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "id": "363422be-b0f9-4692-a24d-278670e7c7f1",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "status": {
         "state": "completed"
       },
       "artifacts": [
         {
           "artifactId": "9b6934dd-37e3-4eb1-8766-962efaab63a1",
           "name": "joke",
           "parts": [
             {
               "kind": "text",
               "text": "Why did the chicken cross the road? To get to the other side!"
             }
           ]
         }
       ],
       "history": [
         {
           "role": "user",
           "parts": [
             {
               "kind": "text",
               "text": "tell me a joke"
             }
           ],
           "messageId": "9229e770-767c-417b-a0b0-f0741243c589",
           "taskId": "363422be-b0f9-4692-a24d-278670e7c7f1",
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4"
         }
       ],
       "kind": "task",
       "metadata": {}
     }
   }
   ```

_If the task were longer-running, the server might initially respond with `status.state: "working"`. The client would then periodically call `tasks/get` with params: `{"id": "363422be-b0f9-4692-a24d-278670e7c7f1"}` until the task reaches a terminal state._

**Scenario:** Client asks a simple question, and the agent responds quickly without a task

1. **Client sends a message using `message/send`:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 1,
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "tell me a joke"
           }
         ],
         "messageId": "9229e770-767c-417b-a0b0-f0741243c589"
       },
       "metadata": {}
     }
   }
   ```

2. **Server processes the request, responds quickly without a task**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "messageId": "363422be-b0f9-4692-a24d-278670e7c7f1",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "parts": [
         {
           "kind": "text",
           "text": "Why did the chicken cross the road? To get to the other side!"
         }
       ],
       "kind": "message",
       "metadata": {}
     }
   }
   ```

### 9.3. Streaming Task Execution (SSE)

**Scenario:** Client asks the agent to write a long paper describing an attached picture.

1. **Client sends a message and subscribes using `message/stream`:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 1,
     "method": "message/stream",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "write a long paper describing the attached pictures"
           },
           {
             "kind": "file",
             "file": {
               "mimeType": "image/png",
               "data": "<base64-encoded-content>"
             }
           }
         ],
         "messageId": "bbb7dee1-cf5c-4683-8a6f-4114529da5eb"
       },
       "metadata": {}
     }
   }
   ```

2. **Server responds with HTTP 200 OK, `Content-Type: text/event-stream`, and starts sending SSE events:**

   _Event 1: Task status update - working_

   ```json
   data: {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "id": "225d6247-06ba-4cda-a08b-33ae35c8dcfa",
       "contextId": "05217e44-7e9f-473e-ab4f-2c2dde50a2b1",
       "status": {
         "state": "submitted",
         "timestamp":"2025-04-02T16:59:25.331844"
       },
       "history": [
         {
           "role": "user",
           "parts": [
             {
               "kind": "text",
               "text": "write a long paper describing the attached pictures"
             },
             {
               "kind": "file",
               "file": {
                 "mimeType": "image/png",
                 "data": "<base64-encoded-content>"
               }
             }
           ],
           "messageId": "bbb7dee1-cf5c-4683-8a6f-4114529da5eb",
           "taskId": "225d6247-06ba-4cda-a08b-33ae35c8dcfa",
           "contextId": "05217e44-7e9f-473e-ab4f-2c2dde50a2b1"
         }
       ],
       "kind": "task",
       "metadata": {}
     }
   }

   data: {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "taskId": "225d6247-06ba-4cda-a08b-33ae35c8dcfa",
       "contextId": "05217e44-7e9f-473e-ab4f-2c2dde50a2b1",
       "artifact": {
         "artifactId": "9b6934dd-37e3-4eb1-8766-962efaab63a1",
         "parts": [
           {"kind":"text", "text": "<section 1...>"}
         ]
       },
       "append": false,
       "lastChunk": false,
       "kind":"artifact-update"
     }
   }

   data: {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "taskId": "225d6247-06ba-4cda-a08b-33ae35c8dcfa",
       "contextId": "05217e44-7e9f-473e-ab4f-2c2dde50a2b1",
       "artifact": {
         "artifactId": "9b6934dd-37e3-4eb1-8766-962efaab63a1",
         "parts": [
           {"kind":"text", "text": "<section 2...>"}
         ],
       },
       "append": true,
       "lastChunk": false,
       "kind":"artifact-update"
     }
   }


   data: {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "taskId": "225d6247-06ba-4cda-a08b-33ae35c8dcfa",
       "contextId": "05217e44-7e9f-473e-ab4f-2c2dde50a2b1",
       "artifact": {
         "artifactId": "9b6934dd-37e3-4eb1-8766-962efaab63a1",
         "parts": [
           {"kind":"text", "text": "<section 3...>"}
         ]
       },
       "append": true,
       "lastChunk": true,
       "kind":"artifact-update"
     }
   }

   data: {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "taskId": "225d6247-06ba-4cda-a08b-33ae35c8dcfa",
       "contextId": "05217e44-7e9f-473e-ab4f-2c2dde50a2b1",
       "status": {
         "state": "completed",
         "timestamp":"2025-04-02T16:59:35.331844"
       },
       "final": true,
       "kind":"status-update"
     }
   }
   ```

   _(Server closes the SSE connection after the `final:true` event)._

### 9.4. Multi-Turn Interaction (Input Required)

**Scenario:** Client wants to book a flight, and the agent needs more information.

1. **Client sends a message using `message/send`:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-003",
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [{ "kind": "text", "text": "I'd like to book a flight." }]
       },
       "messageId": "c53ba666-3f97-433c-a87b-6084276babe2"
     }
   }
   ```

2. **Server responds, task state is `input-required`:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-003",
     "result": {
       "id": "3f36680c-7f37-4a5f-945e-d78981fafd36",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "status": {
         "state": "input-required",
         "message": {
           "role": "agent",
           "parts": [
             {
               "kind": "text",
               "text": "Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?"
             }
           ],
           "messageId": "c2e1b2dd-f200-4b04-bc22-1b0c65a1aad2",
           "taskId": "3f36680c-7f37-4a5f-945e-d78981fafd36",
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4"
         },
         "timestamp": "2024-03-15T10:10:00Z"
       },
       "history": [
         {
           "role": "user",
           "parts": [
             {
               "kind": "text",
               "text": "I'd like to book a flight."
             }
           ],
           "messageId": "c53ba666-3f97-433c-a87b-6084276babe2",
           "taskId": "3f36680c-7f37-4a5f-945e-d78981fafd36",
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4"
         }
       ],
       "kind": "task"
     }
   }
   ```

3. **Client `message/send` (providing the requested input, using the _same_ task ID):**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-004",
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th."
           }
         ],
         "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
         "taskId": "3f36680c-7f37-4a5f-945e-d78981fafd36",
         "messageId": "0db1d6c4-3976-40ed-b9b8-0043ea7a03d3"
       },
       "configuration": {
         "blocking": true
       }
     }
   }
   ```

4. **Server processes the new input and responds (e.g., task completed or more input needed):**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-004",
     "result": {
       "id": "3f36680c-7f37-4a5f-945e-d78981fafd36",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "status": {
         "state": "completed",
         "message": {
           "role": "agent",
           "parts": [
             {
               "kind": "text",
               "text": "Okay, I've found a flight for you. Confirmation XYZ123. Details are in the artifact."
             }
           ]
         }
       },
       "artifacts": [
         {
           "artifactId": "9b6934dd-37e3-4eb1-8766-962efaab63a1",
           "name": "FlightItinerary.json",
           "parts": [
             {
               "kind": "data",
               "data": {
                 "confirmationId": "XYZ123",
                 "from": "JFK",
                 "to": "LHR",
                 "departure": "2024-10-10T18:00:00Z",
                 "arrival": "2024-10-11T06:00:00Z",
                 "returnDeparture": "..."
               }
             }
           ]
         }
       ],
       "history": [
         {
           "role": "user",
           "parts": [
             {
               "kind": "text",
               "text": "I'd like to book a flight."
             }
           ],
           "messageId": "c53ba666-3f97-433c-a87b-6084276babe2",
           "taskId": "3f36680c-7f37-4a5f-945e-d78981fafd36",
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4"
         },
         {
           "role": "agent",
           "parts": [
             {
               "kind": "text",
               "text": "Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?"
             }
           ],
           "messageId": "c2e1b2dd-f200-4b04-bc22-1b0c65a1aad2",
           "taskId": "3f36680c-7f37-4a5f-945e-d78981fafd36",
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4"
         },
         {
           "role": "user",
           "parts": [
             {
               "kind": "text",
               "text": "I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th."
             }
           ],
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
           "taskId": "3f36680c-7f37-4a5f-945e-d78981fafd36",
           "messageId": "0db1d6c4-3976-40ed-b9b8-0043ea7a03d3"
         }
       ],
       "kind": "task",
       "metadata": {}
     }
   }
   ```

### 9.5. Task Listing and Management

**Scenario:** Client wants to see all tasks from a specific context or all tasks with a particular status.

1. **Client requests all tasks from a specific context:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-001",
     "method": "tasks/list",
     "params": {
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "pageSize": 10,
       "historyLength": 3
     }
   }
   ```

2. **Server responds with matching tasks:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-001",
     "result": {
       "tasks": [
         {
           "id": "3f36680c-7f37-4a5f-945e-d78981fafd36",
           "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
           "status": {
             "state": "completed",
             "timestamp": "2024-03-15T10:15:00Z"
           },
       "totalSize": 5,
       "pageSize": 10,
       "nextPageToken": ""
     }
   }
   ```

3. **Client requests all working tasks across all contexts:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-002",
     "method": "tasks/list",
     "params": {
       "status": "working",
       "pageSize": 20
     }
   }
   ```

4. **Server responds with all currently working tasks:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-002",
     "result": {
       "tasks": [
         {
           "id": "789abc-def0-1234-5678-9abcdef01234",
           "contextId": "another-context-id",
           "status": {
             "state": "working",
             "message": {
               "role": "agent",
               "parts": [
                 {
                   "kind": "text",
                   "text": "Processing your document analysis..."
                 }
               ],
               "messageId": "msg-status-update"
             },
             "timestamp": "2024-03-15T10:20:00Z"
           },
           "kind": "task"
         }
       ],
       "totalSize": 1,
       "pageSize": 20,
       "nextPageToken": ""
     }
   }
   ```

5. **Continuing pagination - Client requests the next page using nextPageToken:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-003",
     "method": "tasks/list",
     "params": {
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "pageSize": 10,
       "pageToken": "<base64-encoded-cursor-token>"
     }
   }
   ```

6. **Server responds with the next page of results:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-003",
     "result": {
       "tasks": [
         // ... additional tasks
       ],
       "totalSize": 15,
       "pageSize": 10,
       "nextPageToken": "<base64-encoded-cursor-token>"
     }
   }
   ```

7. **Error example - Client sends invalid parameters:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-error-001",
     "method": "tasks/list",
     "params": {
       "pageSize": 150,
       "historyLength": -5,
       "status": "running"
     }
   }
   ```

8. **Server responds with validation error:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "list-error-001",
     "error": {
       "code": -32602,
       "message": "Invalid params",
       "data": {
         "errors": [
           {
             "field": "pageSize",
             "message": "Must be between 1 and 100 inclusive, got 150"
           },
           {
             "field": "historyLength",
             "message": "Must be non-negative integer, got -5"
           },
           {
             "field": "status",
             "message": "Invalid status value 'running'. Must be one of: pending, working, completed, failed, canceled"
           }
         ]
       }
     }
   }
   ```

### 9.6. Push Notification Setup and Usage

**Scenario:** Client requests a long-running report generation and wants to be notified via webhook when it's done.

1. **Client `message/send` with `pushNotification` config:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-005",
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "Generate the Q1 sales report. This usually takes a while. Notify me when it's ready."
           }
         ],
         "messageId": "6dbc13b5-bd57-4c2b-b503-24e381b6c8d6"
       },
       "configuration": {
         "pushNotificationConfig": {
           "url": "https://client.example.com/webhook/a2a-notifications",
           "token": "secure-client-token-for-task-aaa",
           "authentication": {
             "schemes": ["Bearer"]
             // Assuming server knows how to get a Bearer token for this webhook audience,
             // or this implies the webhook is public/uses the 'token' for auth.
             // 'credentials' could provide more specifics if needed by the server.
           }
         }
       }
     }
   }
   ```

2. **Server acknowledges the task (e.g., status `submitted` or `working`):**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-005",
     "result": {
       "id": "43667960-d455-4453-b0cf-1bae4955270d",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "status": { "state": "submitted", "timestamp": "2024-03-15T11:00:00Z" }
       // ... other fields ...
     }
   }
   ```

3. **(Later) A2A Server completes the task and POSTs a notification to `https://client.example.com/webhook/a2a-notifications`:**

   - **HTTP Headers might include:**
     - `Authorization: Bearer <server_jwt_for_webhook_audience>` (if server authenticates to webhook)
     - `Content-Type: application/json`
     - `X-A2A-Notification-Token: secure-client-token-for-task-aaa`
   - **HTTP Body (Task object is sent as JSON payload):**

   ```json
   {
     "id": "43667960-d455-4453-b0cf-1bae4955270d",
     "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
     "status": { "state": "completed", "timestamp": "2024-03-15T18:30:00Z" },
     "kind": "task"
     // ... other fields ...
   }
   ```

4. **Client's Webhook Service:**

   - Receives the POST.
   - Validates the `Authorization` header (if applicable).
   - Validates the `X-A2A-Notification-Token`.
   - Internally processes the notification (e.g., updates application state, notifies end user).

### 9.7. File Exchange (Upload and Download)

**Scenario:** Client sends an image for analysis, and the agent returns a modified image.

1. **Client `message/send` with a `FilePart` (uploading image bytes):**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-007",
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "Analyze this image and highlight any faces."
           },
           {
             "kind": "file",
             "file": {
               "name": "input_image.png",
               "mimeType": "image/png",
               "bytes": "iVBORw0KGgoAAAANSUhEUgAAAAUA..." // Base64 encoded image data
             }
           }
         ],
         "messageId": "6dbc13b5-bd57-4c2b-b503-24e381b6c8d6"
       }
     }
   }
   ```

2. **Server processes the image and responds with a `FilePart` in an artifact (e.g., providing a URI to the modified image):**

   ```json
   {
     "jsonrpc": "2.0",
     "id": "req-007",
     "result": {
       "id": "43667960-d455-4453-b0cf-1bae4955270d",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "status": { "state": "completed", "timestamp": "2024-03-15T12:05:00Z" },
       "artifacts": [
         {
           "artifactId": "9b6934dd-37e3-4eb1-8766-962efaab63a1",
           "name": "processed_image_with_faces.png",
           "parts": [
             {
               "kind": "file",
               "file": {
                 "name": "output.png",
                 "mimeType": "image/png",
                 // Server might provide a URI to a temporary storage location
                 "uri": "https://storage.example.com/processed/task-bbb/output.png?token=xyz"
                 // Or, alternatively, it could return bytes directly:
                 // "bytes": "ASEDGhw0KGgoAAAANSUhEUgAA..."
               }
             }
           ]
         }
       ],
       "kind": "task"
     }
   }
   ```

### 9.8. Structured Data Exchange (Requesting and Providing JSON)

**Scenario:** Client asks for a list of open support tickets in a specific JSON format.

1. **Client `message/send`, `Part.metadata` hints at desired output schema/Media Type:**
   _(Note: A2A doesn't formally standardize schema negotiation in v0.2.0, but `metadata` can be used for such hints by convention between client/server)._

   ```json
   {
     "jsonrpc": "2.0",
     "id": 9,
     "method": "message/send",
     "params": {
       "message": {
         "role": "user",
         "parts": [
           {
             "kind": "text",
             "text": "Show me a list of my open IT tickets",
             "metadata": {
               "mimeType": "application/json",
               "schema": {
                 "type": "array",
                 "items": {
                   "type": "object",
                   "properties": {
                     "ticketNumber": { "type": "string" },
                     "description": { "type": "string" }
                   }
                 }
               }
             }
           }
         ],
         "messageId": "85b26db5-ffbb-4278-a5da-a7b09dea1b47"
       },
       "metadata": {}
     }
   }
   ```

2. **Server responds with structured JSON data:**

   ```json
   {
     "jsonrpc": "2.0",
     "id": 9,
     "result": {
       "id": "d8c6243f-5f7a-4f6f-821d-957ce51e856c",
       "contextId": "c295ea44-7543-4f78-b524-7a38915ad6e4",
       "status": {
         "state": "completed",
         "timestamp": "2025-04-17T17:47:09.680794"
       },
       "artifacts": [
         {
           "artifactId": "c5e0382f-b57f-4da7-87d8-b85171fad17c",
           "parts": [
             {
               "kind": "text",
               "text": "[{\"ticketNumber\":\"REQ12312\",\"description\":\"request for VPN access\"},{\"ticketNumber\":\"REQ23422\",\"description\":\"Add to DL - team-gcp-onboarding\"}]"
             }
           ]
         }
       ],
       "kind": "task"
     }
   }
   ```

These examples illustrate the flexibility of A2A in handling various interaction patterns and data types. Implementers should refer to the detailed object definitions for all fields and constraints.

## 10. Appendices

### 10.1. Relationship to MCP (Model Context Protocol)

A2A and MCP are complementary protocols designed for different aspects of agentic systems:

- **[Model Context Protocol (MCP)](https://modelcontextprotocol.io/):** Focuses on standardizing how AI models and agents connect to and interact with **tools, APIs, data sources, and other external resources.** It defines structured ways to describe tool capabilities (like function calling in LLMs), pass inputs, and receive structured outputs. Think of MCP as the "how-to" for an agent to _use_ a specific capability or access a resource.
- **Agent2Agent Protocol (A2A):** Focuses on standardizing how independent, often opaque, **AI agents communicate and collaborate with each other as peers.** A2A provides an application-level protocol for agents to discover each other, negotiate interaction modalities, manage shared tasks, and exchange conversational context or complex results. It's about how agents _partner_ or _delegate_ work.

**How they work together:**
An A2A Client agent might request an A2A Server agent to perform a complex task. The Server agent, in turn, might use MCP to interact with several underlying tools, APIs, or data sources to gather information or perform actions necessary to fulfill the A2A task.

For a more detailed comparison, see the [A2A and MCP guide](./topics/a2a-and-mcp.md).

### 10.2. Security Considerations Summary

Security is a paramount concern in A2A. Key considerations include:

- **Transport Security:** Always use HTTPS with strong TLS configurations in production environments.
- **Authentication:**
    - Handled via standard HTTP mechanisms (e.g., `Authorization` header with Bearer tokens, API keys).
    - Requirements are declared in the `AgentCard`.
    - Credentials MUST be obtained out-of-band by the client.
    - A2A Servers MUST authenticate every request.
- **Authorization:**
    - A server-side responsibility based on the authenticated identity.
    - Implement the principle of least privilege.
    - Can be granular, based on skills, actions, or data.
- **Push Notification Security:**
    - Webhook URL validation (by the A2A Server sending notifications) is crucial to prevent SSRF.
    - Authentication of the A2A Server to the client's webhook is essential.
    - Authentication of the notification by the client's webhook receiver (verifying it came from the legitimate A2A Server and is relevant) is critical.
    - See the [Streaming & Asynchronous Operations guide](./topics/streaming-and-async.md#security-considerations-for-push-notifications) for detailed push notification security.
- **Input Validation:** Servers MUST rigorously validate all RPC parameters and the content/structure of data in `Message` and `Artifact` parts to prevent injection attacks or processing errors.
- **Resource Management:** Implement rate limiting, concurrency controls, and resource limits to protect agents from abuse or overload.
- **Data Privacy:** Adhere to all applicable privacy regulations for data exchanged in `Message` and `Artifact` parts. Minimize sensitive data transfer.

For a comprehensive discussion, refer to the [Enterprise-Ready Features guide](./topics/enterprise-ready.md).

## 11. A2A Compliance Requirements

This section defines the normative requirements for A2A-compliant implementations.

### 11.1. Agent Compliance

For an agent to be considered **A2A-compliant**, it **MUST**:

#### 11.1.1. Transport Support Requirements

- **Support at least one transport**: Agents **MUST** implement at least one transport protocols as defined in [Section 3.2](#32-supported-transport-protocols).
- **Expose Agent Card**: **MUST** provide a valid `AgentCard` document as defined in [Section 5](#5-agent-discovery-the-agent-card).
- **Declare transport capabilities**: **MUST** accurately declare all supported transports in the `AgentCard` using `preferredTransport` and `additionalInterfaces` fields following the requirements in [Section 5.6](#56-transport-declaration-and-url-relationships).

#### 11.1.2. Core Method Implementation

**MUST** implement all of the following core methods via at least one supported transport:

- `message/send` - Send messages and initiate tasks
- `tasks/get` - Retrieve task status and results
- `tasks/cancel` - Request task cancellation

#### 11.1.3. Optional Method Implementation

**MAY** implement the following optional methods:

- `message/stream` - Streaming message interaction (requires `capabilities.streaming: true`)
- `tasks/resubscribe` - Resume streaming for existing tasks (requires `capabilities.streaming: true`)
- `tasks/pushNotificationConfig/set` - Configure push notifications (requires `capabilities.pushNotifications: true`)
- `tasks/pushNotificationConfig/get` - Retrieve push notification config (requires `capabilities.pushNotifications: true`)
- `tasks/pushNotificationConfig/list` - List push notification configs (requires `capabilities.pushNotifications: true`)
- `tasks/pushNotificationConfig/delete` - Delete push notification config (requires `capabilities.pushNotifications: true`)
- `agent/authenticatedExtendedCard` - Retrieve authenticated agent card (requires `supportsAuthenticatedExtendedCard: true`)

#### 11.1.4. Multi-Transport Compliance

If an agent supports additional transports (gRPC, HTTP+JSON), it **MUST**:

- **Functional equivalence**: Provide identical functionality across all supported transports.
- **Consistent behavior**: Return semantically equivalent results for the same operations.
- **Transport-specific requirements**: Conform to all requirements defined in [Section 3.2](#32-supported-transport-protocols) for each supported transport.
- **Method mapping compliance**: Use the standard method mappings defined in [Section 3.5](#35-method-mapping-and-naming-conventions) for all supported transports.

#### 11.1.5. Data Format Compliance

- **JSON-RPC structure**: **MUST** use valid JSON-RPC 2.0 request/response objects as defined in [Section 6.11](#611-json-rpc-structures).
- **A2A data objects**: **MUST** use the data structures defined in [Section 6](#6-protocol-data-objects) for all protocol entities.
- **Error handling**: **MUST** use the error codes defined in [Section 8](#8-error-handling).

### 11.2. Client Compliance

For a client to be considered **A2A-compliant**, it **MUST**:

#### 11.2.1. Transport Support

- **Multi-transport capability**: **MUST** be able to communicate with agents using at least one transport protocols.
- **Agent Card processing**: **MUST** be able to parse and interpret `AgentCard` documents.
- **Transport selection**: **MUST** be able to select an appropriate transport from the agent's declared capabilities following the rules defined in [Section 5.6.3](#563-client-transport-selection-rules).

#### 11.2.2. Protocol Implementation

- **Core method usage**: **MUST** properly construct requests for at least `message/send` and `tasks/get` methods.
- **Error handling**: **MUST** properly handle all A2A error codes defined in [Section 8.2](#82-a2a-specific-errors).
- **Authentication**: **MUST** support at least one authentication method when interacting with agents that require authentication.

#### 11.2.3. Optional Client Features

Clients **MAY** implement:

- **Multi-transport support**: Support for gRPC and/or HTTP+JSON transports.
- **Streaming support**: Handle streaming methods and Server-Sent Events.
- **Push notification handling**: Serve as webhook endpoints for push notifications.
- **Extended Agent Cards**: Retrieve and use authenticated extended agent cards.

### 11.3. Compliance Testing

Implementations **SHOULD** validate compliance through:

- **Transport interoperability**: Test communication with agents using different transport implementations.
- **Method mapping verification**: Verify that all supported transports use the correct method names and URL patterns as defined in [Section 3.5](#35-method-mapping-and-naming-conventions).
- **Error handling**: Verify proper handling of all defined error conditions.
- **Data format validation**: Ensure JSON schemas match the TypeScript type definitions in [`types/src/types.ts`](https://github.com/a2aproject/A2A/blob/main/types/src/types.ts).
- **Multi-transport consistency**: For multi-transport agents, verify functional equivalence across all supported transports.

=================================================

--- START OF FILE docs/topics/a2a-and-mcp.md ---

# A2A and MCP: Detailed Comparison

In AI agent development, two key protocol types emerge to facilitate
interoperability. One connects agents to tools and resources. The other enables
agent-to-agent collaboration. The Agent2Agent (A2A) Protocol and the
[Model Context Protocol](https://modelcontextprotocol.io/) (MCP) address these distinct but highly complementary needs.

## Model Context Protocol

The Model Context Protocol (MCP) defines how an AI agent interacts with and utilizes individual tools and resources, such as a database or an API.

This protocol offers the following capabilities:

- Standardizes how AI models and agents connect to and interact with tools,
  APIs, and other external resources.
- Defines a structured way to describe tool capabilities, similar to function
  calling in Large Language Models.
- Passes inputs to tools and receives structured outputs.
- Supports common use cases, such as an LLM calling an external API, an agent
  querying a database, or an agent connecting to predefined functions.

## Agent2Agent Protocol

The Agent2Agent Protocol focuses on enabling different agents to collaborate with one another to achieve a common goal.

This protocol offers the following capabilities:

- Standardizes how independent, often opaque, AI agents communicate and
  collaborate as peers.
- Provides an application-level protocol for agents to discover each other,
  negotiate interactions, manage shared tasks, and exchange conversational
  context and complex data.
- Supports typical use cases, including a customer service agent delegating an
  inquiry to a billing agent, or a travel agent coordinating with flight,
  hotel, and activity agents.

## Why Different Protocols?

Both the MCP and A2A protocols are essential for building complex AI systems, and they address distinct but highly complementary needs. The distinction between A2A and MCP depends on what an agent interacts with.

- **Tools and Resources (MCP Domain)**:
      - **Characteristics:** These are typically primitives with well-defined,
        structured inputs and outputs. They perform specific, often stateless,
        functions. Examples include a calculator, a database query API, or a
        weather lookup service.
      - **Purpose:** Agents use tools to gather information and perform discrete
        functions.
- **Agents (A2A domain)**:
      - **Characteristics:** These are more autonomous systems. They reason,
        plan, use multiple tools, maintain state over longer interactions, and
        engage in complex, often multi-turn dialogues to achieve novel or
        evolving tasks.
      - **Purpose:** Agents collaborate with other agents to tackle broader, more
        complex goals.

## A2A ‚ù§Ô∏è MCP: Complementary Protocols for Agentic Systems

An agentic application might primarily use A2A to communicate with other agents.
Each individual agent internally uses MCP to interact with its specific tools
and resources.

<div style="text-align: center; margin: 20px;" markdown>

![Diagram showing A2A and MCP working together. A User interacts with Agent A using A2A. Agent A interacts with Agent B using A2A. Agent B uses MCP to interact with Tool 1 and Tool 2.](../assets/a2a-mcp.png){width="80%"}

_An agentic application might use A2A to communicate with other agents, while each agent internally uses MCP to interact with its specific tools and resources._

</div>

### Example Scenario: The Auto Repair Shop

Consider an auto repair shop staffed by autonomous AI agent "mechanics".
These mechanics use special-purpose tools, such as vehicle diagnostic scanners,
repair manuals, and platform lifts, to diagnose and repair problems. The repair
process can involve extensive conversations, research, and interaction with part
suppliers.

- **Customer Interaction (User-to-Agent using A2A)**: A customer (or their
    primary assistant agent) uses A2A to communicate with the "Shop Manager"
    agent.

    For example, the customer might say, "My car is making a rattling noise".

- **Multi-turn Diagnostic Conversation (Agent-to-Agent using A2A)**: The Shop
    Manager agent uses A2A for a multi-turn diagnostic conversation.

    For example, the Manager might ask, "Can you send a video of the noise?" or "I see some fluid leaking. How long has this been happening?".

- **Internal Tool Usage (Agent-to-Tool using MCP)**: The Mechanic agent,
    assigned the task by the Shop Manager, needs to diagnose the issue. The
    Mechanic agent uses MCP to interact with its specialized tools.

    For example:

    - MCP call to a "Vehicle Diagnostic Scanner" tool:
        `scan_vehicle_for_error_codes(vehicle_id='XYZ123')`
    - MCP call to a "Repair Manual Database" tool:
        `get_repair_procedure(error_code='P0300', vehicle_make='Toyota',
        vehicle_model='Camry')`
    - MCP call to a "Platform Lift" tool: `raise_platform(height_meters=2)`

- **Supplier Interaction (Agent-to-Agent using A2A)**: The Mechanic agent
    determines that a specific part is needed. The Mechanic agent uses A2A to
    communicate with a "Parts Supplier" agent to order a part.
    For example, the
    Mechanic agent might ask, "Do you have part #12345 in stock for a Toyota Camry 2018?"

- **Order processing (Agent-to-Agent using A2A)**: The Parts Supplier agent,
    which is also an A2A-compliant system, responds, potentially leading to an
    order.

In this example:

- A2A facilitates the higher-level, conversational, and task-oriented
    interactions between the customer and the shop, and between the shop's
    agents and external supplier agents.
- MCP enables the mechanic agent to use its specific, structured tools to
    perform its diagnostic and repair functions.

An A2A server could expose some of its skills as MCP-compatible resources.
However, A2A's primary strength lies in its support for more flexible, stateful,
and collaborative interactions. These interactions go beyond a typical tool
invocation. A2A focuses on agents partnering on tasks, whereas MCP focuses on
agents using capabilities.

## Representing A2A Agents as MCP Resources

An A2A Server (a remote agent) could expose some of its skills as MCP-compatible resources, especially if those skills are well-defined and can be invoked in a more tool-like, stateless manner. In such a case, another agent might "discover" this A2A agent's specific skill through an MCP-style tool description (perhaps derived from its Agent Card).

However, the primary strength of A2A lies in its support for more flexible, stateful, and collaborative interactions that go beyond typical tool invocation. A2A is about agents _partnering_ on tasks, while MCP is more about agents _using_ capabilities.

By leveraging both A2A for inter-agent collaboration and MCP for tool integration, developers can build more powerful, flexible, and interoperable AI systems.

=================================================

--- START OF FILE docs/topics/agent-discovery.md ---

# Agent Discovery in A2A

To collaborate using the Agent2Agent (A2A) protocol, AI agents need to first find each other and understand their capabilities. A2A standardizes agent self-descriptions through the **[Agent Card](../specification.md#5-agent-discovery-the-agent-card)**. However, discovery methods for these Agent Cards vary by environment and requirements. The Agent Card defines what an agent offers. Various strategies exist for a client agent to discover these cards. The choice of strategy depends on the deployment environment and security requirements.

## The Role of the Agent Card

The Agent Card is a JSON document that serves as a digital "business card" for an A2A Server (the remote agent). It is crucial for agent discovery and interaction. The key information included in an Agent Card is as follows:

- **Identity:** Includes `name`, `description`, and `provider` information.
- **Service Endpoint:** Specifies the `url` for the A2A service.
- **A2A Capabilities:** Lists supported features such as `streaming` or `pushNotifications`.
- **Authentication:** Details the required `schemes` (e.g., "Bearer", "OAuth2").
- **Skills:** Describes the agent's tasks using `AgentSkill` objects, including `id`, `name`, `description`, `inputModes`, `outputModes`, and `examples`.

Client agents use the Agent Card to determine an agent's suitability, structure requests, and ensure secure communication.

## Discovery Strategies

The following sections detail common strategies used by client agents to discover remote Agent Cards:

### 1. Well-Known URI

This approach is recommended for public agents or agents intended for broad discovery within a specific domain.

- **Mechanism:** A2A Servers make their Agent Card discoverable by hosting it at a standardized, `well-known` URI on their domain. The standard path is `https://{agent-server-domain}/.well-known/agent-card.json`, following the principles of [RFC 8615](https://datatracker.ietf.org/doc/html/rfc8615).

- **Process:**
    1. A client agent knows or programmatically discovers the domain of a potential A2A Server (e.g., `smart-thermostat.example.com`).
    2. The client performs an HTTP GET request to `https://smart-thermostat.example.com/.well-known/agent-card.json`.
    3. If the Agent Card exists and is accessible, the server returns it as a JSON response.

- **Advantages:**
    - Ease of implementation
    - Adheres to standards
    - Facilitates automated discovery

- **Considerations:**
    - Best suited for open or domain-controlled discovery scenarios.
    - Authentication is necessary at the endpoint serving the Agent Card if it contains sensitive details.

### 2. Curated Registries (Catalog-Based Discovery)

This approach is employed in enterprise environments or public marketplaces, where Agent Cards are often managed by a central registry. The curated registry acts as a central repository, allowing clients to query and discover agents based on criteria like "skills" or "tags".

- **Mechanism:** An intermediary service (the registry) maintains a collection of Agent Cards. Clients query this registry to find agents based on various criteria (e.g., skills offered, tags, provider name, capabilities).

- **Process:**
    1. A2A Servers publish their Agent Cards to the registry.
    2. Client agents query the registry's API, and search by criteria such as "specific skills".
    3. The registry returns matching Agent Cards or references.

- **Advantages:**
    - Centralized management and governance.
    - Capability-based discovery (e.g., by skill).
    - Support for access controls and trust frameworks.
    - Applicable in both private and public marketplaces.
- **Considerations:**
    - Requires deployment and maintenance of a registry service.
    - The current A2A specification does not prescribe a standard API for curated registries.

### 3. Direct Configuration / Private Discovery

This approach is used for tightly coupled systems, private agents, or development purposes, where clients are directly configured with Agent Card information or URLs.

- **Mechanism:** Client applications utilize hardcoded details, configuration files, environment variables, or proprietary APIs for discovery.
- **Process:** The process is specific to the application's deployment and configuration strategy.
- **Advantages:** This method is straightforward for establishing connections within known, static relationships.
- **Considerations:**
    - Inflexible for dynamic discovery scenarios.
    - Changes to Agent Card information necessitate client reconfiguration.
    - Proprietary API-based discovery also lacks standardization.

## Securing Agent Cards

Agent Cards include sensitive information, such as:

- URLs for internal or restricted agents.
- Descriptions of sensitive skills.

### Protection Mechanisms

To mitigate risks, the following protection mechanisms should be considered:

- **Authenticated Agent Cards:** We recommend the use of [authenticated extended agent cards](../specification.md#710-agentgetauthenticatedextendedcard) for sensitive information or for serving a more detailed version of the card.
- **Secure Endpoints:** Implement access controls on the HTTP endpoint serving the Agent Card (e.g., `/.well-known/agent-card.json` or registry API). The methods include:
    - Mutual TLS (mTLS)
    - Network restrictions (e.g., IP ranges)
    - HTTP Authentication (e.g., OAuth 2.0)

- **Registry Selective Disclosure:** Registries return different Agent Cards based on the client's identity and permissions.

Any Agent Card containing sensitive data must be protected with authentication and authorization mechanisms. The A2A specification strongly recommends the use of out-of-band dynamic credentials rather than embedding static secrets within the Agent Card.

## Future Considerations

The A2A community explores standardizing registry interactions or advanced discovery protocols.

=================================================

--- START OF FILE docs/topics/enterprise-ready.md ---

# Enterprise Implementation of A2A

The Agent2Agent (A2A) protocol is designed with enterprise requirements at its
core. Rather than inventing new, proprietary standards for security and
operations, A2A aims to integrate seamlessly with existing enterprise
infrastructure and widely adopted best practices. This approach allows
organizations to use their existing investments and expertise in security,
monitoring, governance, and identity management.

A key principle of A2A is that agents are typically **opaque** because they don't
share internal memory, tools, or direct resource access with each other. This
opacity naturally aligns with standard client-server security paradigms,
treating remote agents as standard HTTP-based enterprise applications.

## Transport Level Security (TLS)

Ensuring the confidentiality and integrity of data in transit is fundamental for
any enterprise application.

- **HTTPS Mandate**: All A2A communication in production environments must
    occur over `HTTPS`.
- **Modern TLS Standards**: Implementations should use modern TLS versions.
    TLS 1.2 or higher is recommended. Strong, industry-standard cipher suites
    should be used to protect data from eavesdropping and tampering.
- **Server Identity Verification**: A2A clients should verify the A2A server's
    identity by validating its TLS certificate against trusted certificate
    authorities during the TLS handshake. This prevents man-in-the-middle
    attacks.

## Authentication

A2A delegates authentication to standard web mechanisms. It primarily relies on
HTTP headers and established standards like OAuth2 and OpenID Connect.
Authentication requirements are advertised by the A2A server in its Agent Card.

- **No Identity in Payload**: A2A protocol payloads, such as `JSON-RPC`
    messages, don't carry user or client identity information directly. Identity
    is established at the transport/HTTP layer.
- **Agent Card Declaration**: The A2A server's Agent Card describes the
    authentication schemes it supports in its `security` field and aligns with
    those defined in the OpenAPI Specification for authentication.
- **Out-of-Band Credential Acquisition**: The A2A Client obtains the necessary credentials,
    such as OAuth 2.0 tokens or API keys, through processes external to the A2A protocol itself. Examples include OAuth flows or secure key distribution.
- **HTTP Header Transmission**: Credentials **must** be transmitted in standard
    HTTP headers as per the requirements of the chosen authentication scheme.
    Examples include `Authorization: Bearer <TOKEN>` or `API-Key: <KEY_VALUE>`.
- **Server-Side Validation**: The A2A server **must** authenticate every
    incoming request using the credentials provided in the HTTP headers.
    - If authentication fails or credentials are missing, the server **should**
        respond with a standard HTTP status code:
        - `401 Unauthorized`: If the credentials are missing or invalid. This
            response **should** include a `WWW-Authenticate` header to inform
            the client about the supported authentication methods.
        - `403 Forbidden`: If the credentials are valid, but the authenticated
            client does not have permission to perform the requested action.
- **In-Task Authentication (Secondary Credentials)**: If an agent needs
    additional credentials to access a different system or service during a
    task (for example, to use a specific tool on the user's behalf), the A2A server
    indicates to the client that more information is needed. The client
    is then responsible for obtaining these secondary credentials through a
    process outside of the A2A protocol itself (for example, an OAuth flow) and
    providing them back to the A2A server to continue the task.

## Authorization

Once a client is authenticated, the A2A server is responsible for authorizing
the request. Authorization logic is specific to the agent's implementation,
the data it handles, and applicable enterprise policies.

- **Granular Control**: Authorization **should** be applied based on the
    authenticated identity, which could represent an end user, a client
    application, or both.
- **Skill-Based Authorization**: Access can be controlled on a per-skill
    basis, as advertised in the Agent Card. For example, specific OAuth scopes
    **should** grant an authenticated client access to invoke certain skills but
    not others.
- **Data and Action-Level Authorization**: Agents that interact with backend
    systems, databases, or tools **must** enforce appropriate authorization before
    performing sensitive actions or accessing sensitive data through those
    underlying resources. The agent acts as a gatekeeper.
- **Principle of Least Privilege**: Agents **must** grant only the necessary
    permissions required for a client or user to perform their intended
    operations through the A2A interface.

## Data Privacy and Confidentiality

Protecting sensitive data exchanged between agents is paramount, requiring
strict adherence to privacy regulations and best practices.

- **Sensitivity Awareness**: Implementers must be acutely aware of the
    sensitivity of data exchanged in Message and Artifact parts of A2A
    interactions.
- **Compliance**: Ensure compliance with relevant data privacy regulations
    such as GDPR, CCPA, and HIPAA, based on the domain and data involved.
- **Data Minimization**: Avoid including or requesting unnecessarily sensitive
    information in A2A exchanges.
- **Secure Handling**: Protect data both in transit, using TLS as mandated,
    and at rest if persisted by agents, according to enterprise data security
    policies and regulatory requirements.

## Tracing, Observability, and Monitoring

A2A's reliance on HTTP allows for straightforward integration with standard
enterprise tracing, logging, and monitoring tools, providing critical visibility
into inter-agent workflows.

- **Distributed Tracing**: A2A Clients and Servers **should** participate in
    distributed tracing systems. For example, use OpenTelemetry to propagate
    trace context, including trace IDs and span IDs, through standard HTTP
    headers, such as W3C Trace Context headers. This enables end-to-end
    visibility for debugging and performance analysis.
- **Comprehensive Logging**: Log details on both client and server, including
    taskId, sessionId, correlation IDs, and trace context for troubleshooting
    and auditing.
- **Metrics**: A2A servers should expose key operational metrics, such as
    request rates, error rates, task processing latency, and resource
    utilization, to enable performance monitoring, alerting, and capacity
    planning.
- **Auditing**: Audit significant events, such as task creation, critical
    state changes, and agent actions, especially when involving sensitive data
    or high-impact operations.

## API Management and Governance

For A2A servers exposed externally, across organizational boundaries, or even within
large enterprises, integration with API Management solutions is highly recommended,
as this provides:

- **Centralized Policy Enforcement**: Consistent application of security
    policies such as authentication and authorization, rate limiting, and quotas.
- **Traffic Management**: Load balancing, routing, and mediation.
- **Analytics and Reporting**: Insights into agent usage, performance, and
    trends.
- **Developer Portals**: Facilitate discovery of A2A-enabled agents, provide
documentation such as Agent Cards, and streamline onboarding for client developers.

By adhering to these enterprise-grade practices, A2A implementations can be
deployed securely, reliably, and manageably within complex organizational
environments. This fosters trust and enables scalable inter-agent collaboration.

=================================================

--- START OF FILE docs/topics/extensions.md ---

# Extensions in A2A

The Agent2Agent (A2A) protocol provides a strong foundation for inter-agent
communication. However, specific domains or advanced use cases often require
additional structure, custom data, or new interaction patterns beyond the
generic methods. Extensions are A2A's powerful mechanism for layering new capabilities onto the
base protocol.

Extensions allow for extending the A2A protocol with new data, requirements,
RPC methods, and state machines. Agents declare their support for specific
extensions in their Agent Card, and clients can then opt-in to the behavior
offered by an extension as part of requests they make to the agent. Extensions
are identified by a URI and defined by their own specification. Anyone is able to define, publish, and implement an extension.

The flexibility of extensions allows for customizing A2A without fragmenting
the core standard, fostering innovation and domain-specific optimizations.

## Scope of Extensions

The exact set of possible ways to use extensions is intentionally broad,
facilitating the ability to expand A2A beyond known use cases.
However, some foreseeable applications include:

- **Data-only Extensions**: Exposing new, structured information in the Agent
    Card that doesn't impact the request-response flow. For example, an
    extension could add structured data about an agent's GDPR compliance.
- **Profile Extensions**: Overlaying additional structure and state change
    requirements on the core request-response messages. This type effectively
    acts as a profile on the core A2A protocol, narrowing the space of allowed
    values (for example, requiring all messages to use `DataParts` adhering to
    a specific schema). This can also include augmenting existing states in the
    task state machine by using metadata. For example, an extension could define
    a 'generating-image' sub-state when `TaskStatus.state` is 'working' and
    `TaskStatus.message.metadata["generating-image"]` is true.
- **Method Extensions (Extended Skills)**: Adding entirely new RPC methods
    beyond the core set defined by the protocol. An Extended Skill refers to a
    capability or function an agent gains or exposes specifically through the
    implementation of an extension that defines new RPC methods. For example, a
    `task-history` extension might add a `tasks/search` RPC method to retrieve
    a list of previous tasks, effectively providing the agent with a new,
    extended skill.
- **State Machine Extensions**: Adding new states or transitions to the task
  state machine.

## List of Example Extensions

| Extension | Description |
| :-------- | :------------ |
| [Secure Passport Extension](https://github.com/a2aproject/a2a-samples/tree/main/extensions/secure-passport) | Adds a trusted, contextual layer for immediate personalization and reduced overhead (v1). |
| [Hello World or Timestamp Extension](https://github.com/a2aproject/a2a-samples/tree/main/extensions/timestamp) | A simple extension demonstrating how to augment base A2A types by adding timestamps to the `metadata` field of `Message` and `Artifact` objects (v1). |
| [Traceability Extension](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/extensions/traceability) | Explore the Python implementation and basic usage of the Traceability Extension (v1). |
| [Agent Gateway Protocol (AGP) Extension](https://github.com/a2aproject/a2a-samples/tree/main/extensions/agp) | A Core Protocol Layer or Routing Extension that introduces Autonomous Squads (ASq) and routes Intent payloads based on declared Capabilities, enhancing scalability (v1). |

## Limitations

There are some changes to the protocol that extensions don't allow, primarily
to prevent breaking core type validations:

- **Changing the Definition of Core Data Structures**: For example, adding new
    fields or removing required fields to protocol-defined data structures).
    Extensions should place custom attributes in the `metadata` map present on
    core data structures.
- **Adding New Values to Enum Types**: Extensions should use existing enum values
    and annotate additional semantic meaning in the `metadata` field.

## Extension Declaration

Agents declare their support for extensions in their Agent Card by including
`AgentExtension` objects within their `AgentCapabilities` object.

```ts { .no-copy }
--8<-- "types/src/types.ts:AgentExtension"
```

The following is an example of an Agent Card with an extension:

```json
{
  "name": "Magic 8-ball",
  "description": "An agent that can tell your future... maybe.",
  "version": "0.1.0",
  "url": "https://example.com/agents/eightball",
  "capabilities": {
    "streaming": true,
    "extensions": [
      {
        "uri": "https://example.com/ext/konami-code/v1",
        "description": "Provide cheat codes to unlock new fortunes",
        "required": false,
        "params": {
          "hints": [
            "When your sims need extra cash fast",
            "You might deny it, but we've seen the evidence of those cows."
          ]
        }
      }
    ]
  },
  "defaultInputModes": ["text/plain"],
  "defaultOutputModes": ["text/plain"],
  "skills": [
    {
      "id": "fortune",
      "name": "Fortune teller",
      "description": "Seek advice from the mystical magic 8-ball",
      "tags": ["mystical", "untrustworthy"]
    }
  ]
}
```

## Required Extensions

While extensions generally offer optional functionality, some agents may have
stricter requirements. When an Agent Card declares an extension as
`required: true`, it signals to clients that some aspect of the extension impacts how
requests are structured or processed, and that the client must abide by it.
Agents shouldn't mark data-only extensions as required. If a client does not
request activation of a required extension, or fails to follow its protocol,
the agent should reject the incoming request with an appropriate error.

## Extension Specification

The detailed behavior and structure of an extension are defined by its
**specification**. While the exact format is not mandated, it should contain at
at least:

- The specific URI(s) that identify the extension.
- The schema and meaning of objects specified in the `params` field of the
    `AgentExtension` object.
- Schemas of any additional data structures communicated between client and
    agent.
- Details of new request-response flows, additional endpoints, or any other
    logic required to implement the extension.

## Extension Dependencies

Extensions might depend on other extensions. This can be a required dependency
(where the extension cannot function without the dependent) or an optional one
(where additional functionality is enabled if another extension is present).
Extension specifications should document these dependencies. It is the client's
responsibility to activate an extension and all its required dependencies as
listed in the extension's specification.

## Extension Activation

Extensions default to being inactive, providing a baseline
experience for extension-unaware clients. Clients and agents perform
negotiation to determine which extensions are active for a specific request.

1. **Client Request**: A client requests extension activation by including the
    `X-A2A-Extensions` header in the HTTP request to the agent. The value is a
    comma-separated list of extension URIs the client intends to activate.
2. **Agent Processing**: Agents are responsible for identifying supported
    extensions in the request and performing the activation. Any requested
    extensions not supported by the agent can be ignored.
3. **Response**: Once the agent has identified all activated extensions, the
    response SHOULD include the `X-A2A-Extensions` header, listing all
    extensions that were successfully activated for that request.

![A2A Extension Flow Diagram](https://storage.googleapis.com/gweb-developer-goog-blog-assets/images/Screenshot_2025-09-04_at_13.03.31.original.png){ width="70%" style="margin:20px auto;display:block;" }

**Example request showing extension activation:**

```http
POST /agents/eightball HTTP/1.1
Host: example.com
Content-Type: application/json
X-A2A-Extensions: https://example.com/ext/konami-code/v1
Content-Length: 519
{
  "jsonrpc": "2.0",
  "method": "message/send",
  "id": "1",
  "params": {
    "message": {
      "kind": "message",
      "messageId": "1",
      "role": "user",
      "parts": [{"kind": "text", "text": "Oh magic 8-ball, will it rain today?"}]
    },
    "metadata": {
      "https://example.com/ext/konami-code/v1/code": "motherlode"
    }
  }
}
```

**Corresponding response echoing activated extensions:**

```http
HTTP/1.1 200 OK
Content-Type: application/json
X-A2A-Extensions: https://example.com/ext/konami-code/v1
Content-Length: 338
{
  "jsonrpc": "2.0",
  "id": "1",
  "result": {
    "kind": "message",
    "messageId": "2",
    "role": "agent",
    "parts": [{"kind": "text", "text": "That's a bingo!"}]
  }
}
```

## Implementation Considerations

While the A2A protocol defines the functionality of extensions, this section
provides guidance on their implementation‚Äîbest practices for authoring,
versioning, and distributing extension implementations.

- **Versioning**: Extension specifications evolve. It is
    crucial to have a clear versioning strategy to ensure that clients and
    agents can negotiate compatible implementations.
    - **Recommendation**: Use the extension's URI as the primary version
        identifier, ideally including a version number (for example,
        `https://example.com/ext/my-extension/v1`).
    - **Breaking Changes**: A new URI MUST be used when introducing a breaking
        change to an extension's logic, data structures, or required parameters.
    - Handling Mismatches: If a client requests a version not supported by
        the agent, the agent SHOULD ignore the activation request for that
        extension; it MUST NOT fall back to a different version.
- **Discoverability and Publication**:
    - **Specification Hosting**: The extension specification document **should** be
        hosted at the extension's URI.
    - **Permanent Identifiers**: Authors are encouraged to use a permanent
        identifier service, such as `w3id.org`, for their extension URIs to
        prevent broken links.
    - **Community Registry (Future)**: The A2A community might establish a
        central registry for discovering and browsing available extensions in
        the future.
- **Packaging and Reusability (A2A SDKs and Libraries)**:
    To promote adoption, extension logic should be packaged into reusable
        libraries that can be integrated into existing A2A client and
        server applications.
    - An extension implementation should be distributed as a
        standard package for its language ecosystem (for example, a PyPI package
        for Python, an npm package for TypeScript/JavaScript).
    - The objective is to provide a streamlined integration experience for
        developers. A well-designed extension package should allow a developer
        to add it to their server with minimal code, for example:

        ```python
        --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/adk_expense_reimbursement/__main__.py"
        ```

        This example showcases how A2A SDKs or libraries such as `a2a.server` in
        Python facilitate the implementation of A2A agents and extensions.

- **Security**: Extensions modify the core behavior of the A2A protocol, and therefore
    introduce new security considerations:

    - **Input Validation**: Any new data fields, parameters, or methods
        introduced by an extension MUST be rigorously validated. Treat all
        extension-related data from an external party as untrusted input.
    - **Scope of Required Extensions**: Be mindful when marking an extension as
        `required: true` in an Agent Card. This creates a hard dependency for
        all clients and should only be used for extensions fundamental to the
        agent's core function and security (for example, a message signing
        extension).
    - **Authentication and Authorization**: If an extension adds new methods,
        the implementation MUST ensure these methods are subject to the same
        authentication and authorization checks as the core A2A methods. An
        extension MUST NOT provide a way to bypass the agent's primary security
        controls.

For more information, see the [A2A Extensions: Empowering Custom Agent Functionality](https://developers.googleblog.com/en/a2a-extensions-empowering-custom-agent-functionality/) blog post.

=================================================

--- START OF FILE docs/topics/key-concepts.md ---

# Core Concepts and Components in A2A

A2A uses a set of core concepts that define how agents interact.
Understand these core building blocks to develop or integrate with A2A-compliant
systems.

![A2A Actors showing a User, A2A Client (Client Agent), and A2A Server (Remote Agent)](../assets/a2a-actors.png){ width="70%" style="margin:20px auto;display:block;" }

## Core Actors in A2A Interactions

- **User**: The end user, which can be a human operator or an automated
    service. The user initiates a request or defines a goal that requires
    assistance from one or more AI agents.
- **A2A Client (Client Agent)**: An application, service, or another AI agent
    that acts on behalf of the user. The client initiates communication using the
    A2A protocol.
- **A2A Server (Remote Agent)**: An AI agent or an agentic system that exposes
    an HTTP endpoint implementing the A2A protocol. It receives requests from
    clients, processes tasks, and returns results or status updates. From the client's perspective,
    the remote agent operates as an _opaque_ (black-box) system, meaning its internal workings, memory, or tools are not exposed.

## Fundamental Communication Elements

The following table describes the fundamental communication elements in A2A:

| Element | Description | Key Purpose |
| :------ | :---------- | :---------- |
| Agent Card | A JSON metadata document describing an agent's identity, capabilities, endpoint, skills, and authentication requirements. | Enables clients to discover agents and understand how to interact with them securely and effectively. |
| Task | A stateful unit of work initiated by an agent, with a unique ID and defined lifecycle. | Facilitates tracking of long-running operations and enables multi-turn interactions and collaboration. |
| Message | A single turn of communication between a client and an agent, containing content and a role ("user" or "agent"). | Conveys instructions, context, questions, answers, or status updates that are not necessarily formal artifacts. |
| Part | The fundamental content container (for example, TextPart, FilePart, DataPart) used within Messages and Artifacts. | Provides flexibility for agents to exchange various content types within messages and artifacts. |
| Artifact | A tangible output generated by an agent during a task (for example, a document, image, or structured data). | Delivers the concrete results of an agent's work, ensuring structured and retrievable outputs. |

## Interaction Mechanisms

The A2A Protocol supports various interaction patterns to accommodate different
needs for responsiveness and persistence. These mechanisms ensure that agents
can exchange information efficiently and reliably, regardless of the task's
complexity or duration:

- **Request/Response (Polling)**: Clients send a request and the server
    responds. For long-running tasks, the client periodically polls the server
    for updates.
- **Streaming with Server-Sent Events (SSE)**: Clients initiate a stream to
    receive real-time, incremental results or status updates from the server
    over an open HTTP connection.
- **Push Notifications**: For very long-running tasks or disconnected
    scenarios, the server can actively send asynchronous notifications to a
    client-provided webhook when significant task updates occur.

For a detailed exploration of streaming and push notifications, refer to the
[Streaming & Asynchronous Operations](./streaming-and-async.md) document.

## Agent Cards

The Agent Card is a JSON document that serves as a digital business card for
initial discovery and interaction setup. It provides essential metadata about an
agent. Clients parse this information to determine if an agent is suitable for a
given task, how to structure requests, and how to communicate securely. Key
information includes identity, service endpoint (URL), A2A capabilities,
authentication requirements, and a list of skills.

## Messages and Parts

A message represents a single turn of communication between a client and an
agent. It includes a role ("user" or "agent") and a unique `messageId`. It
contains one or more Part objects, which are granular containers for the actual
content. This design allows A2A to be modality independent.

The primary part kinds are:

- `TextPart`: Contains plain textual content.
- `FilePart`: Represents a file. It can be transmitted either inline (Base64
   encoded) or through a URI. It includes metadata like "name" and "mimeType".
- `DataPart`: Carries structured JSON data. This is useful for forms,
   parameters, or any machine-readable information.

## Artifacts

An artifact represents a tangible output or a concrete result generated by a
remote agent during task processing. Unlike general messages, artifacts are the
actual deliverables. An artifact has a unique `artifactId`, a human-readable
name, and consists of one or more part objects. Artifacts are closely tied to the
task lifecycle and can be streamed incrementally to the client.

## Agent Response: Task or Message

The agent response can be a new `Task` (when the agent needs to perform a
long-running operation) or a `Message` (when the agent can respond immediately).

For more details, see [Life of a Task](./life-of-a-task.md).

## Other Important Concepts

- **Context (`contextId`):** A server-generated identifier that can be used to logically group multiple related `Task` objects, providing context across a series of interactions.
- **Transport and Format:** A2A communication occurs over HTTP(S). JSON-RPC 2.0 is used as the payload format for all requests and responses.
- **Authentication & Authorization:** A2A relies on standard web security practices. Authentication requirements are declared in the Agent Card, and credentials (e.g., OAuth tokens, API keys) are typically passed through HTTP headers, separate from the A2A protocol messages themselves. For more information, see [Enterprise-Ready Features](./enterprise-ready.md).
- **Agent Discovery:** The process by which clients find Agent Cards to learn about available A2A Servers and their capabilities. For more information, see [Agent Discovery](./agent-discovery.md).
- **Extensions:** A2A allows agents to declare custom protocol extensions as part of their AgentCard. For more information, see [Extensions](./extensions.md).

=================================================

--- START OF FILE docs/topics/life-of-a-task.md ---

# Life of a Task

In the Agent2Agent (A2A) Protocol, interactions can range from simple, stateless
exchanges to complex, long-running processes. When an agent receives a message
from a client, it can respond in one of two fundamental ways:

- **Respond with a Stateless `Message`**: This type of response is
    typically used for immediate, self-contained interactions that conclude
    without requiring further state management.
- **Initiate a Stateful `Task`**: If the response is a `Task`, the agent will
    process it through a defined lifecycle, communicating progress and requiring
    input as needed, until it reaches an interrupted state (e.g.,
    `input-required`, `auth-required`) or a terminal state (e.g., `completed`,
    `canceled`, `rejected`, `failed`).

## Group Related Interactions

A `contextId` is a crucial identifier that logically groups multiple `Task`
objects and independent `Message` objects, providing continuity across a series of
interactions.

- When a client sends a message for the first time, the agent responds
    with a new `contextId`. If a task is initiated, it will also have a `taskId`.
- Clients can send subsequent messages and include the same `contextId` to
    indicate that they are continuing their previous interaction within the same
    context.
- Clients optionally attach the `taskId` to a subsequent message to
    indicate that it continues that specific task.

The `contextId` enables collaboration towards a common goal or a shared
contextual session across multiple, potentially concurrent tasks. Internally, an
A2A agent (especially one using an LLM) uses the `contextId` to manage its internal
conversational state or its LLM context.

## Agent Response: Message or Task

The choice between responding with a `Message` or a `Task` depends on the
nature of the interaction and the agent's capabilities:

- **Messages for Trivial Interactions**: `Message` objects are suitable for
    transactional interactions that don't require long-running
    processing or complex state management. An agent might use messages to
    negotiate the acceptance or scope of a task before committing to a `Task`
    object.
- **Tasks for Stateful Interactions**: Once an agent maps the intent of an
    incoming message to a supported capability that requires substantial,
    trackable work over an extended period, the agent responds with a `Task`
    object.

Conceptually, agents operate at different levels of complexity:

- **Message-only Agents**: Always respond with `Message` objects. They
    typically don't manage complex state or long-running executions, and use
    `contextId` to tie messages together. These agents might directly wrap LLM
    invocations and simple tools.
- **Task-generating Agents**: Always respond with `Task` objects, even for
    responses, which are then modeled as completed tasks. Once a task is
    created, the agent will only return `Task` objects in response to messages
    sent, and once a task is complete, no more messages can be sent. This
    approach avoids deciding between `Task` versus `Message`, but creates completed task objects
    for even simple interactions.
- **Hybrid Agents**: Generate both `Message` and `Task` objects. These agents
    use messages to negotiate agent capability and the scope of work for a task,
    then send a `Task` object to track execution and manage states like
    `input-required` or error handling. Once a task is created, the agent will
    only return `Task` objects in response to messages sent, and once a task is
    complete, no more messages can be sent. A hybrid agent uses messages to
    negotiate the scope of a task, and then generate a task to track its
    execution.
    For more information about hybrid agents, see [A2A protocol: Demystifying Tasks vs Messages](https://discuss.google.dev/t/a2a-protocol-demystifying-tasks-vs-messages/255879).

## Task Refinements

Clients often need to send new requests based on task results or refine the
outputs of previous tasks. This is modeled by starting another interaction using
the same `contextId` as the original task. Clients further hint the agent by
providing references to the original task using `referenceTaskIds` in the
`Message` object. The agent then responds with either a new `Task` or a
`Message`.

## Task Immutability

Once a task reaches a terminal state (completed, canceled, rejected, or failed),
it cannot restart. Any subsequent interaction related to that task, such as a
refinement, must initiate a new task within the same `contextId`. This principle
offers several benefits:

- **Task Immutability.** Clients reliably reference tasks and their
    associated state, artifacts, and messages, providing a clean mapping of
    inputs to outputs. This is valuable for orchestration and traceability.
- **Clear Unit of Work.** Every new request, refinement, or follow-up becomes
    a distinct task. This simplifies bookkeeping, allows for granular tracking
    of an agent's work, and enables tracing each artifact to a specific unit of
    work.
- **Easier Implementation.** This removes ambiguity for agent developers
    regarding whether to create a new task or restart an existing one.

## Parallel Follow-ups

A2A supports parallel work by enabling agents to create distinct, parallel
tasks for each follow-up message sent within the same `contextId`. This allows
clients to track individual tasks and create new dependent tasks as soon as a
prerequisite task is complete.

For example:

- Task 1: Book a flight to Helsinki.
- Task 2: Based on Task 1, book a hotel.
- Task 3: Based on Task 1, book a snowmobile activity.
- Task 4: Based on Task 2, add a spa reservation to the hotel booking.

## Referencing Previous Artifacts

The serving agent infers the relevant artifact from a referenced task or from the
`contextId`. As the domain expert, the serving agent is best suited to resolve
ambiguity or identify missing information. If there is ambiguity, the agent asks
the client for clarification by returning an `input-required` state. The client
then specifies the artifact in its response, optionally populating artifact
references (`artifactId`, `taskId`) in `Part` metadata.

## Tracking Artifact Mutation

Follow-up or refinement tasks often lead to the creation of new artifacts based on older ones. Tracking these mutations is important to ensure that only the most recent version of an artifact is used in subsequent interactions. This could be conceptualized as a version history, where each new artifact is linked to its predecessor.

However, the client is in the best position to manage this artifact linkage. The client determines what constitutes an acceptable result and has the ability to accept or reject new versions. Therefore, the serving agent shouldn't be responsible for tracking artifact mutations, and this linkage is not part of the A2A protocol specification. Clients should maintain this version history on their end and present the latest acceptable version to the user.

To facilitate client-side tracking, serving agents should use a consistent `artifact-name` when generating a refined version of an existing artifact.

When initiating follow-up or refinement tasks, the client should explicitly reference the specific artifact they intend to refine, ideally the "latest" version from their perspective. If the artifact reference is not provided, the serving agent can:

- Attempt to infer the intended artifact based on the current `contextId`.
- If there is ambiguity or insufficient context, the agent should respond with an `input-required` task state to request clarification from the client.

## Example Follow-up Scenario

The following example illustrates a typical task flow with a follow-up:

1. Client sends a message to the agent:

    ```json
    {
      "jsonrpc": "2.0",
      "id": "req-001",
      "method": "message.send",
      "params": {
        "message": {
          "role": "user",
          "parts": [
            {
              "kind": "text",
              "text": "Generate an image of a sailboat on the ocean."
            }
          ]
          "messageId": "msg-user-001"
        }
      }
    }
    ```

2. Agent responds with a boat image (completed task):

    ```json
    {
      "jsonrpc": "2.0",
      "id": "req-001",
      "result": {
        "id": "task-boat-gen-123",
        "contextId": "ctx-conversation-abc",
        "status": {
          "state": "completed"
        },
        "artifacts": [
          {
            "artifactId": "artifact-boat-v1-xyz",
            "name": "sailboat_image.png",
            "description": "A generated image of a sailboat on the ocean.",
            "parts": [
              {
                "kind": "file",
                "file": {
                  "name": "sailboat_image.png",
                  "mimeType": "image/png",
                  "bytes": "base64_encoded_png_data_of_a_sailboat"
                }
              }
            ]
          }
        ],
        "kind": "task"
      }
    }
    ```

3. Client asks to color the boat red. This refinement request refers to the
    previous `taskId` and uses the same `contextId`.

    ```json
    {
      "jsonrpc": "2.0",
      "id": "req-002",
      "method": "message.send",
      "params": {
        "message": {
          "role": "user",
          "messageId": "msg-user-002",
          "contextId": "ctx-conversation-abc",
          "referenceTaskIds": [
            "task-boat-gen-123"
          ],
          "parts": [
            {
              "kind": "text",
              "text": "Please modify the sailboat to be red."
            }
          ]
        }
      }
    }
    ```

4. Agent responds with a new image artifact (new task, same context, updated
    artifact name): The agent creates a new task within the same `contextId`. The
    new boat image artifact retains the same name but has a new `artifactId`.

    ```json
    {
      "jsonrpc": "2.0",
      "id": "req-002",
      "result": {
        "id": "task-boat-color-456",
        "contextId": "ctx-conversation-abc",
        "status": {
          "state": "completed"
        },
        "artifacts": [
          {
            "artifactId": "artifact-boat-v2-red-pqr",
            "name": "sailboat_image.png",
            "description": "A generated image of a red sailboat on the ocean.",
            "parts": [
              {
                "kind": "file",
                "file": {
                  "name": "sailboat_image.png",
                  "mimeType": "image/png",
                  "bytes": "base64_encoded_png_data_of_a_RED_sailboat"
                }
              }
            ]
          }
        ],
        "kind": "task"
      }
    }
    ```

=================================================

--- START OF FILE docs/topics/streaming-and-async.md ---

# Streaming and Asynchronous Operations for Long-Running Tasks

The Agent2Agent (A2A) protocol is explicitly designed to handle tasks that might not complete immediately. Many AI-driven operations are often long-running, involve multiple steps, produce incremental results, or require human intervention. A2A provides mechanisms for managing such asynchronous interactions, ensuring that clients receive updates effectively, whether they remain continuously connected or operate in a more disconnected fashion.

## Streaming with Server-Sent Events (SSE)

For tasks that produce incremental results (like generating a long document or streaming media) or provide ongoing status updates, A2A supports real-time communication using Server-Sent Events (SSE). This approach is ideal when the client is able to maintain an active HTTP connection with the A2A Server.

The following key features detail how SSE streaming is implemented and managed within the A2A protocol:

- **Server Capability:** The A2A Server must indicate its support for streaming by setting `capabilities.streaming: true` in its Agent Card.

- **Initiating a Stream:** The client uses the `message/stream` RPC method to send an initial message (for example, a prompt or command) and simultaneously subscribe to updates for that task.

- **Server Response and Connection:** If the subscription is successful, the server responds with an HTTP 200 OK status and a `Content-Type: text/event-stream`. This HTTP connection remains open for the server to push events to the client.

- **Event Structure and Types:** The server sends events over this stream. Each event's `data` field contains a JSON-RPC 2.0 Response object, typically a `SendStreamingMessageResponse`. The `result` field of the `SendStreamingMessageResponse` contains:

    - [`Task`](../specification.md#61-task-object): Represents the current state of the work.
    - [`TaskStatusUpdateEvent`](../specification.md#722-taskstatusupdateevent-object): Communicates changes in the task's lifecycle state (for example, from `working` to `input-required` or `completed`). It also provides intermediate messages from the agent.
    - [`TaskArtifactUpdateEvent`](../specification.md#723-taskartifactupdateevent-object): Delivers new or updated Artifacts generated by the task. This is used to stream large files or data structures in chunks, with fields like `append` and `lastChunk` to help reassemble.

- **Stream Termination:** The server signals the end of updates for a cycle by setting `final: true` in a `TaskStatusUpdateEvent`. This typically occurs when the task reaches a terminal state. After this, the server usually closes the SSE connection.

- **Resubscription:** If a client's SSE connection breaks prematurely while a task is still active, the client is able to attempt to reconnect to the stream using the `tasks/resubscribe` RPC method.

### When to Use Streaming

Streaming with SSE is best suited for:

- Real-time progress monitoring of long-running tasks.
- Receiving large results (artifacts) incrementally.
- Interactive, conversational exchanges where immediate feedback or partial responses are beneficial.
- Applications requiring low-latency updates from the agent.

### Protocol Specification References

Refer to the Protocol Specification for detailed structures:

- [`message/stream`](../specification.md#72-messagestream)
- [`tasks/resubscribe`](../specification.md#79-tasksresubscribe)

## Push Notifications for Disconnected Scenarios

For very long-running tasks (for example, lasting minutes, hours, or even days) or when clients are unable to or prefer not to maintain persistent connections (like mobile clients or serverless functions), A2A supports asynchronous updates using push notifications. This allows the A2A Server to actively notify a client-provided webhook when a significant task update occurs.

The following key features detail how push notifications are implemented and managed within the A2A protocol:

- **Server Capability:** The A2A Server must indicate its support for this feature by setting `capabilities.pushNotifications: true` in its Agent Card.
- **Configuration:** The client provides a [`PushNotificationConfig`](../specification.md#68-pushnotificationconfig-object) to the server. This configuration is supplied:
    - Within the initial `message/send` or `message/stream` request, or
    - Separately, using the `tasks/pushNotificationConfig/set` RPC method for an existing task.
    The `PushNotificationConfig` includes a `url` (the HTTPS webhook URL), an optional `token` (for client-side validation), and optional `authentication` details (for the A2A Server to authenticate to the webhook).
- **Notification Trigger:** The A2A Server decides when to send a push notification, typically when a task reaches a significant state change (for example, terminal state, `input-required`, or `auth-required`).
- **Notification Payload:** The A2A protocol does not strictly define the HTTP body payload, but it SHOULD contain sufficient information for the client to identify the Task ID and understand the general nature of the update (for example, the new `TaskState`).
- **Client Action:** Upon receiving a push notification (and successfully verifying its authenticity), the client typically uses the `tasks/get` RPC method with the `taskId` from the notification to retrieve the complete, updated `Task` object, including any new artifacts.

### When to Use Push Notifications

Push notifications are ideal for:

- Very long-running tasks that can take minutes, hours, or days to complete.
- Clients that cannot or prefer not to maintain persistent connections, such as mobile applications or serverless functions.
- Scenarios where clients only need to be notified of significant state changes rather than continuous updates.

### Protocol Specification References

Refer to the Protocol Specification for detailed structures:

- [`tasks/pushNotificationConfig/set`](../specification.md#75-taskspushnotificationconfigset)
- [`tasks/get`](../specification.md#76-taskspushnotificationconfigget)

### Client-Side Push Notification Service

The `url` specified in `PushNotificationConfig.url` points to a client-side Push Notification Service. This service is responsible for receiving the HTTP POST notification from the A2A Server. Its responsibilities include authenticating the incoming notification, validating its relevance, and relaying the notification or its content to the appropriate client application logic or system.

### Security Considerations for Push Notifications

Security is paramount for push notifications due to their asynchronous and server-initiated outbound nature. Both the A2A Server (sending the notification) and the client's webhook receiver have critical responsibilities.

#### A2A Server Security (when sending notifications to client webhook)

- **Webhook URL Validation:** Servers SHOULD NOT blindly trust and send POST requests to any URL provided by a client. Malicious clients could provide URLs pointing to internal services or unrelated third-party systems, leading to Server-Side Request Forgery (SSRF) attacks or acting as Distributed Denial of Service (DDoS) amplifiers.
    - **Mitigation strategies:** Allowlisting of trusted domains, ownership verification (for example, challenge-response mechanisms), and network controls (e.g., egress firewalls).
- **Authenticating to the Client's Webhook:** The A2A Server MUST authenticate itself to the client's webhook URL according to the scheme(s) specified in `PushNotificationConfig.authentication`. Common schemes include Bearer Tokens (OAuth 2.0), API keys, HMAC signatures, or mutual TLS (mTLS).

#### Client Webhook Receiver Security (when receiving notifications from A2A server)

- **Authenticating the A2A Server:** The webhook endpoint MUST rigorously verify the authenticity of incoming notification requests to ensure they originate from the legitimate A2A Server and not an imposter.
    - **Verification methods:** Verify signatures/tokens (for example, JWT signatures against the A2A Server's trusted public keys, HMAC signatures, or API key validation). Also, validate the `PushNotificationConfig.token` if provided.
- **Preventing Replay Attacks:**
    - **Timestamps:** Notifications SHOULD include a timestamp. The webhook SHOULD reject notifications that are too old.
    - **Nonces/unique IDs:** For critical notifications, consider using unique, single-use identifiers (for example, JWT's `jti` claim or event IDs) to prevent processing duplicate notifications.
- **Secure Key Management and Rotation:** Implement secure key management practices, including regular key rotation, especially for cryptographic keys. Protocols like JWKS (JSON Web Key Set) facilitate key rotation for asymmetric keys.

#### Example Asymmetric Key Flow (JWT + JWKS)

1. Client sets `PushNotificationConfig` specifying `authentication.schemes: ["Bearer"]` and possibly an expected `issuer` or `audience` for the JWT.
2. A2A Server, when sending a notification:
    - Generates a JWT, signing it with its private key. The JWT includes claims like `iss` (issuer), `aud` (audience), `iat` (issued at), `exp` (expires), `jti` (JWT ID), and `taskId`.
    - The JWT header indicates the signing algorithm and key ID (`kid`).
    - The A2A Server makes its public keys available through a JWKS endpoint.
3. Client Webhook, upon receiving the notification:
    - Extracts the JWT from the Authorization header.
    - Inspects the `kid` (key ID) in the JWT header.
    - Fetches the corresponding public key from the A2A Server's JWKS endpoint (caching keys is recommended).
    - Verifies the JWT signature using the public key.
    - Validates claims (`iss`, `aud`, `iat`, `exp`, `jti`).
    - Checks the `PushNotificationConfig.token` if provided.

This comprehensive, layered approach to security for push notifications helps ensure that messages are authentic, integral, and timely, protecting both the sending A2A Server and the receiving client webhook infrastructure.

=================================================

--- START OF FILE docs/topics/what-is-a2a.md ---

# What is A2A?

The A2A protocol is an open standard that enables seamless communication and
collaboration between AI agents. It provides a common language for agents built
using diverse frameworks and by different vendors, fostering interoperability
and breaking down silos. Agents are autonomous problem-solvers that act
independently within their environment. A2A allows agents from different
developers, built on different frameworks, and owned by different organizations
to unite and work together.

## Why Use the A2A Protocol

A2A addresses key challenges in AI agent collaboration. It provides
a standardized approach for agents to interact. This section explains the
problems A2A solves and the benefits it offers.

### Problems that A2A Solves

Consider a user request for an AI assistant to plan an international trip. This
task involves orchestrating multiple specialized agents, such as:

- A flight booking agent
- A hotel reservation agent
- An agent for local tour recommendations
- A currency conversion agent

Without A2A, integrating these diverse agents presents several challenges:

- **Agent Exposure**: Developers often wrap agents as tools to expose them to
    other agents, similar to how tools are exposed in a Multi-agent Control
    Platform (Model Context Protocol). However, this approach is inefficient because agents are
    designed to negotiate directly. Wrapping agents as tools limits their capabilities.
    A2A allows agents to be exposed as they are, without requiring this wrapping.
- **Custom Integrations**: Each interaction requires custom, point-to-point
    solutions, creating significant engineering overhead.
- **Slow Innovation**: Bespoke development for each new integration slows
    innovation.
- **Scalability Issues**: Systems become difficult to scale and maintain as
    the number of agents and interactions grows.
- **Interoperability**: This approach limits interoperability,
    preventing the organic formation of complex AI ecosystems.
- **Security Gaps**: Ad hoc communication often lacks consistent security
    measures.

The A2A protocol addresses these challenges by establishing interoperability for
AI agents to interact reliably and securely.

### A2A Example Scenario

This section provides an example scenario to illustrate the benefits of using an A2A (Agent2Agent) protocol for complex interactions between AI agents.

#### A User's Complex Request

A user interacts with an AI assistant, giving it a complex prompt like "Plan an international trip."

```mermaid
graph LR
    User --> Prompt --> AI_Assistant[AI Assistant]
```

#### The Need for Collaboration

The AI assistant receives the prompt and realizes it needs to call upon multiple specialized agents to fulfill the request. These agents include a Flight Booking Agent, a Hotel Reservation Agent, a Currency Conversion Agent, and a Local Tours Agent.

```mermaid
graph LR
    subgraph "Specialized Agents"
        FBA[‚úàÔ∏è Flight Booking Agent]
        HRA[üè® Hotel Reservation Agent]
        CCA[üí± Currency Conversion Agent]
        LTA[üöå Local Tours Agent]
    end

    AI_Assistant[ü§ñ AI Assistant] --> FBA
    AI_Assistant --> HRA
    AI_Assistant --> CCA
    AI_Assistant --> LTA
```

#### The Interoperability Challenge

The core problem: The agents are unable to work together because each has its own bespoke development and deployment.

The consequence of a lack of a standardized protocol is that these agents cannot collaborate with each other let alone discover what they can do. The individual agents (Flight, Hotel, Currency, and Tours) are isolated.

#### The "With A2A" Solution

The A2A Protocol provides standard methods and data structures for agents to communicate with one another, regardless of their underlying implementation, so the same agents can be used as an interconnected system, communicating seamlessly through the standardized protocol.

The AI assistant, now acting as an orchestrator, receives the cohesive information from all the A2A-enabled agents. It then presents a single, complete travel plan as a seamless response to the user's initial prompt.

![A2A Actors showing a User, A2A Client (Client Agent), and A2A Server (Remote Agent)](../assets/a2a-actors.png){ width="70%" style="margin:20px auto;display:block;" }

### Core Benefits of A2A

Implementing the A2A protocol offers significant advantages across the AI ecosystem:

- **Secure collaboration**: Without a standard, it's difficult to ensure
    secure communication between agents. A2A uses HTTPS for secure communication
    and maintains opaque operations, so agents can't see the inner workings of
    other agents during collaboration.
- **Interoperability**: A2A breaks down silos between different AI
    agent ecosystems, enabling agents from various vendors and frameworks to work
    together seamlessly.
- **Agent autonomy**: A2A allows agents to retain their individual capabilities
    and act as autonomous entities while collaborating with other agents.
- **Reduced integration complexity**: The protocol standardizes agent
    communication, enabling teams to focus on the unique value their agents
    provide.
- **Support for LRO**: The protocol supports long-running operations (LRO) and
    streaming with Server-Sent Events (SSE) and asynchronous execution.

### Key Design Principles of A2A

A2A development follows principles that prioritize broad adoption,
enterprise-grade capabilities, and future-proofing.

- **Simplicity**: A2A leverages existing standards like HTTP, JSON-RPC, and
    Server-Sent Events (SSE). This avoids reinventing core technologies and
    accelerates developer adoption.
- **Enterprise Readiness**: A2A addresses critical enterprise needs. It aligns
    with standard web practices for robust authentication, authorization,
    security, privacy, tracing, and monitoring.
- **Asynchronous**: A2A natively supports long-running tasks. It handles
    scenarios where agents or users might not remain continuously connected. It
    uses mechanisms like streaming and push notifications.
- **Modality Independent**: The protocol allows agents to communicate using a
    wide variety of content types. This enables rich and flexible interactions
    beyond plain text.
- **Opaque Execution**: Agents collaborate effectively without exposing their
    internal logic, memory, or proprietary tools. Interactions rely on declared
    capabilities and exchanged context. This preserves intellectual property and
    enhances security.

### Understanding the Agent Stack: A2A, MCP, Agent Frameworks and Models

A2A is situated within a broader agent stack, which includes:

- **A2A:** Standardizes communication among agents deployed in different organizations and developed using diverse frameworks.
- **MCP:** Connects models to data and external resources.
- **Frameworks (like ADK):** Provide toolkits for constructing agents.
- **Models:** Fundamental to an agent's reasoning, these can be any Large Language Model (LLM).

![ADK versus MCP](../assets/agentic-stack.png){ width="70%" style="margin:20px auto;display:block;" }

#### A2A and MCP

In the broader ecosystem of AI communication, you might be familiar with protocols designed to facilitate interactions between agents, models, and tools. Notably, the Model Context Protocol (MCP) is an emerging standard focused on connecting Large Language Models (LLMs) with data and external resources.

The Agent2Agent (A2A) protocol is designed to standardize communication between AI agents, particularly those deployed in external systems. A2A is positioned to complement MCP, addressing a distinct yet related aspect of agent interaction.

- **MCP's Focus:** Reducing the complexity involved in connecting agents with tools and data. Tools are typically stateless and perform specific, predefined functions (e.g., a calculator, a database query).
- **A2A's Focus:** Enabling agents to collaborate within their native modalities, allowing them to communicate as agents (or as users) rather than being constrained to tool-like interactions. This enables complex, multi-turn interactions where agents reason, plan, and delegate tasks to other agents. For example, this facilitates multi-turn interactions, such as those involving negotiation or clarification when placing an order.

![ADK + MCP](../assets/a2a-mcp-readme.png){ width="70%" style="margin:20px auto;display:block;" }

The practice of encapsulating an agent as a simple tool is fundamentally limiting, as it fails to capture the agent's full capabilities. This critical distinction is explored in the post, [Why Agents Are Not Tools](https://discuss.google.dev/t/agents-are-not-tools/192812).

For a more in-depth comparison, refer to the [A2A and MCP Comparison](a2a-and-mcp.md) document.

#### A2A and ADK

The [Agent Development Kit (ADK)](https://google.github.io/adk-docs)
is an open-source agent development toolkit developed by Google. A2A is a
communication protocol for agents that enables inter-agent communication,
regardless of the framework used for their construction (e.g., ADK, LangGraph,
or Crew AI). ADK is a flexible and modular framework for developing and
deploying AI agents. While optimized for Gemini AI and the Google ecosystem,
ADK is model-agnostic, deployment-agnostic, and built for compatibility with
other frameworks.

### A2A Request Lifecycle

The A2A request lifecycle is a sequence that details the four main steps a request follows: agent discovery, authentication, `sendMessage` API, and `sendMessageStream` API. The following diagram provides a deeper look into the operational flow, illustrating the interactions between the client, A2A server, and auth server.

```mermaid
sequenceDiagram
    participant Client
    participant A2A Server
    participant Auth Server

    rect rgb(240, 240, 240)
    Note over Client, A2A Server: 1. Agent Discovery
    Client->>A2A Server: GET agent card eg: (/.well-known/agent-card)
    A2A Server-->>Client: Returns Agent Card
    end

    rect rgb(240, 240, 240)
    Note over Client, Auth Server: 2. Authentication
    Client->>Client: Parse Agent Card for securitySchemes
    alt securityScheme is "openIdConnect"
        Client->>Auth Server: Request token based on "authorizationUrl" and "tokenUrl".
        Auth Server-->>Client: Returns JWT
    end
    end

    rect rgb(240, 240, 240)
    Note over Client, A2A Server: 3. sendMessage API
    Client->>Client: Parse Agent Card for "url" param to send API requests to.
    Client->>A2A Server: POST /sendMessage (with JWT)
    A2A Server->>A2A Server: Process message and create task
    A2A Server-->>Client: Returns Task Response
    end

    rect rgb(240, 240, 240)
    Note over Client, A2A Server: 4. sendMessageStream API
    Client->>A2A Server: POST /sendMessageStream (with JWT)
    A2A Server-->>Client: Stream: Task (Submitted)
    A2A Server-->>Client: Stream: TaskStatusUpdateEvent (Working)
    A2A Server-->>Client: Stream: TaskArtifactUpdateEvent (artifact A)
    A2A Server-->>Client: Stream: TaskArtifactUpdateEvent (artifact B)
    A2A Server-->>Client: Stream: TaskStatusUpdateEvent (Completed)
    end
```

## What's Next

Learn about the [Key Concepts](./key-concepts.md) that form the foundation of the A2A protocol.

=================================================

--- START OF FILE docs/tutorials/index.md ---

# Tutorials

## Python

Tutorial | Description | Difficulty
:--------|:------------|:-----------
[A2A and Python Quickstart](./python/1-introduction.md) | Learn to build a simple Python-based "echo" A2A server and client. | Easy
[ADK facts](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/agents/adk_facts) | Build and test a simple Personal Assistant agent using the Agent Development Kit (ADK) that can provide interesting facts. | Easy
[ADK agent on Cloud Run](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/agents/adk_cloud_run) | Deploy, manage, and observe an ADK-based agent as a scalable, serverless service on Google Cloud Run.| Easy
[Multi-agent collaboration using A2A](https://github.com/a2aproject/a2a-samples/tree/main/demo) | Learn how to set up an orchestrator (host agent) that routes and manages requests among several specialized A2A-compatible agents. | Easy
[Airbnb and weather multi-agent](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/agents/airbnb_planner_multiagent) | Build a complex multi-agent system where agents collaborate using A2A to plan a trip, finding both Airbnb accommodations and weather information. | Medium
[A2A Client-Server example using remote ADK agent](https://goo.gle/adk-a2a) | Learn how a local A2A client agent discovers and consumes the capabilities of a separate, remote ADK-based agent (for example, a prime number checker). | Easy
[Colab Notebook](https://github.com/a2aproject/a2a-samples/blob/main/notebooks/multi_agents_eval_with_cloud_run_deployment.ipynb) | Use Colab Notebook to deploy A2A agents to Cloud Run from your browser, and then evaluate their performance with Vertex AI. | Easy

## Java

Tutorial | Description
:--------|:-----------
[Multi-language translator agent using Java](https://github.com/a2aproject/a2a-samples/tree/main/samples/java) | Implement the A2A protocol using Java SDK to create an interactive language translation service.

## JavaScript

Tutorial | Description
:--------|:------------
[Movie research agent using JavaScript](https://github.com/a2aproject/a2a-samples/tree/main/samples/js) | Build an A2A agent with Node.js that uses the TMDB (The Movie Database) API to handle movie searches and queries.

## C#/.NET

Tutorial | Description
:--------|:------------
[All .NET samples](https://github.com/a2aproject/a2a-dotnet/tree/main/samples) | Repository of foundational samples showing how to build A2A clients and servers, including an Echo Agent, using the C#/.NET SDK.

=================================================

--- START OF FILE docs/tutorials/python/1-introduction.md ---

# Python Quickstart Tutorial: Building an A2A Agent

Welcome to the Agent2Agent (A2A) Python Quickstart Tutorial!

In this tutorial, you will explore a simple "echo" A2A server using the Python SDK. This will introduce you to the fundamental concepts and components of an A2A server. You will then look at a more advanced example that integrates a Large Language Model (LLM).

This hands-on guide will help you understand:

- The basic concepts behind the A2A protocol.
- How to set up a Python environment for A2A development using the SDK.
- How Agent Skills and Agent Cards describe an agent.
- How an A2A server handles tasks.
- How to interact with an A2A server using a client.
- How streaming capabilities and multi-turn interactions work.
- How an LLM can be integrated into an A2A agent.

By the end of this tutorial, you will have a functional understanding of A2A agents and a solid foundation for building or integrating A2A-compliant applications.

## Tutorial Sections

The tutorial is broken down into the following steps:

1. **[Introduction (This Page)](./1-introduction.md)**
2. **[Setup](./2-setup.md)**: Prepare your Python environment and the A2A SDK.
3. **[Agent Skills & Agent Card](./3-agent-skills-and-card.md)**: Define what your agent can do and how it describes itself.
4. **[The Agent Executor](./4-agent-executor.md)**: Understand how the agent logic is implemented.
5. **[Starting the Server](./5-start-server.md)**: Run the Helloworld A2A server.
6. **[Interacting with the Server](./6-interact-with-server.md)**: Send requests to your agent.
7. **[Streaming & Multi-Turn Interactions](./7-streaming-and-multiturn.md)**: Explore advanced capabilities with the LangGraph example.
8. **[Next Steps](./8-next-steps.md)**: Explore further possibilities with A2A.

Let's get started!

=================================================

--- START OF FILE docs/tutorials/python/2-setup.md ---

# 2. Setup Your Environment

## Prerequisites

- Python 3.10 or higher.
- Access to a terminal or command prompt.
- Git, for cloning the repository.
- A code editor (e.g., Visual Studio Code) is recommended.

## Clone the Repository

If you haven't already, clone the A2A Samples repository:

```bash
git clone https://github.com/a2aproject/a2a-samples.git -b main --depth 1
cd a2a-samples
```

## Python Environment & SDK Installation

We recommend using a virtual environment for Python projects. The A2A Python SDK uses `uv` for dependency management, but you can use `pip` with `venv` as well.

1. **Create and activate a virtual environment:**

    Using `venv` (standard library):

    === "Mac/Linux"

        ```sh
        python -m venv .venv
        source .venv/bin/activate
        ```

    === "Windows"

        ```powershell
        python -m venv .venv
        .venv\Scripts\activate
        ```

2. **Install needed Python dependencies along with the A2A SDK and its dependencies:**

    ```bash
    pip install -r samples/python/requirements.txt
    ```

## Verify Installation

After installation, you should be able to import the `a2a` package in a Python interpreter:

```bash
python -c "import a2a; print('A2A SDK imported successfully')"
```

If this command runs without error and prints the success message, your environment is set up correctly.

=================================================

--- START OF FILE docs/tutorials/python/3-agent-skills-and-card.md ---

# 3. Agent Skills & Agent Card

Before an A2A agent can do anything, it needs to define what it _can_ do (its skills) and how other agents or clients can find out about these capabilities (its Agent Card).

We'll use the `helloworld` example located in [`a2a-samples/samples/python/agents/helloworld/`](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/agents/helloworld).

## Agent Skills

An **Agent Skill** describes a specific capability or function the agent can perform. It's a building block that tells clients what kinds of tasks the agent is good for.

Key attributes of an `AgentSkill` (defined in `a2a.types`):

- `id`: A unique identifier for the skill.
- `name`: A human-readable name.
- `description`: A more detailed explanation of what the skill does.
- `tags`: Keywords for categorization and discovery.
- `examples`: Sample prompts or use cases.
- `inputModes` / `outputModes`: Supported Media Types for input and output (e.g., "text/plain", "application/json").

In `__main__.py`, you can see how a skill for the Helloworld agent is defined:

```python { .no-copy }
--8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/__main__.py:AgentSkill"
```

This skill is very simple: it's named "Returns hello world" and primarily deals with text.

## Agent Card

The **Agent Card** is a JSON document that an A2A Server makes available, typically at a `.well-known/agent-card.json` endpoint. It's like a digital business card for the agent.

Key attributes of an `AgentCard` (defined in `a2a.types`):

- `name`, `description`, `version`: Basic identity information.
- `url`: The endpoint where the A2A service can be reached.
- `capabilities`: Specifies supported A2A features like `streaming` or `pushNotifications`.
- `defaultInputModes` / `defaultOutputModes`: Default Media Types for the agent.
- `skills`: A list of `AgentSkill` objects that the agent offers.

The `helloworld` example defines its Agent Card like this:

```python { .no-copy }
--8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/__main__.py:AgentCard"
```

This card tells us the agent is named "Hello World Agent", runs at `http://localhost:9999/`, supports text interactions, and has the `hello_world` skill. It also indicates public authentication, meaning no specific credentials are required.

Understanding the Agent Card is crucial because it's how a client discovers an agent and learns how to interact with it.

=================================================

--- START OF FILE docs/tutorials/python/4-agent-executor.md ---

# 4. The Agent Executor

The core logic of how an A2A agent processes requests and generates responses/events is handled by an **Agent Executor**. The A2A Python SDK provides an abstract base class `a2a.server.agent_execution.AgentExecutor` that you implement.

## `AgentExecutor` Interface

The `AgentExecutor` class defines two primary methods:

- `async def execute(self, context: RequestContext, event_queue: EventQueue)`: Handles incoming requests that expect a response or a stream of events. It processes the user's input (available via `context`) and uses the `event_queue` to send back `Message`, `Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent` objects.
- `async def cancel(self, context: RequestContext, event_queue: EventQueue)`: Handles requests to cancel an ongoing task.

The `RequestContext` provides information about the incoming request, such as the user's message and any existing task details. The `EventQueue` is used by the executor to send events back to the client.

## Helloworld Agent Executor

Let's look at `agent_executor.py`. It defines `HelloWorldAgentExecutor`.

1. **The Agent (`HelloWorldAgent`)**:
    This is a simple helper class that encapsulates the actual "business logic".

    ```python { .no-copy }
    --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/agent_executor.py:HelloWorldAgent"
    ```

    It has a simple `invoke` method that returns the string "Hello World".

2. **The Executor (`HelloWorldAgentExecutor`)**:
    This class implements the `AgentExecutor` interface.

    - **`__init__`**:

        ```python { .no-copy }
        --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/agent_executor.py:HelloWorldAgentExecutor_init"
        ```

        It instantiates the `HelloWorldAgent`.

    - **`execute`**:

        ```python { .no-copy }
        --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/agent_executor.py:HelloWorldAgentExecutor_execute"
        ```

        When a `message/send` or `message/stream` request comes in (both are handled by `execute` in this simplified executor):

        1. It calls `self.agent.invoke()` to get the "Hello World" string.
        2. It creates an A2A `Message` object using the `new_agent_text_message` utility function.
        3. It enqueues this message onto the `event_queue`. The underlying `DefaultRequestHandler` will then process this queue to send the response(s) to the client. For a single message like this, it will result in a single response for `message/send` or a single event for `message/stream` before the stream closes.

    - **`cancel`**:
        The Helloworld example's `cancel` method simply raises an exception, indicating that cancellation is not supported for this basic agent.

        ```python { .no-copy }
        --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/agent_executor.py:HelloWorldAgentExecutor_cancel"
        ```

The `AgentExecutor` acts as the bridge between the A2A protocol (managed by the request handler and server application) and your agent's specific logic. It receives context about the request and uses an event queue to communicate results or updates back.

=================================================

--- START OF FILE docs/tutorials/python/5-start-server.md ---

# 5. Starting the Server

Now that we have an Agent Card and an Agent Executor, we can set up and start the A2A server.

The A2A Python SDK provides an `A2AStarletteApplication` class that simplifies running an A2A-compliant HTTP server. It uses [Starlette](https://www.starlette.io/) for the web framework and is typically run with an ASGI server like [Uvicorn](https://www.uvicorn.org/).

## Server Setup in Helloworld

Let's look at `__main__.py` again to see how the server is initialized and started.

```python { .no-copy }
--8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/__main__.py"
```

Let's break this down:

1. **`DefaultRequestHandler`**:

    - The SDK provides `DefaultRequestHandler`. This handler takes your `AgentExecutor` implementation (here, `HelloWorldAgentExecutor`) and a `TaskStore` (here, `InMemoryTaskStore`).
    - It routes incoming A2A RPC calls to the appropriate methods on your executor (like `execute` or `cancel`).
    - The `TaskStore` is used by the `DefaultRequestHandler` to manage the lifecycle of tasks, especially for stateful interactions, streaming, and resubscription. Even if your agent executor is simple, the handler needs a task store.

2. **`A2AStarletteApplication`**:

    - The `A2AStarletteApplication` class is instantiated with the `agent_card` and the `request_handler` (referred to as `http_handler` in its constructor).
    - The `agent_card` is crucial because the server will expose it at the `/.well-known/agent-card.json` endpoint (by default).
    - The `request_handler` is responsible for processing all incoming A2A method calls by interacting with your `AgentExecutor`.

3. **`uvicorn.run(server_app_builder.build(), ...)`**:
    - The `A2AStarletteApplication` has a `build()` method that constructs the actual Starlette application.
    - This application is then run using `uvicorn.run()`, making your agent accessible over HTTP.
    - `host='0.0.0.0'` makes the server accessible on all network interfaces on your machine.
    - `port=9999` specifies the port to listen on. This matches the `url` in the `AgentCard`.

## Running the Helloworld Server

Navigate to the `a2a-samples` directory in your terminal (if you're not already there) and ensure your virtual environment is activated.

To run the Helloworld server:

```bash
# from the a2a-samples directory
python samples/python/agents/helloworld/__main__.py
```

You should see output similar to this, indicating the server is running:

```console { .no-copy }
INFO:     Started server process [xxxxx]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:9999 (Press CTRL+C to quit)
```

Your A2A Helloworld agent is now live and listening for requests! In the next step, we'll interact with it.

=================================================

--- START OF FILE docs/tutorials/python/6-interact-with-server.md ---

# 6. Interacting with the Server

With the Helloworld A2A server running, let's send some requests to it. The SDK includes a client (`A2AClient`) that simplifies these interactions.

## The Helloworld Test Client

The `test_client.py` script demonstrates how to:

1. Fetch the Agent Card from the server.
2. Create an `A2AClient` instance.
3. Send both non-streaming (`message/send`) and streaming (`message/stream`) requests.

Open a **new terminal window**, activate your virtual environment, and navigate to the `a2a-samples` directory.

Activate virtual environment (Be sure to do this in the same directory where you created the virtual environment):

=== "Mac/Linux"

    ```sh
    source .venv/bin/activate
    ```

=== "Windows"

    ```powershell
    .venv\Scripts\activate
    ```

Run the test client:

```bash
# from the a2a-samples directory
python samples/python/agents/helloworld/test_client.py
```

## Understanding the Client Code

Let's look at key parts of `test_client.py`:

1. **Fetching the Agent Card & Initializing the Client**:

    ```python { .no-copy }
    --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/test_client.py:A2ACardResolver"
    ```

    The `A2ACardResolver` class is a convenience. It first fetches the `AgentCard` from the server's `/.well-known/agent-card.json` endpoint (based on the provided base URL) and then initializes the client with it.

2. **Sending a Non-Streaming Message (`send_message`)**:

    ```python { .no-copy }
    --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/test_client.py:send_message"
    ```

    - The `send_message_payload` constructs the data for `MessageSendParams`.
    - This is wrapped in a `SendMessageRequest`.
    - It includes a `message` object with the `role` set to "user" and the content in `parts`.
    - The Helloworld agent's `execute` method will enqueue a single "Hello World" message. The `DefaultRequestHandler` will retrieve this and send it as the response.
    - The `response` will be a `SendMessageResponse` object, which contains either a `SendMessageSuccessResponse` (with the agent's `Message` as the result) or a `JSONRPCErrorResponse`.

3. **Handling Task IDs (Illustrative Note for Helloworld)**:

    The Helloworld client (`test_client.py`) doesn't attempt `get_task` or `cancel_task` directly because the simple Helloworld agent's `execute` method, when called via `message/send`, results in the `DefaultRequestHandler` returning a direct `Message` response rather than a `Task` object. More complex agents that explicitly manage tasks (like the LangGraph example) would return a `Task` object from `message/send`, and its `id` could then be used for `get_task` or `cancel_task`.

4. **Sending a Streaming Message (`send_message_streaming`)**:

    ```python { .no-copy }
    --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/helloworld/test_client.py:send_message_streaming"
    ```

    - This method calls the agent's `message/stream` endpoint. The `DefaultRequestHandler` will invoke the `HelloWorldAgentExecutor.execute` method.
    - The `execute` method enqueues one "Hello World" message, and then the event queue is closed.
    - The client will receive this single message as one `SendStreamingMessageResponse` event, and then the stream will terminate.
    - The `stream_response` is an `AsyncGenerator`.

## Expected Output

When you run `test_client.py`, you'll see JSON outputs for:

- The non-streaming response (a single "Hello World" message).
- The streaming response (a single "Hello World" message as one chunk, after which the stream ends).

The `id` fields in the output will vary with each run.

```console { .no-copy }
// Non-streaming response
{"jsonrpc":"2.0","id":"xxxxxxxx","result":{"type":"message","role":"agent","parts":[{"type":"text","text":"Hello World"}],"messageId":"yyyyyyyy"}}
// Streaming response (one chunk)
{"jsonrpc":"2.0","id":"zzzzzzzz","result":{"type":"message","role":"agent","parts":[{"type":"text","text":"Hello World"}],"messageId":"wwwwwwww","final":true}}
```

_(Actual IDs like `xxxxxxxx`, `yyyyyyyy`, `zzzzzzzz`, `wwwwwwww` will be different UUIDs/request IDs)_

This confirms your server is correctly handling basic A2A interactions with the updated SDK structure!

Now you can shut down the server by typing Ctrl+C in the terminal window where `__main__.py` is running.

=================================================

--- START OF FILE docs/tutorials/python/7-streaming-and-multiturn.md ---

# 7. Streaming & Multi-Turn Interactions (LangGraph Example)

The Helloworld example demonstrates the basic mechanics of A2A. For more advanced features like robust streaming, task state management, and multi-turn conversations powered by an LLM, we'll turn to the LangGraph example located in [`a2a-samples/samples/python/agents/langgraph/`](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/agents/langgraph).

This example features a "Currency Agent" that uses the Gemini model via LangChain and LangGraph to answer currency conversion questions.

## Setting up the LangGraph Example

1. Create a [Gemini API Key](https://ai.google.dev/gemini-api/docs/api-key), if you don't already have one.

2. **Environment Variable:**

    Create a `.env` file in the `a2a-samples/samples/python/agents/langgraph/` directory:

    ```bash
    echo "GOOGLE_API_KEY=YOUR_API_KEY_HERE" > .env
    ```

    Replace `YOUR_API_KEY_HERE` with your actual Gemini API key.

3. **Install Dependencies (if not already covered):**

    The `langgraph` example has its own `pyproject.toml` which includes dependencies like `langchain-google-genai` and `langgraph`. When you installed the SDK from the `a2a-samples` root using `pip install -e .[dev]`, this should have also installed the dependencies for the workspace examples, including `langgraph-example`. If you encounter import errors, ensure your primary SDK installation from the root directory was successful.

## Running the LangGraph Server

Navigate to the `a2a-samples/samples/python/agents/langgraph/app` directory in your terminal and ensure your virtual environment (from the SDK root) is activated.

Start the LangGraph agent server:

```bash
python __main__.py
```

This will start the server, usually on `http://localhost:10000`.

## Interacting with the LangGraph Agent

Open a **new terminal window**, activate your virtual environment, and navigate to `a2a-samples/samples/python/agents/langgraph/app`.

Run its test client:

```bash
python test_client.py
```

Now, you can shut down the server by typing Ctrl+C in the terminal window where `__main__.py` is running.

## Key Features Demonstrated

The `langgraph` example showcases several important A2A concepts:

1. **LLM Integration**:

    - `agent.py` defines `CurrencyAgent`. It uses `ChatGoogleGenerativeAI` and LangGraph's `create_react_agent` to process user queries.
    - This demonstrates how a real LLM can power the agent's logic.

2. **Task State Management**:

    - `samples/langgraph/__main__.py` initializes a `DefaultRequestHandler` with an `InMemoryTaskStore`.

        ```python { .no-copy }
        --8<-- "https://raw.githubusercontent.com/a2aproject/a2a-samples/refs/heads/main/samples/python/agents/langgraph/app/__main__.py:DefaultRequestHandler"
        ```

    - The `CurrencyAgentExecutor` (in `samples/langgraph/agent_executor.py`), when its `execute` method is called by the `DefaultRequestHandler`, interacts with the `RequestContext` which contains the current task (if any).
    - For `message/send`, the `DefaultRequestHandler` uses the `TaskStore` to persist and retrieve task state across interactions. The response to `message/send` will be a full `Task` object if the agent's execution flow involves multiple steps or results in a persistent task.
    - The `test_client.py`'s `run_single_turn_test` demonstrates getting a `Task` object back and then querying it using `get_task`.

3. **Streaming with `TaskStatusUpdateEvent` and `TaskArtifactUpdateEvent`**:

    - The `execute` method in `CurrencyAgentExecutor` is responsible for handling both non-streaming and streaming requests, orchestrated by the `DefaultRequestHandler`.
    - As the LangGraph agent processes the request (which might involve calling tools like `get_exchange_rate`), the `CurrencyAgentExecutor` enqueues different types of events onto the `EventQueue`:
        - `TaskStatusUpdateEvent`: For intermediate updates (e.g., "Looking up exchange rates...", "Processing the exchange rates.."). The `final` flag on these events is `False`.
        - `TaskArtifactUpdateEvent`: When the final answer is ready, it's enqueued as an artifact. The `lastChunk` flag is `True`.
        - A final `TaskStatusUpdateEvent` with `state=TaskState.completed` and `final=True` is sent to signify the end of the task for streaming.
    - The `test_client.py`'s `run_streaming_test` function will print these individual event chunks as they are received from the server.

4. **Multi-Turn Conversation (`TaskState.input_required`)**:

    - The `CurrencyAgent` can ask for clarification if a query is ambiguous (e.g., user asks "how much is 100 USD?").
    - When this happens, the `CurrencyAgentExecutor` will enqueue a `TaskStatusUpdateEvent` where `status.state` is `TaskState.input_required` and `status.message` contains the agent's question (e.g., "To which currency would you like to convert?"). This event will have `final=True` for the current interaction stream.
    - The `test_client.py`'s `run_multi_turn_test` function demonstrates this:
        - It sends an initial ambiguous query.
        - The agent responds (via the `DefaultRequestHandler` processing the enqueued events) with a `Task` whose status is `input_required`.
        - The client then sends a second message, including the `taskId` and `contextId` from the first turn's `Task` response, to provide the missing information ("in GBP"). This continues the same task.

## Exploring the Code

Take some time to look through these files:

- `__main__.py`: Server setup using `A2AStarletteApplication` and `DefaultRequestHandler`. Note the `AgentCard` definition includes `capabilities.streaming=True`.
- `agent.py`: The `CurrencyAgent` with LangGraph, LLM model, and tool definitions.
- `agent_executor.py`: The `CurrencyAgentExecutor` implementing the `execute` (and `cancel`) method. It uses the `RequestContext` to understand the ongoing task and the `EventQueue` to send back various events (`TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`, new `Task` object implicitly via the first event if no task exists).
- `test_client.py`: Demonstrates various interaction patterns, including retrieving task IDs and using them for multi-turn conversations.

This example provides a much richer illustration of how A2A facilitates complex, stateful, and asynchronous interactions between agents.

=================================================

--- START OF FILE docs/tutorials/python/8-next-steps.md ---

# Next Steps

Congratulations on completing the A2A Python SDK Tutorial! You've learned how to:

- Set up your environment for A2A development.
- Define Agent Skills and Agent Cards using the SDK's types.
- Implement a basic HelloWorld A2A server and client.
- Understand and implement streaming capabilities.
- Integrate a more complex agent using LangGraph, demonstrating task state management and tool use.

You now have a solid foundation for building and integrating your own A2A-compliant agents.

## Where to Go From Here?

Here are some ideas and resources to continue your A2A journey:

- **Explore Other Examples:**
    - Check out the other examples in the [a2a-samples GitHub repository](https://github.com/a2aproject/a2a-samples/tree/main/samples) for more complex agent integrations and features.
- **Deepen Your Protocol Understanding:**
    - üìö Read the complete [A2A Protocol Documentation site](https://a2a-protocol.org) for a comprehensive overview.
    - üìù Review the detailed [A2A Protocol Specification](../../specification.md) to understand the nuances of all data structures and RPC methods.
- **Review Key A2A Topics:**
    - [A2A and MCP](../../topics/a2a-and-mcp.md): Understand how A2A complements the Model Context Protocol for tool usage.
    - [Enterprise-Ready Features](../../topics/enterprise-ready.md): Learn about security, observability, and other enterprise considerations.
    - [Streaming & Asynchronous Operations](../../topics/streaming-and-async.md): Get more details on SSE and push notifications.
    - [Agent Discovery](../../topics/agent-discovery.md): Explore different ways agents can find each other.
- **Build Your Own Agent:**
    - Try creating a new A2A agent using your favorite Python agent framework (like LangChain, CrewAI, AutoGen, Semantic Kernel, or a custom solution).
    - Implement the `a2a.server.AgentExecutor` interface to bridge your agent's logic with the A2A protocol.
    - Think about what unique skills your agent could offer and how its Agent Card would represent them.
- **Experiment with Advanced Features:**
    - Implement robust task management with a persistent `TaskStore` if your agent handles long-running or multi-session tasks.
    - Explore implementing push notifications if your agent's tasks are very long-lived.
    - Consider more complex input and output modalities (e.g., handling file uploads/downloads, or structured data via `DataPart`).
- **Contribute to the A2A Community:**
    - Join the discussions on the [A2A GitHub Discussions page](https://github.com/a2aproject/A2A/discussions).
    - Report issues or suggest improvements via [GitHub Issues](https://github.com/a2aproject/A2A/issues).
    - Consider contributing code, examples, or documentation. See the [CONTRIBUTING.md](https://github.com/a2aproject/A2A/blob/main/CONTRIBUTING.md) guide.

The A2A protocol aims to foster an ecosystem of interoperable AI agents. By building and sharing A2A-compliant agents, you can be a part of this exciting development!

=================================================

--- START OF FILE specification/grpc/a2a.proto ---

// Older protoc compilers don't understand edition yet.
syntax = "proto3";
package a2a.v1;

import "google/api/annotations.proto";
import "google/api/client.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

option csharp_namespace = "A2a.V1";
option go_package = "google.golang.org/a2a/v1";
option java_multiple_files = true;
option java_outer_classname = "A2A";
option java_package = "com.google.a2a.v1";

// A2AService defines the gRPC version of the A2A protocol. This has a slightly
// different shape than the JSONRPC version to better conform to AIP-127,
// where appropriate. The nouns are AgentCard, Message, Task and
// TaskPushNotificationConfig.
// - Messages are not a standard resource so there is no get/delete/update/list
//   interface, only a send and stream custom methods.
// - Tasks have a get interface and custom cancel and subscribe methods.
// - TaskPushNotificationConfig are a resource whose parent is a task.
//   They have get, list and create methods.
// - AgentCard is a static resource with only a get method.
service A2AService {
  // Send a message to the agent. This is a blocking call that will return the
  // task once it is completed, or a LRO if requested.
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse) {
    option (google.api.http) = {
      post: "/v1/message:send"
      body: "*"
    };
  }
  // SendStreamingMessage is a streaming call that will return a stream of
  // task update events until the Task is in an interrupted or terminal state.
  rpc SendStreamingMessage(SendMessageRequest) returns (stream StreamResponse) {
    option (google.api.http) = {
      post: "/v1/message:stream"
      body: "*"
    };
  }

  // Get the current state of a task from the agent.
  rpc GetTask(GetTaskRequest) returns (Task) {
    option (google.api.http) = {
      get: "/v1/{name=tasks/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // List tasks with optional filtering and pagination.
  rpc ListTasks(ListTasksRequest) returns (ListTasksResponse) {
    option (google.api.http) = {
      get: "/v1/tasks"
    };
  }
  // Cancel a task from the agent. If supported one should expect no
  // more task updates for the task.
  rpc CancelTask(CancelTaskRequest) returns (Task) {
    option (google.api.http) = {
      post: "/v1/{name=tasks/*}:cancel"
      body: "*"
    };
  }
  // TaskSubscription is a streaming call that will return a stream of task
  // update events. This attaches the stream to an existing in process task.
  // If the task is complete the stream will return the completed task (like
  // GetTask) and close the stream.
  rpc TaskSubscription(TaskSubscriptionRequest)
      returns (stream StreamResponse) {
    option (google.api.http) = {
      get: "/v1/{name=tasks/*}:subscribe"
    };
  }

  // Set a push notification config for a task.
  rpc CreateTaskPushNotificationConfig(CreateTaskPushNotificationConfigRequest)
      returns (TaskPushNotificationConfig) {
    option (google.api.http) = {
      post: "/v1/{parent=tasks/*/pushNotificationConfigs}"
      body: "config"
    };
    option (google.api.method_signature) = "parent,config";
  }
  // Get a push notification config for a task.
  rpc GetTaskPushNotificationConfig(GetTaskPushNotificationConfigRequest)
      returns (TaskPushNotificationConfig) {
    option (google.api.http) = {
      get: "/v1/{name=tasks/*/pushNotificationConfigs/*}"
    };
    option (google.api.method_signature) = "name";
  }
  // Get a list of push notifications configured for a task.
  rpc ListTaskPushNotificationConfig(ListTaskPushNotificationConfigRequest)
      returns (ListTaskPushNotificationConfigResponse) {
    option (google.api.http) = {
      get: "/v1/{parent=tasks/*}/pushNotificationConfigs"
    };
    option (google.api.method_signature) = "parent";
  }
  // GetAgentCard returns the agent card for the agent.
  rpc GetAgentCard(GetAgentCardRequest) returns (AgentCard) {
    option (google.api.http) = {
      get: "/v1/card"
    };
  }
  // Delete a push notification config for a task.
  rpc DeleteTaskPushNotificationConfig(DeleteTaskPushNotificationConfigRequest)
      returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/{name=tasks/*/pushNotificationConfigs/*}"
    };
    option (google.api.method_signature) = "name";
  }
}

///////// Data Model ////////////

// --8<-- [start:MessageSendConfiguration]
// Configuration of a send message request.
message SendMessageConfiguration {
  // The output modes that the agent is expected to respond with.
  repeated string accepted_output_modes = 1;
  // A configuration of a webhook that can be used to receive updates
  PushNotificationConfig push_notification = 2;
  // The maximum number of messages to include in the history. if 0, the
  // history will be unlimited.
  int32 history_length = 3;
  // If true, the message will be blocking until the task is completed. If
  // false, the message will be non-blocking and the task will be returned
  // immediately. It is the caller's responsibility to check for any task
  // updates.
  bool blocking = 4;
}
// --8<-- [end:MessageSendConfiguration]

// --8<-- [start:Task]
// Task is the core unit of action for A2A. It has a current status
// and when results are created for the task they are stored in the
// artifact. If there are multiple turns for a task, these are stored in
// history.
message Task {
  // Unique identifier (e.g. UUID) for the task, generated by the server for a
  // new task.
  string id = 1;
  // Unique identifier (e.g. UUID) for the contextual collection of interactions
  // (tasks and messages). Created by the A2A server.
  string context_id = 2;
  // The current status of a Task, including state and a message.
  TaskStatus status = 3;
  // A set of output artifacts for a Task.
  repeated Artifact artifacts = 4;
  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
  // The history of interactions from a task.
  repeated Message history = 5;
  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
  // A key/value object to store custom metadata about a task.
  google.protobuf.Struct metadata = 6;
}
// --8<-- [end:Task]

// --8<-- [start:TaskState]
// The set of states a Task can be in.
enum TaskState {
  TASK_STATE_UNSPECIFIED = 0;
  // Represents the status that acknowledges a task is created
  TASK_STATE_SUBMITTED = 1;
  // Represents the status that a task is actively being processed
  TASK_STATE_WORKING = 2;
  // Represents the status a task is finished. This is a terminal state
  TASK_STATE_COMPLETED = 3;
  // Represents the status a task is done but failed. This is a terminal state
  TASK_STATE_FAILED = 4;
  // Represents the status a task was cancelled before it finished.
  // This is a terminal state.
  TASK_STATE_CANCELLED = 5;
  // Represents the status that the task requires information to complete.
  // This is an interrupted state.
  TASK_STATE_INPUT_REQUIRED = 6;
  // Represents the status that the agent has decided to not perform the task.
  // This may be done during initial task creation or later once an agent
  // has determined it can't or won't proceed. This is a terminal state.
  TASK_STATE_REJECTED = 7;
  // Represents the state that some authentication is needed from the upstream
  // client. Authentication is expected to come out-of-band thus this is not
  // an interrupted or terminal state.
  TASK_STATE_AUTH_REQUIRED = 8;
}
// --8<-- [end:TaskState]

// --8<-- [start:TaskStatus]
// A container for the status of a task
message TaskStatus {
  // The current state of this task
  TaskState state = 1;
  // A message associated with the status.
  Message update = 2 [json_name = "message"];
  // Timestamp when the status was recorded.
  // Example: "2023-10-27T10:00:00Z"
  google.protobuf.Timestamp timestamp = 3;
}
// --8<-- [end:TaskStatus]

// --8<-- [start:Part]
// Part represents a container for a section of communication content.
// Parts can be purely textual, some sort of file (image, video, etc) or
// a structured data blob (i.e. JSON).
message Part {
  oneof part {
    string text = 1;
    FilePart file = 2;
    DataPart data = 3;
  }
  // Optional metadata associated with this part.
  google.protobuf.Struct metadata = 4;
}
// --8<-- [end:Part]

// --8<-- [start:FilePart]
// FilePart represents the different ways files can be provided. If files are
// small, directly feeding the bytes is supported via file_with_bytes. If the
// file is large, the agent should read the content as appropriate directly
// from the file_with_uri source.
message FilePart {
  oneof file {
    string file_with_uri = 1;
    bytes file_with_bytes = 2;
  }
  string mime_type = 3;
  string name = 4;
}
// --8<-- [end:FilePart]

// --8<-- [start:DataPart]
// DataPart represents a structured blob. This is most commonly a JSON payload.
message DataPart {
  google.protobuf.Struct data = 1;
}
// --8<-- [end:DataPart]

enum Role {
  ROLE_UNSPECIFIED = 0;
  // USER role refers to communication from the client to the server.
  ROLE_USER = 1;
  // AGENT role refers to communication from the server to the client.
  ROLE_AGENT = 2;
}

// --8<-- [start:Message]
// Message is one unit of communication between client and server. It is
// associated with a context and optionally a task. Since the server is
// responsible for the context definition, it must always provide a context_id
// in its messages. The client can optionally provide the context_id if it
// knows the context to associate the message to. Similarly for task_id,
// except the server decides if a task is created and whether to include the
// task_id.
message Message {
  // The unique identifier (e.g. UUID)of the message. This is required and
  // created by the message creator.
  string message_id = 1;
  // The context id of the message. This is optional and if set, the message
  // will be associated with the given context.
  string context_id = 2;
  // The task id of the message. This is optional and if set, the message
  // will be associated with the given task.
  string task_id = 3;
  // A role for the message.
  Role role = 4;
  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
  // Parts is the container of the message content.
  repeated Part parts = 5;
  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
  // Any optional metadata to provide along with the message.
  google.protobuf.Struct metadata = 6;
  // The URIs of extensions that are present or contributed to this Message.
  repeated string extensions = 7;
  // A list of task IDs that this message references for additional context.
  repeated string reference_task_ids = 8;
}
// --8<-- [end:Message]

// --8<-- [start:Artifact]
// Artifacts are the container for task completed results. These are similar
// to Messages but are intended to be the product of a task, as opposed to
// point-to-point communication.
message Artifact {
  // Unique identifier (e.g. UUID) for the artifact. It must be at least unique
  // within a task.
  string artifact_id = 1;
  // A human readable name for the artifact.
  string name = 3;
  // A human readable description of the artifact, optional.
  string description = 4;
  // The content of the artifact.
  repeated Part parts = 5;
  // Optional metadata included with the artifact.
  google.protobuf.Struct metadata = 6;
  // The URIs of extensions that are present or contributed to this Artifact.
  repeated string extensions = 7;
}
// --8<-- [end:Artifact]

// --8<-- [start:TaskStatusUpdateEvent]
// TaskStatusUpdateEvent is a delta even on a task indicating that a task
// has changed.
message TaskStatusUpdateEvent {
  // The id of the task that is changed
  string task_id = 1;
  // The id of the context that the task belongs to
  string context_id = 2;
  // The new status of the task.
  TaskStatus status = 3;
  // Whether this is the last status update expected for this task.
  bool final = 4;
  // Optional metadata to associate with the task update.
  google.protobuf.Struct metadata = 5;
}
// --8<-- [end:TaskStatusUpdateEvent]

// --8<-- [start:TaskArtifactUpdateEvent]
// TaskArtifactUpdateEvent represents a task delta where an artifact has
// been generated.
message TaskArtifactUpdateEvent {
  // The id of the task for this artifact
  string task_id = 1;
  // The id of the context that this task belongs too
  string context_id = 2;
  // The artifact itself
  Artifact artifact = 3;
  //  Whether this should be appended to a prior one produced
  bool append = 4;
  // Whether this represents the last part of an artifact
  bool last_chunk = 5;
  // Optional metadata associated with the artifact update.
  google.protobuf.Struct metadata = 6;
}
// --8<-- [end:TaskArtifactUpdateEvent]

// --8<-- [start:PushNotificationConfig]
// Configuration for setting up push notifications for task updates.
message PushNotificationConfig {
  // A unique identifier (e.g. UUID) for this push notification.
  string id = 1;
  // Url to send the notification too
  string url = 2;
  // Token unique for this task/session
  string token = 3;
  // Information about the authentication to sent with the notification
  AuthenticationInfo authentication = 4;
}
// --8<-- [end:PushNotificationConfig]

// --8<-- [start:PushNotificationAuthenticationInfo]
// Defines authentication details, used for push notifications.
message AuthenticationInfo {
  // Supported authentication schemes - e.g. Basic, Bearer, etc
  repeated string schemes = 1;
  // Optional credentials
  string credentials = 2;
}
// --8<-- [end:PushNotificationAuthenticationInfo]

// --8<-- [start:AgentInterface]
// Defines additional transport information for the agent.
message AgentInterface {
  // The url this interface is found at.
  string url = 1;
  // The transport supported this url. This is an open form string, to be
  // easily extended for many transport protocols. The core ones officially
  // supported are JSONRPC, GRPC and HTTP+JSON.
  string transport = 2;
}
// --8<-- [end:AgentInterface]

// --8<-- [start:AgentCard]
// AgentCard conveys key information:
// - Overall details (version, name, description, uses)
// - Skills; a set of actions/solutions the agent can perform
// - Default modalities/content types supported by the agent.
// - Authentication requirements
// Next ID: 19
message AgentCard {
  // The version of the A2A protocol this agent supports.
  string protocol_version = 16;
  // A human readable name for the agent.
  // Example: "Recipe Agent"
  string name = 1;
  // A description of the agent's domain of action/solution space.
  // Example: "Agent that helps users with recipes and cooking."
  string description = 2;
  // A URL to the address the agent is hosted at. This represents the
  // preferred endpoint as declared by the agent.
  string url = 3;
  // The transport of the preferred endpoint. If empty, defaults to JSONRPC.
  string preferred_transport = 14;
  // Announcement of additional supported transports. Client can use any of
  // the supported transports.
  repeated AgentInterface additional_interfaces = 15;
  // The service provider of the agent.
  AgentProvider provider = 4;
  // The version of the agent.
  // Example: "1.0.0"
  string version = 5;
  // A url to provide additional documentation about the agent.
  string documentation_url = 6;
  // A2A Capability set supported by the agent.
  AgentCapabilities capabilities = 7;
  // The security scheme details used for authenticating with this agent.
  map<string, SecurityScheme> security_schemes = 8;
  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
  // Security requirements for contacting the agent.
  // This list can be seen as an OR of ANDs. Each object in the list describes
  // one possible set of security requirements that must be present on a
  // request. This allows specifying, for example, "callers must either use
  // OAuth OR an API Key AND mTLS."
  // Example:
  // security {
  //   schemes { key: "oauth" value { list: ["read"] } }
  // }
  // security {
  //   schemes { key: "api-key" }
  //   schemes { key: "mtls" }
  // }
  repeated Security security = 9;
  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
  // The set of interaction modes that the agent supports across all skills.
  // This can be overridden per skill. Defined as mime types.
  repeated string default_input_modes = 10;
  // The mime types supported as outputs from this agent.
  repeated string default_output_modes = 11;
  // Skills represent a unit of ability an agent can perform. This may
  // somewhat abstract but represents a more focused set of actions that the
  // agent is highly likely to succeed at.
  repeated AgentSkill skills = 12;
  // Whether the agent supports providing an extended agent card when
  // the user is authenticated, i.e. is the card from .well-known
  // different than the card from GetAgentCard.
  bool supports_authenticated_extended_card = 13;
  // JSON Web Signatures computed for this AgentCard.
  repeated AgentCardSignature signatures = 17;
  // An optional URL to an icon for the agent.
  string icon_url = 18;
}
// --8<-- [end:AgentCard]

// --8<-- [start:AgentProvider]
// Represents information about the service provider of an agent.
message AgentProvider {
  // The providers reference url
  // Example: "https://ai.google.dev"
  string url = 1;
  // The providers organization name
  // Example: "Google"
  string organization = 2;
}
// --8<-- [end:AgentProvider]

// --8<-- [start:AgentCapabilities]
// Defines the A2A feature set supported by the agent
message AgentCapabilities {
  // If the agent will support streaming responses
  bool streaming = 1;
  // If the agent can send push notifications to the clients webhook
  bool push_notifications = 2;
  // Extensions supported by this agent.
  repeated AgentExtension extensions = 3;
  // If the agent provides a history of state transitions for a task.
  bool state_transition_history = 4;
}
// --8<-- [end:AgentCapabilities]

// --8<-- [start:AgentExtension]
// A declaration of an extension supported by an Agent.
message AgentExtension {
  // The URI of the extension.
  // Example: "https://developers.google.com/identity/protocols/oauth2"
  string uri = 1;
  // A description of how this agent uses this extension.
  // Example: "Google OAuth 2.0 authentication"
  string description = 2;
  // Whether the client must follow specific requirements of the extension.
  // Example: false
  bool required = 3;
  // Optional configuration for the extension.
  google.protobuf.Struct params = 4;
}
// --8<-- [end:AgentExtension]

// --8<-- [start:AgentSkill]
// AgentSkill represents a unit of action/solution that the agent can perform.
// One can think of this as a type of highly reliable solution that an agent
// can be tasked to provide. Agents have the autonomy to choose how and when
// to use specific skills, but clients should have confidence that if the
// skill is defined that unit of action can be reliably performed.
message AgentSkill {
  // Unique identifier of the skill within this agent.
  string id = 1;
  // A human readable name for the skill.
  string name = 2;
  // A human (or llm) readable description of the skill
  // details and behaviors.
  string description = 3;
  // A set of tags for the skill to enhance categorization/utilization.
  // Example: ["cooking", "customer support", "billing"]
  repeated string tags = 4;
  // A set of example queries that this skill is designed to address.
  // These examples should help the caller to understand how to craft requests
  // to the agent to achieve specific goals.
  // Example: ["I need a recipe for bread"]
  repeated string examples = 5;
  // Possible input modalities supported.
  repeated string input_modes = 6;
  // Possible output modalities produced
  repeated string output_modes = 7;
  // protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
  // Security schemes necessary for the agent to leverage this skill.
  // As in the overall AgentCard.security, this list represents a logical OR of
  // security requirement objects. Each object is a set of security schemes
  // that must be used together (a logical AND).
  repeated Security security = 8;
  // protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
}
// --8<-- [end:AgentSkill]

// --8<-- [start:AgentCardSignature]
// AgentCardSignature represents a JWS signature of an AgentCard.
// This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
message AgentCardSignature {
  // The protected JWS header for the signature. This is always a
  // base64url-encoded JSON object. Required.
  string protected = 1 [(google.api.field_behavior) = REQUIRED];
  // The computed signature, base64url-encoded. Required.
  string signature = 2 [(google.api.field_behavior) = REQUIRED];
  // The unprotected JWS header values.
  google.protobuf.Struct header = 3;
}
// --8<-- [end:AgentCardSignature]

// --8<-- [start:TaskPushNotificationConfig]
message TaskPushNotificationConfig {
  // The resource name of the config.
  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
  string name = 1;
  // The push notification configuration details.
  PushNotificationConfig push_notification_config = 2;
}
// --8<-- [end:TaskPushNotificationConfig]

// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
message StringList {
  repeated string list = 1;
}
// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED

message Security {
  map<string, StringList> schemes = 1;
}

// --8<-- [start:SecurityScheme]
message SecurityScheme {
  oneof scheme {
    APIKeySecurityScheme api_key_security_scheme = 1;
    HTTPAuthSecurityScheme http_auth_security_scheme = 2;
    OAuth2SecurityScheme oauth2_security_scheme = 3;
    OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4;
    MutualTlsSecurityScheme mtls_security_scheme = 5;
  }
}
// --8<-- [end:SecurityScheme]

// --8<-- [start:APIKeySecurityScheme]
message APIKeySecurityScheme {
  // Description of this security scheme.
  string description = 1;
  // Location of the API key, valid values are "query", "header", or "cookie"
  string location = 2;
  // Name of the header, query or cookie parameter to be used.
  string name = 3;
}
// --8<-- [end:APIKeySecurityScheme]

// --8<-- [start:HTTPAuthSecurityScheme]
message HTTPAuthSecurityScheme {
  // Description of this security scheme.
  string description = 1;
  // The name of the HTTP Authentication scheme to be used in the
  // Authorization header as defined in RFC7235. The values used SHOULD be
  // registered in the IANA Authentication Scheme registry.
  // The value is case-insensitive, as defined in RFC7235.
  string scheme = 2;
  // A hint to the client to identify how the bearer token is formatted.
  // Bearer tokens are usually generated by an authorization server, so
  // this information is primarily for documentation purposes.
  string bearer_format = 3;
}
// --8<-- [end:HTTPAuthSecurityScheme]

// --8<-- [start:OAuth2SecurityScheme]
message OAuth2SecurityScheme {
  // Description of this security scheme.
  string description = 1;
  // An object containing configuration information for the flow types supported
  OAuthFlows flows = 2;
  // URL to the oauth2 authorization server metadata
  // [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
  string oauth2_metadata_url = 3;
}
// --8<-- [end:OAuth2SecurityScheme]

// --8<-- [start:OpenIdConnectSecurityScheme]
message OpenIdConnectSecurityScheme {
  // Description of this security scheme.
  string description = 1;
  // Well-known URL to discover the [[OpenID-Connect-Discovery]] provider
  // metadata.
  string open_id_connect_url = 2;
}
// --8<-- [end:OpenIdConnectSecurityScheme]

// --8<-- [start:MutualTLSSecurityScheme]
message MutualTlsSecurityScheme {
  // Description of this security scheme.
  string description = 1;
}
// --8<-- [end:MutualTLSSecurityScheme]

// --8<-- [start:OAuthFlows]
message OAuthFlows {
  oneof flow {
    AuthorizationCodeOAuthFlow authorization_code = 1;
    ClientCredentialsOAuthFlow client_credentials = 2;
    ImplicitOAuthFlow implicit = 3;
    PasswordOAuthFlow password = 4;
  }
}
// --8<-- [end:OAuthFlows]

// --8<-- [start:AuthorizationCodeOAuthFlow]
message AuthorizationCodeOAuthFlow {
  // The authorization URL to be used for this flow. This MUST be in the
  // form of a URL. The OAuth2 standard requires the use of TLS
  string authorization_url = 1;
  // The token URL to be used for this flow. This MUST be in the form of a URL.
  // The OAuth2 standard requires the use of TLS.
  string token_url = 2;
  // The URL to be used for obtaining refresh tokens. This MUST be in the
  // form of a URL. The OAuth2 standard requires the use of TLS.
  string refresh_url = 3;
  // The available scopes for the OAuth2 security scheme. A map between the
  // scope name and a short description for it. The map MAY be empty.
  map<string, string> scopes = 4;
}
// --8<-- [end:AuthorizationCodeOAuthFlow]

// --8<-- [start:ClientCredentialsOAuthFlow]
message ClientCredentialsOAuthFlow {
  // The token URL to be used for this flow. This MUST be in the form of a URL.
  // The OAuth2 standard requires the use of TLS.
  string token_url = 1;
  // The URL to be used for obtaining refresh tokens. This MUST be in the
  // form of a URL. The OAuth2 standard requires the use of TLS.
  string refresh_url = 2;
  // The available scopes for the OAuth2 security scheme. A map between the
  // scope name and a short description for it. The map MAY be empty.
  map<string, string> scopes = 3;
}
// --8<-- [end:ClientCredentialsOAuthFlow]

// --8<-- [start:ImplicitOAuthFlow]
message ImplicitOAuthFlow {
  // The authorization URL to be used for this flow. This MUST be in the
  // form of a URL. The OAuth2 standard requires the use of TLS
  string authorization_url = 1;
  // The URL to be used for obtaining refresh tokens. This MUST be in the
  // form of a URL. The OAuth2 standard requires the use of TLS.
  string refresh_url = 2;
  // The available scopes for the OAuth2 security scheme. A map between the
  // scope name and a short description for it. The map MAY be empty.
  map<string, string> scopes = 3;
}
// --8<-- [end:ImplicitOAuthFlow]

// --8<-- [start:PasswordOAuthFlow]
message PasswordOAuthFlow {
  // The token URL to be used for this flow. This MUST be in the form of a URL.
  // The OAuth2 standard requires the use of TLS.
  string token_url = 1;
  // The URL to be used for obtaining refresh tokens. This MUST be in the
  // form of a URL. The OAuth2 standard requires the use of TLS.
  string refresh_url = 2;
  // The available scopes for the OAuth2 security scheme. A map between the
  // scope name and a short description for it. The map MAY be empty.
  map<string, string> scopes = 3;
}
// --8<-- [end:PasswordOAuthFlow]

///////////// Request Messages ///////////
// --8<-- [start:MessageSendParams]
message SendMessageRequest {
  // The message to send to the agent.
  Message request = 1
      [(google.api.field_behavior) = REQUIRED, json_name = "message"];
  // Configuration for the send request.
  SendMessageConfiguration configuration = 2;
  // Optional metadata for the request.
  google.protobuf.Struct metadata = 3;
}
// --8<-- [end:MessageSendParams]

// --8<-- [start:GetTaskRequest]
message GetTaskRequest {
  // The resource name of the task.
  // Format: tasks/{task_id}
  string name = 1 [(google.api.field_behavior) = REQUIRED];
  // The number of most recent messages from the task's history to retrieve.
  int32 history_length = 2;
}
// --8<-- [end:GetTaskRequest]

// --8<-- [start:ListTasksRequest]
message ListTasksRequest {
  // Filter tasks by context ID to get tasks from a specific conversation
  // or session.
  string context_id = 1;
  // Filter tasks by their current status state.
  TaskState status = 2;
  // Maximum number of tasks to return. Must be between 1 and 100.
  // Defaults to 50 if not specified.
  int32 page_size = 3;
  // Token for pagination. Use the next_page_token from a previous
  // ListTasksResponse.
  string page_token = 4;
  // Number of recent messages to include in each task's history.
  // Must be non-negative. Defaults to 0 if not specified.
  int32 history_length = 5;
  // Filter tasks updated after this timestamp. Only tasks with a last
  // updated time greater than or equal to this value will be returned.
  google.protobuf.Timestamp last_updated_time = 6;
  // Whether to include artifacts in the returned tasks.
  // Defaults to false to reduce payload size.
  bool include_artifacts = 7;
}
// --8<-- [end:ListTasksRequest]

// --8<-- [start:ListTasksResponse]
message ListTasksResponse {
  // Array of tasks matching the specified criteria.
  repeated Task tasks = 1;
  // Token for retrieving the next page of results.
  // Empty string if no more results.
  string next_page_token = 2;
  // Total number of tasks available (before pagination).
  int32 total_size = 3;
}
// --8<-- [end:ListTasksResponse]

// --8<-- [start:CancelTaskRequest]
message CancelTaskRequest {
  // The resource name of the task to cancel.
  // Format: tasks/{task_id}
  string name = 1;
}
// --8<-- [end:CancelTaskRequest]

// --8<-- [start:GetTaskPushNotificationConfigRequest]
message GetTaskPushNotificationConfigRequest {
  // The resource name of the config to retrieve.
  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
  string name = 1;
}
// --8<-- [end:GetTaskPushNotificationConfigRequest]

// --8<-- [start:DeleteTaskPushNotificationConfigRequest]
message DeleteTaskPushNotificationConfigRequest {
  // The resource name of the config to delete.
  // Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
  string name = 1;
}
// --8<-- [end:DeleteTaskPushNotificationConfigRequest]

// --8<-- [start:SetTaskPushNotificationConfigRequest]
message CreateTaskPushNotificationConfigRequest {
  // The parent task resource for this config.
  // Format: tasks/{task_id}
  string parent = 1 [(google.api.field_behavior) = REQUIRED];
  // The ID for the new config.
  string config_id = 2 [(google.api.field_behavior) = REQUIRED];
  // The configuration to create.
  TaskPushNotificationConfig config = 3
      [(google.api.field_behavior) = REQUIRED];
}
// --8<-- [end:SetTaskPushNotificationConfigRequest]

// --8<-- [start:TaskResubscriptionRequest]
message TaskSubscriptionRequest {
  // The resource name of the task to subscribe to.
  // Format: tasks/{task_id}
  string name = 1;
}
// --8<-- [end:TaskResubscriptionRequest]

// --8<-- [start:ListTaskPushNotificationConfigRequest]
message ListTaskPushNotificationConfigRequest {
  // The parent task resource.
  // Format: tasks/{task_id}
  string parent = 1;
  // For AIP-158 these fields are present. Usually not used/needed.
  // The maximum number of configurations to return.
  // If unspecified, all configs will be returned.
  int32 page_size = 2;

  // A page token received from a previous
  // ListTaskPushNotificationConfigRequest call.
  // Provide this to retrieve the subsequent page.
  // When paginating, all other parameters provided to
  // `ListTaskPushNotificationConfigRequest` must match the call that provided
  // the page token.
  string page_token = 3;
}
// --8<-- [end:ListTaskPushNotificationConfigRequest]

// --8<-- [start:GetAuthenticatedExtendedCardRequest]
message GetAgentCardRequest {
  // Empty. Added to fix linter violation.
}
// --8<-- [end:GetAuthenticatedExtendedCardRequest]

//////// Response Messages ///////////
// --8<-- [start:SendMessageSuccessResponse]
message SendMessageResponse {
  oneof payload {
    Task task = 1;
    Message msg = 2 [json_name = "message"];
  }
}
// --8<-- [end:SendMessageSuccessResponse]

// --8<-- [start:SendStreamingMessageSuccessResponse]
// The stream response for a message. The stream should be one of the following
// sequences:
// If the response is a message, the stream should contain one, and only one,
// message and then close
// If the response is a task lifecycle, the first response should be a Task
// object followed by zero or more TaskStatusUpdateEvents and
// TaskArtifactUpdateEvents. The stream should complete when the Task
// if in an interrupted or terminal state. A stream that ends before these
// conditions are met are
message StreamResponse {
  oneof payload {
    Task task = 1;
    Message msg = 2 [json_name = "message"];
    TaskStatusUpdateEvent status_update = 3;
    TaskArtifactUpdateEvent artifact_update = 4;
  }
}
// --8<-- [end:SendStreamingMessageSuccessResponse]

// --8<-- [start:ListTaskPushNotificationConfigSuccessResponse]
message ListTaskPushNotificationConfigResponse {
  // The list of push notification configurations.
  repeated TaskPushNotificationConfig configs = 1;
  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  string next_page_token = 2;
}
// --8<-- [end:ListTaskPushNotificationConfigSuccessResponse]

=================================================

--- START OF FILE specification/json/a2a.json ---

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "definitions": {
        "A2AError": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONParseError"
                },
                {
                    "$ref": "#/definitions/InvalidRequestError"
                },
                {
                    "$ref": "#/definitions/MethodNotFoundError"
                },
                {
                    "$ref": "#/definitions/InvalidParamsError"
                },
                {
                    "$ref": "#/definitions/InternalError"
                },
                {
                    "$ref": "#/definitions/TaskNotFoundError"
                },
                {
                    "$ref": "#/definitions/TaskNotCancelableError"
                },
                {
                    "$ref": "#/definitions/PushNotificationNotSupportedError"
                },
                {
                    "$ref": "#/definitions/UnsupportedOperationError"
                },
                {
                    "$ref": "#/definitions/ContentTypeNotSupportedError"
                },
                {
                    "$ref": "#/definitions/InvalidAgentResponseError"
                },
                {
                    "$ref": "#/definitions/AuthenticatedExtendedCardNotConfiguredError"
                }
            ],
            "description": "A discriminated union of all standard JSON-RPC and A2A-specific error types."
        },
        "A2ARequest": {
            "anyOf": [
                {
                    "$ref": "#/definitions/SendMessageRequest"
                },
                {
                    "$ref": "#/definitions/SendStreamingMessageRequest"
                },
                {
                    "$ref": "#/definitions/GetTaskRequest"
                },
                {
                    "$ref": "#/definitions/ListTasksRequest"
                },
                {
                    "$ref": "#/definitions/CancelTaskRequest"
                },
                {
                    "$ref": "#/definitions/SetTaskPushNotificationConfigRequest"
                },
                {
                    "$ref": "#/definitions/GetTaskPushNotificationConfigRequest"
                },
                {
                    "$ref": "#/definitions/TaskResubscriptionRequest"
                },
                {
                    "$ref": "#/definitions/ListTaskPushNotificationConfigRequest"
                },
                {
                    "$ref": "#/definitions/DeleteTaskPushNotificationConfigRequest"
                },
                {
                    "$ref": "#/definitions/GetAuthenticatedExtendedCardRequest"
                }
            ],
            "description": "A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification."
        },
        "APIKeySecurityScheme": {
            "description": "Defines a security scheme using an API key.",
            "properties": {
                "description": {
                    "description": "An optional description for the security scheme.",
                    "type": "string"
                },
                "in": {
                    "description": "The location of the API key.",
                    "enum": [
                        "cookie",
                        "header",
                        "query"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "The name of the header, query, or cookie parameter to be used.",
                    "type": "string"
                },
                "type": {
                    "const": "apiKey",
                    "description": "The type of the security scheme. Must be 'apiKey'.",
                    "type": "string"
                }
            },
            "required": [
                "in",
                "name",
                "type"
            ],
            "type": "object"
        },
        "AgentCapabilities": {
            "description": "Defines optional capabilities supported by an agent.",
            "properties": {
                "extensions": {
                    "description": "A list of protocol extensions supported by the agent.",
                    "items": {
                        "$ref": "#/definitions/AgentExtension"
                    },
                    "type": "array"
                },
                "pushNotifications": {
                    "description": "Indicates if the agent supports sending push notifications for asynchronous task updates.",
                    "type": "boolean"
                },
                "stateTransitionHistory": {
                    "description": "Indicates if the agent provides a history of state transitions for a task.",
                    "type": "boolean"
                },
                "streaming": {
                    "description": "Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "AgentCard": {
            "description": "The AgentCard is a self-describing manifest for an agent. It provides essential\nmetadata including the agent's identity, capabilities, skills, supported\ncommunication methods, and security requirements.",
            "properties": {
                "additionalInterfaces": {
                    "description": "A list of additional supported interfaces (transport and URL combinations).\nThis allows agents to expose multiple transports, potentially at different URLs.\n\nBest practices:\n- SHOULD include all supported transports for completeness\n- SHOULD include an entry matching the main 'url' and 'preferredTransport'\n- MAY reuse URLs if multiple transports are available at the same endpoint\n- MUST accurately declare the transport available at each URL\n\nClients can select any interface from this list based on their transport capabilities\nand preferences. This enables transport negotiation and fallback scenarios.",
                    "items": {
                        "$ref": "#/definitions/AgentInterface"
                    },
                    "type": "array"
                },
                "capabilities": {
                    "$ref": "#/definitions/AgentCapabilities",
                    "description": "A declaration of optional capabilities supported by the agent."
                },
                "defaultInputModes": {
                    "description": "Default set of supported input MIME types for all skills, which can be\noverridden on a per-skill basis.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "defaultOutputModes": {
                    "description": "Default set of supported output MIME types for all skills, which can be\noverridden on a per-skill basis.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "description": {
                    "description": "A human-readable description of the agent, assisting users and other agents\nin understanding its purpose.",
                    "examples": [
                        "Agent that helps users with recipes and cooking."
                    ],
                    "type": "string"
                },
                "documentationUrl": {
                    "description": "An optional URL to the agent's documentation.",
                    "type": "string"
                },
                "iconUrl": {
                    "description": "An optional URL to an icon for the agent.",
                    "type": "string"
                },
                "name": {
                    "description": "A human-readable name for the agent.",
                    "examples": [
                        "Recipe Agent"
                    ],
                    "type": "string"
                },
                "preferredTransport": {
                    "default": "JSONRPC",
                    "description": "The transport protocol for the preferred endpoint (the main 'url' field).\nIf not specified, defaults to 'JSONRPC'.\n\nIMPORTANT: The transport specified here MUST be available at the main 'url'.\nThis creates a binding between the main URL and its supported transport protocol.\nClients should prefer this transport and URL combination when both are supported.",
                    "examples": [
                        "JSONRPC",
                        "GRPC",
                        "HTTP+JSON"
                    ],
                    "type": "string"
                },
                "protocolVersion": {
                    "default": "0.3.0",
                    "description": "The version of the A2A protocol this agent supports.",
                    "type": "string"
                },
                "provider": {
                    "$ref": "#/definitions/AgentProvider",
                    "description": "Information about the agent's service provider."
                },
                "security": {
                    "description": "A list of security requirement objects that apply to all agent interactions. Each object\nlists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.\nThis list can be seen as an OR of ANDs. Each object in the list describes one possible\nset of security requirements that must be present on a request. This allows specifying,\nfor example, \"callers must either use OAuth OR an API Key AND mTLS.\"",
                    "examples": [
                        [
                            {
                                "oauth": [
                                    "read"
                                ]
                            },
                            {
                                "api-key": [],
                                "mtls": []
                            }
                        ]
                    ],
                    "items": {
                        "additionalProperties": {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "securitySchemes": {
                    "additionalProperties": {
                        "$ref": "#/definitions/SecurityScheme"
                    },
                    "description": "A declaration of the security schemes available to authorize requests. The key is the\nscheme name. Follows the OpenAPI 3.0 Security Scheme Object.",
                    "type": "object"
                },
                "signatures": {
                    "description": "JSON Web Signatures computed for this AgentCard.",
                    "items": {
                        "$ref": "#/definitions/AgentCardSignature"
                    },
                    "type": "array"
                },
                "skills": {
                    "description": "The set of skills, or distinct capabilities, that the agent can perform.",
                    "items": {
                        "$ref": "#/definitions/AgentSkill"
                    },
                    "type": "array"
                },
                "supportsAuthenticatedExtendedCard": {
                    "description": "If true, the agent can provide an extended agent card with additional details\nto authenticated users. Defaults to false.",
                    "type": "boolean"
                },
                "url": {
                    "description": "The preferred endpoint URL for interacting with the agent.\nThis URL MUST support the transport specified by 'preferredTransport'.",
                    "examples": [
                        "https://api.example.com/a2a/v1"
                    ],
                    "type": "string"
                },
                "version": {
                    "description": "The agent's own version number. The format is defined by the provider.",
                    "examples": [
                        "1.0.0"
                    ],
                    "type": "string"
                }
            },
            "required": [
                "capabilities",
                "defaultInputModes",
                "defaultOutputModes",
                "description",
                "name",
                "protocolVersion",
                "skills",
                "url",
                "version"
            ],
            "type": "object"
        },
        "AgentCardSignature": {
            "description": "AgentCardSignature represents a JWS signature of an AgentCard.\nThis follows the JSON format of an RFC 7515 JSON Web Signature (JWS).",
            "properties": {
                "header": {
                    "additionalProperties": {},
                    "description": "The unprotected JWS header values.",
                    "type": "object"
                },
                "protected": {
                    "description": "The protected JWS header for the signature. This is a Base64url-encoded\nJSON object, as per RFC 7515.",
                    "type": "string"
                },
                "signature": {
                    "description": "The computed signature, Base64url-encoded.",
                    "type": "string"
                }
            },
            "required": [
                "protected",
                "signature"
            ],
            "type": "object"
        },
        "AgentExtension": {
            "description": "A declaration of a protocol extension supported by an Agent.",
            "examples": [
                {
                    "description": "Google OAuth 2.0 authentication",
                    "required": false,
                    "uri": "https://developers.google.com/identity/protocols/oauth2"
                }
            ],
            "properties": {
                "description": {
                    "description": "A human-readable description of how this agent uses the extension.",
                    "type": "string"
                },
                "params": {
                    "additionalProperties": {},
                    "description": "Optional, extension-specific configuration parameters.",
                    "type": "object"
                },
                "required": {
                    "description": "If true, the client must understand and comply with the extension's requirements\nto interact with the agent.",
                    "type": "boolean"
                },
                "uri": {
                    "description": "The unique URI identifying the extension.",
                    "type": "string"
                }
            },
            "required": [
                "uri"
            ],
            "type": "object"
        },
        "AgentInterface": {
            "description": "Declares a combination of a target URL and a transport protocol for interacting with the agent.\nThis allows agents to expose the same functionality over multiple transport mechanisms.",
            "properties": {
                "transport": {
                    "description": "The transport protocol supported at this URL.",
                    "examples": [
                        "JSONRPC",
                        "GRPC",
                        "HTTP+JSON"
                    ],
                    "type": "string"
                },
                "url": {
                    "description": "The URL where this interface is available. Must be a valid absolute HTTPS URL in production.",
                    "examples": [
                        "https://api.example.com/a2a/v1",
                        "https://grpc.example.com/a2a",
                        "https://rest.example.com/v1"
                    ],
                    "type": "string"
                }
            },
            "required": [
                "transport",
                "url"
            ],
            "type": "object"
        },
        "AgentProvider": {
            "description": "Represents the service provider of an agent.",
            "examples": [
                {
                    "organization": "Google",
                    "url": "https://ai.google.dev"
                }
            ],
            "properties": {
                "organization": {
                    "description": "The name of the agent provider's organization.",
                    "type": "string"
                },
                "url": {
                    "description": "A URL for the agent provider's website or relevant documentation.",
                    "type": "string"
                }
            },
            "required": [
                "organization",
                "url"
            ],
            "type": "object"
        },
        "AgentSkill": {
            "description": "Represents a distinct capability or function that an agent can perform.",
            "properties": {
                "description": {
                    "description": "A detailed description of the skill, intended to help clients or users\nunderstand its purpose and functionality.",
                    "type": "string"
                },
                "examples": {
                    "description": "Example prompts or scenarios that this skill can handle. Provides a hint to\nthe client on how to use the skill.",
                    "examples": [
                        [
                            "I need a recipe for bread"
                        ]
                    ],
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "id": {
                    "description": "A unique identifier for the agent's skill.",
                    "type": "string"
                },
                "inputModes": {
                    "description": "The set of supported input MIME types for this skill, overriding the agent's defaults.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "name": {
                    "description": "A human-readable name for the skill.",
                    "type": "string"
                },
                "outputModes": {
                    "description": "The set of supported output MIME types for this skill, overriding the agent's defaults.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "security": {
                    "description": "Security schemes necessary for the agent to leverage this skill.\nAs in the overall AgentCard.security, this list represents a logical OR of security\nrequirement objects. Each object is a set of security schemes that must be used together\n(a logical AND).",
                    "examples": [
                        [
                            {
                                "google": [
                                    "oidc"
                                ]
                            }
                        ]
                    ],
                    "items": {
                        "additionalProperties": {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "tags": {
                    "description": "A set of keywords describing the skill's capabilities.",
                    "examples": [
                        [
                            "cooking",
                            "customer support",
                            "billing"
                        ]
                    ],
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "required": [
                "description",
                "id",
                "name",
                "tags"
            ],
            "type": "object"
        },
        "Artifact": {
            "description": "Represents a file, data structure, or other resource generated by an agent during a task.",
            "properties": {
                "artifactId": {
                    "description": "A unique identifier (e.g. UUID) for the artifact within the scope of the task.",
                    "type": "string"
                },
                "description": {
                    "description": "An optional, human-readable description of the artifact.",
                    "type": "string"
                },
                "extensions": {
                    "description": "The URIs of extensions that are relevant to this artifact.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata for extensions. The key is an extension-specific identifier.",
                    "type": "object"
                },
                "name": {
                    "description": "An optional, human-readable name for the artifact.",
                    "type": "string"
                },
                "parts": {
                    "description": "An array of content parts that make up the artifact.",
                    "items": {
                        "$ref": "#/definitions/Part"
                    },
                    "type": "array"
                }
            },
            "required": [
                "artifactId",
                "parts"
            ],
            "type": "object"
        },
        "AuthenticatedExtendedCardNotConfiguredError": {
            "description": "An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured",
            "properties": {
                "code": {
                    "const": -32007,
                    "description": "The error code for when an authenticated extended card is not configured.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Authenticated Extended Card is not configured",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "AuthorizationCodeOAuthFlow": {
            "description": "Defines configuration details for the OAuth 2.0 Authorization Code flow.",
            "properties": {
                "authorizationUrl": {
                    "description": "The authorization URL to be used for this flow.\nThis MUST be a URL and use TLS.",
                    "type": "string"
                },
                "refreshUrl": {
                    "description": "The URL to be used for obtaining refresh tokens.\nThis MUST be a URL and use TLS.",
                    "type": "string"
                },
                "scopes": {
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.",
                    "type": "object"
                },
                "tokenUrl": {
                    "description": "The token URL to be used for this flow.\nThis MUST be a URL and use TLS.",
                    "type": "string"
                }
            },
            "required": [
                "authorizationUrl",
                "scopes",
                "tokenUrl"
            ],
            "type": "object"
        },
        "CancelTaskRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/cancel` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/cancel",
                    "description": "The method name. Must be 'tasks/cancel'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/TaskIdParams",
                    "description": "The parameters identifying the task to cancel."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "CancelTaskResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/CancelTaskSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `tasks/cancel` method."
        },
        "CancelTaskSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `tasks/cancel` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/Task",
                    "description": "The result, containing the final state of the canceled Task object."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "ClientCredentialsOAuthFlow": {
            "description": "Defines configuration details for the OAuth 2.0 Client Credentials flow.",
            "properties": {
                "refreshUrl": {
                    "description": "The URL to be used for obtaining refresh tokens. This MUST be a URL.",
                    "type": "string"
                },
                "scopes": {
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.",
                    "type": "object"
                },
                "tokenUrl": {
                    "description": "The token URL to be used for this flow. This MUST be a URL.",
                    "type": "string"
                }
            },
            "required": [
                "scopes",
                "tokenUrl"
            ],
            "type": "object"
        },
        "ContentTypeNotSupportedError": {
            "description": "An A2A-specific error indicating an incompatibility between the requested\ncontent types and the agent's capabilities.",
            "properties": {
                "code": {
                    "const": -32005,
                    "description": "The error code for an unsupported content type.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Incompatible content types",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "DataPart": {
            "description": "Represents a structured data segment (e.g., JSON) within a message or artifact.",
            "properties": {
                "data": {
                    "additionalProperties": {},
                    "description": "The structured data content.",
                    "type": "object"
                },
                "kind": {
                    "const": "data",
                    "description": "The type of this part, used as a discriminator. Always 'data'.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with this part.",
                    "type": "object"
                }
            },
            "required": [
                "data",
                "kind"
            ],
            "type": "object"
        },
        "DeleteTaskPushNotificationConfigParams": {
            "description": "Defines parameters for deleting a specific push notification configuration for a task.",
            "properties": {
                "id": {
                    "description": "The unique identifier (e.g. UUID) of the task.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with the request.",
                    "type": "object"
                },
                "pushNotificationConfigId": {
                    "description": "The ID of the push notification configuration to delete.",
                    "type": "string"
                }
            },
            "required": [
                "id",
                "pushNotificationConfigId"
            ],
            "type": "object"
        },
        "DeleteTaskPushNotificationConfigRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/pushNotificationConfig/delete",
                    "description": "The method name. Must be 'tasks/pushNotificationConfig/delete'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/DeleteTaskPushNotificationConfigParams",
                    "description": "The parameters identifying the push notification configuration to delete."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "DeleteTaskPushNotificationConfigResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/DeleteTaskPushNotificationConfigSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method."
        },
        "DeleteTaskPushNotificationConfigSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "description": "The result is null on successful deletion.",
                    "type": "null"
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "FileBase": {
            "description": "Defines base properties for a file.",
            "properties": {
                "mimeType": {
                    "description": "The MIME type of the file (e.g., \"application/pdf\").",
                    "type": "string"
                },
                "name": {
                    "description": "An optional name for the file (e.g., \"document.pdf\").",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "FilePart": {
            "description": "Represents a file segment within a message or artifact. The file content can be\nprovided either directly as bytes or as a URI.",
            "properties": {
                "file": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/FileWithBytes"
                        },
                        {
                            "$ref": "#/definitions/FileWithUri"
                        }
                    ],
                    "description": "The file content, represented as either a URI or as base64-encoded bytes."
                },
                "kind": {
                    "const": "file",
                    "description": "The type of this part, used as a discriminator. Always 'file'.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with this part.",
                    "type": "object"
                }
            },
            "required": [
                "file",
                "kind"
            ],
            "type": "object"
        },
        "FileWithBytes": {
            "description": "Represents a file with its content provided directly as a base64-encoded string.",
            "properties": {
                "bytes": {
                    "description": "The base64-encoded content of the file.",
                    "type": "string"
                },
                "mimeType": {
                    "description": "The MIME type of the file (e.g., \"application/pdf\").",
                    "type": "string"
                },
                "name": {
                    "description": "An optional name for the file (e.g., \"document.pdf\").",
                    "type": "string"
                }
            },
            "required": [
                "bytes"
            ],
            "type": "object"
        },
        "FileWithUri": {
            "description": "Represents a file with its content located at a specific URI.",
            "properties": {
                "mimeType": {
                    "description": "The MIME type of the file (e.g., \"application/pdf\").",
                    "type": "string"
                },
                "name": {
                    "description": "An optional name for the file (e.g., \"document.pdf\").",
                    "type": "string"
                },
                "uri": {
                    "description": "A URL pointing to the file's content.",
                    "type": "string"
                }
            },
            "required": [
                "uri"
            ],
            "type": "object"
        },
        "GetAuthenticatedExtendedCardRequest": {
            "description": "Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "agent/getAuthenticatedExtendedCard",
                    "description": "The method name. Must be 'agent/getAuthenticatedExtendedCard'.",
                    "type": "string"
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method"
            ],
            "type": "object"
        },
        "GetAuthenticatedExtendedCardResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/GetAuthenticatedExtendedCardSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method."
        },
        "GetAuthenticatedExtendedCardSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/AgentCard",
                    "description": "The result is an Agent Card object."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "GetTaskPushNotificationConfigParams": {
            "description": "Defines parameters for fetching a specific push notification configuration for a task.",
            "properties": {
                "id": {
                    "description": "The unique identifier (e.g. UUID) of the task.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with the request.",
                    "type": "object"
                },
                "pushNotificationConfigId": {
                    "description": "The ID of the push notification configuration to retrieve.",
                    "type": "string"
                }
            },
            "required": [
                "id"
            ],
            "type": "object"
        },
        "GetTaskPushNotificationConfigRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/pushNotificationConfig/get",
                    "description": "The method name. Must be 'tasks/pushNotificationConfig/get'.",
                    "type": "string"
                },
                "params": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/TaskIdParams"
                        },
                        {
                            "$ref": "#/definitions/GetTaskPushNotificationConfigParams"
                        }
                    ],
                    "description": "The parameters for getting a push notification configuration."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "GetTaskPushNotificationConfigResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/GetTaskPushNotificationConfigSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method."
        },
        "GetTaskPushNotificationConfigSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/TaskPushNotificationConfig",
                    "description": "The result, containing the requested push notification configuration."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "GetTaskRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/get` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/get",
                    "description": "The method name. Must be 'tasks/get'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/TaskQueryParams",
                    "description": "The parameters for querying a task."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "GetTaskResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/GetTaskSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `tasks/get` method."
        },
        "GetTaskSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `tasks/get` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/Task",
                    "description": "The result, containing the requested Task object."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "HTTPAuthSecurityScheme": {
            "description": "Defines a security scheme using HTTP authentication.",
            "properties": {
                "bearerFormat": {
                    "description": "A hint to the client to identify how the bearer token is formatted (e.g., \"JWT\").\nThis is primarily for documentation purposes.",
                    "type": "string"
                },
                "description": {
                    "description": "An optional description for the security scheme.",
                    "type": "string"
                },
                "scheme": {
                    "description": "The name of the HTTP Authentication scheme to be used in the Authorization header,\nas defined in RFC7235 (e.g., \"Bearer\").\nThis value should be registered in the IANA Authentication Scheme registry.",
                    "type": "string"
                },
                "type": {
                    "const": "http",
                    "description": "The type of the security scheme. Must be 'http'.",
                    "type": "string"
                }
            },
            "required": [
                "scheme",
                "type"
            ],
            "type": "object"
        },
        "ImplicitOAuthFlow": {
            "description": "Defines configuration details for the OAuth 2.0 Implicit flow.",
            "properties": {
                "authorizationUrl": {
                    "description": "The authorization URL to be used for this flow. This MUST be a URL.",
                    "type": "string"
                },
                "refreshUrl": {
                    "description": "The URL to be used for obtaining refresh tokens. This MUST be a URL.",
                    "type": "string"
                },
                "scopes": {
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.",
                    "type": "object"
                }
            },
            "required": [
                "authorizationUrl",
                "scopes"
            ],
            "type": "object"
        },
        "InternalError": {
            "description": "An error indicating an internal error on the server.",
            "properties": {
                "code": {
                    "const": -32603,
                    "description": "The error code for an internal server error.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Internal error",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "InvalidAgentResponseError": {
            "description": "An A2A-specific error indicating that the agent returned a response that\ndoes not conform to the specification for the current method.",
            "properties": {
                "code": {
                    "const": -32006,
                    "description": "The error code for an invalid agent response.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Invalid agent response",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "InvalidParamsError": {
            "description": "An error indicating that the method parameters are invalid.",
            "properties": {
                "code": {
                    "const": -32602,
                    "description": "The error code for an invalid parameters error.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Invalid parameters",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "InvalidRequestError": {
            "description": "An error indicating that the JSON sent is not a valid Request object.",
            "properties": {
                "code": {
                    "const": -32600,
                    "description": "The error code for an invalid request.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Request payload validation error",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "JSONParseError": {
            "description": "An error indicating that the server received invalid JSON.",
            "properties": {
                "code": {
                    "const": -32700,
                    "description": "The error code for a JSON parse error.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Invalid JSON payload",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "JSONRPCError": {
            "description": "Represents a JSON-RPC 2.0 Error object, included in an error response.",
            "properties": {
                "code": {
                    "description": "A number that indicates the error type that occurred.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "description": "A string providing a short description of the error.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "JSONRPCErrorResponse": {
            "description": "Represents a JSON-RPC 2.0 Error Response object.",
            "properties": {
                "error": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/JSONRPCError"
                        },
                        {
                            "$ref": "#/definitions/JSONParseError"
                        },
                        {
                            "$ref": "#/definitions/InvalidRequestError"
                        },
                        {
                            "$ref": "#/definitions/MethodNotFoundError"
                        },
                        {
                            "$ref": "#/definitions/InvalidParamsError"
                        },
                        {
                            "$ref": "#/definitions/InternalError"
                        },
                        {
                            "$ref": "#/definitions/TaskNotFoundError"
                        },
                        {
                            "$ref": "#/definitions/TaskNotCancelableError"
                        },
                        {
                            "$ref": "#/definitions/PushNotificationNotSupportedError"
                        },
                        {
                            "$ref": "#/definitions/UnsupportedOperationError"
                        },
                        {
                            "$ref": "#/definitions/ContentTypeNotSupportedError"
                        },
                        {
                            "$ref": "#/definitions/InvalidAgentResponseError"
                        },
                        {
                            "$ref": "#/definitions/AuthenticatedExtendedCardNotConfiguredError"
                        }
                    ],
                    "description": "An object describing the error that occurred."
                },
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                }
            },
            "required": [
                "error",
                "id",
                "jsonrpc"
            ],
            "type": "object"
        },
        "JSONRPCMessage": {
            "description": "Defines the base structure for any JSON-RPC 2.0 request, response, or notification.",
            "properties": {
                "id": {
                    "description": "A unique identifier established by the client. It must be a String, a Number, or null.\nThe server must reply with the same value in the response. This property is omitted for notifications.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                }
            },
            "required": [
                "jsonrpc"
            ],
            "type": "object"
        },
        "JSONRPCRequest": {
            "description": "Represents a JSON-RPC 2.0 Request object.",
            "properties": {
                "id": {
                    "description": "A unique identifier established by the client. It must be a String, a Number, or null.\nThe server must reply with the same value in the response. This property is omitted for notifications.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "description": "A string containing the name of the method to be invoked.",
                    "type": "string"
                },
                "params": {
                    "additionalProperties": {},
                    "description": "A structured value holding the parameter values to be used during the method invocation.",
                    "type": "object"
                }
            },
            "required": [
                "jsonrpc",
                "method"
            ],
            "type": "object"
        },
        "JSONRPCResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/SendMessageSuccessResponse"
                },
                {
                    "$ref": "#/definitions/SendStreamingMessageSuccessResponse"
                },
                {
                    "$ref": "#/definitions/GetTaskSuccessResponse"
                },
                {
                    "$ref": "#/definitions/CancelTaskSuccessResponse"
                },
                {
                    "$ref": "#/definitions/ListTasksSuccessResponse"
                },
                {
                    "$ref": "#/definitions/SetTaskPushNotificationConfigSuccessResponse"
                },
                {
                    "$ref": "#/definitions/GetTaskPushNotificationConfigSuccessResponse"
                },
                {
                    "$ref": "#/definitions/ListTaskPushNotificationConfigSuccessResponse"
                },
                {
                    "$ref": "#/definitions/DeleteTaskPushNotificationConfigSuccessResponse"
                },
                {
                    "$ref": "#/definitions/GetAuthenticatedExtendedCardSuccessResponse"
                }
            ],
            "description": "A discriminated union representing all possible JSON-RPC 2.0 responses\nfor the A2A specification methods."
        },
        "JSONRPCSuccessResponse": {
            "description": "Represents a successful JSON-RPC 2.0 Response object.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "description": "The value of this member is determined by the method invoked on the Server."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "ListTaskPushNotificationConfigParams": {
            "description": "Defines parameters for listing all push notification configurations associated with a task.",
            "properties": {
                "id": {
                    "description": "The unique identifier (e.g. UUID) of the task.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with the request.",
                    "type": "object"
                }
            },
            "required": [
                "id"
            ],
            "type": "object"
        },
        "ListTaskPushNotificationConfigRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/pushNotificationConfig/list",
                    "description": "The method name. Must be 'tasks/pushNotificationConfig/list'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/ListTaskPushNotificationConfigParams",
                    "description": "The parameters identifying the task whose configurations are to be listed."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "ListTaskPushNotificationConfigResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/ListTaskPushNotificationConfigSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method."
        },
        "ListTaskPushNotificationConfigSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "description": "The result, containing an array of all push notification configurations for the task.",
                    "items": {
                        "$ref": "#/definitions/TaskPushNotificationConfig"
                    },
                    "type": "array"
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "ListTasksParams": {
            "description": "Parameters for listing tasks with optional filtering criteria.",
            "properties": {
                "contextId": {
                    "description": "Filter tasks by context ID to get tasks from a specific conversation or session.",
                    "type": "string"
                },
                "historyLength": {
                    "description": "Number of recent messages to include in each task's history. Must be non-negative. Defaults to 0 if not specified.",
                    "type": "integer"
                },
                "includeArtifacts": {
                    "description": "Whether to include artifacts in the returned tasks. Defaults to false to reduce payload size.",
                    "type": "boolean"
                },
                "lastUpdatedAfter": {
                    "description": "Filter tasks updated after this timestamp (milliseconds since epoch). Only tasks with a last updated time greater than or equal to this value will be returned.",
                    "type": "integer"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Request-specific metadata.",
                    "type": "object"
                },
                "pageSize": {
                    "description": "Maximum number of tasks to return. Must be between 1 and 100. Defaults to 50 if not specified.",
                    "type": "integer"
                },
                "pageToken": {
                    "description": "Token for pagination. Use the nextPageToken from a previous ListTasksResult response.",
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/TaskState",
                    "description": "Filter tasks by their current status state."
                }
            },
            "type": "object"
        },
        "ListTasksRequest": {
            "description": "JSON-RPC request model for the 'tasks/list' method.",
            "properties": {
                "id": {
                    "description": "A unique identifier established by the client. It must be a String, a Number, or null.\nThe server must reply with the same value in the response. This property is omitted for notifications.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/list",
                    "description": "A String containing the name of the method to be invoked.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/ListTasksParams",
                    "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method"
            ],
            "type": "object"
        },
        "ListTasksResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/ListTasksSuccessResponse"
                }
            ],
            "description": "JSON-RPC response for the 'tasks/list' method."
        },
        "ListTasksResult": {
            "description": "Result object for tasks/list method containing an array of tasks and pagination information.",
            "properties": {
                "nextPageToken": {
                    "description": "Token for retrieving the next page. Empty string if no more results.",
                    "type": "string"
                },
                "pageSize": {
                    "description": "Maximum number of tasks returned in this response.",
                    "type": "integer"
                },
                "tasks": {
                    "description": "Array of tasks matching the specified criteria.",
                    "items": {
                        "$ref": "#/definitions/Task"
                    },
                    "type": "array"
                },
                "totalSize": {
                    "description": "Total number of tasks available (before pagination).",
                    "type": "integer"
                }
            },
            "required": [
                "nextPageToken",
                "pageSize",
                "tasks",
                "totalSize"
            ],
            "type": "object"
        },
        "ListTasksSuccessResponse": {
            "description": "JSON-RPC success response model for the 'tasks/list' method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/ListTasksResult",
                    "description": "The result object on success."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "Message": {
            "description": "Represents a single message in the conversation between a user and an agent.",
            "properties": {
                "contextId": {
                    "description": "The context ID for this message, used to group related interactions.",
                    "type": "string"
                },
                "extensions": {
                    "description": "The URIs of extensions that are relevant to this message.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "kind": {
                    "const": "message",
                    "description": "The type of this object, used as a discriminator. Always 'message' for a Message.",
                    "type": "string"
                },
                "messageId": {
                    "description": "A unique identifier for the message, typically a UUID, generated by the sender.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata for extensions. The key is an extension-specific identifier.",
                    "type": "object"
                },
                "parts": {
                    "description": "An array of content parts that form the message body. A message can be\ncomposed of multiple parts of different types (e.g., text and files).",
                    "items": {
                        "$ref": "#/definitions/Part"
                    },
                    "type": "array"
                },
                "referenceTaskIds": {
                    "description": "A list of other task IDs that this message references for additional context.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "role": {
                    "description": "Identifies the sender of the message. `user` for the client, `agent` for the service.",
                    "enum": [
                        "agent",
                        "user"
                    ],
                    "type": "string"
                },
                "taskId": {
                    "description": "The ID of the task this message is part of. Can be omitted for the first message of a new task.",
                    "type": "string"
                }
            },
            "required": [
                "kind",
                "messageId",
                "parts",
                "role"
            ],
            "type": "object"
        },
        "MessageSendConfiguration": {
            "description": "Defines configuration options for a `message/send` or `message/stream` request.",
            "properties": {
                "acceptedOutputModes": {
                    "description": "A list of output MIME types the client is prepared to accept in the response.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "blocking": {
                    "description": "If true, the client will wait for the task to complete. The server may reject this if the task is long-running.",
                    "type": "boolean"
                },
                "historyLength": {
                    "description": "The number of most recent messages from the task's history to retrieve in the response.",
                    "type": "integer"
                },
                "pushNotificationConfig": {
                    "$ref": "#/definitions/PushNotificationConfig",
                    "description": "Configuration for the agent to send push notifications for updates after the initial response."
                }
            },
            "type": "object"
        },
        "MessageSendParams": {
            "description": "Defines the parameters for a request to send a message to an agent. This can be used\nto create a new task, continue an existing one, or restart a task.",
            "properties": {
                "configuration": {
                    "$ref": "#/definitions/MessageSendConfiguration",
                    "description": "Optional configuration for the send request."
                },
                "message": {
                    "$ref": "#/definitions/Message",
                    "description": "The message object being sent to the agent."
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata for extensions.",
                    "type": "object"
                }
            },
            "required": [
                "message"
            ],
            "type": "object"
        },
        "MethodNotFoundError": {
            "description": "An error indicating that the requested method does not exist or is not available.",
            "properties": {
                "code": {
                    "const": -32601,
                    "description": "The error code for a method not found error.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Method not found",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "MutualTLSSecurityScheme": {
            "description": "Defines a security scheme using mTLS authentication.",
            "properties": {
                "description": {
                    "description": "An optional description for the security scheme.",
                    "type": "string"
                },
                "type": {
                    "const": "mutualTLS",
                    "description": "The type of the security scheme. Must be 'mutualTLS'.",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "OAuth2SecurityScheme": {
            "description": "Defines a security scheme using OAuth 2.0.",
            "properties": {
                "description": {
                    "description": "An optional description for the security scheme.",
                    "type": "string"
                },
                "flows": {
                    "$ref": "#/definitions/OAuthFlows",
                    "description": "An object containing configuration information for the supported OAuth 2.0 flows."
                },
                "oauth2MetadataUrl": {
                    "description": "URL to the oauth2 authorization server metadata\n[RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.",
                    "type": "string"
                },
                "type": {
                    "const": "oauth2",
                    "description": "The type of the security scheme. Must be 'oauth2'.",
                    "type": "string"
                }
            },
            "required": [
                "flows",
                "type"
            ],
            "type": "object"
        },
        "OAuthFlows": {
            "description": "Defines the configuration for the supported OAuth 2.0 flows.",
            "properties": {
                "authorizationCode": {
                    "$ref": "#/definitions/AuthorizationCodeOAuthFlow",
                    "description": "Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0."
                },
                "clientCredentials": {
                    "$ref": "#/definitions/ClientCredentialsOAuthFlow",
                    "description": "Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0."
                },
                "implicit": {
                    "$ref": "#/definitions/ImplicitOAuthFlow",
                    "description": "Configuration for the OAuth Implicit flow."
                },
                "password": {
                    "$ref": "#/definitions/PasswordOAuthFlow",
                    "description": "Configuration for the OAuth Resource Owner Password flow."
                }
            },
            "type": "object"
        },
        "OpenIdConnectSecurityScheme": {
            "description": "Defines a security scheme using OpenID Connect.",
            "properties": {
                "description": {
                    "description": "An optional description for the security scheme.",
                    "type": "string"
                },
                "openIdConnectUrl": {
                    "description": "The OpenID Connect Discovery URL for the OIDC provider's metadata.",
                    "type": "string"
                },
                "type": {
                    "const": "openIdConnect",
                    "description": "The type of the security scheme. Must be 'openIdConnect'.",
                    "type": "string"
                }
            },
            "required": [
                "openIdConnectUrl",
                "type"
            ],
            "type": "object"
        },
        "Part": {
            "anyOf": [
                {
                    "$ref": "#/definitions/TextPart"
                },
                {
                    "$ref": "#/definitions/FilePart"
                },
                {
                    "$ref": "#/definitions/DataPart"
                }
            ],
            "description": "A discriminated union representing a part of a message or artifact, which can\nbe text, a file, or structured data."
        },
        "PartBase": {
            "description": "Defines base properties common to all message or artifact parts.",
            "properties": {
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with this part.",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "PasswordOAuthFlow": {
            "description": "Defines configuration details for the OAuth 2.0 Resource Owner Password flow.",
            "properties": {
                "refreshUrl": {
                    "description": "The URL to be used for obtaining refresh tokens. This MUST be a URL.",
                    "type": "string"
                },
                "scopes": {
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.",
                    "type": "object"
                },
                "tokenUrl": {
                    "description": "The token URL to be used for this flow. This MUST be a URL.",
                    "type": "string"
                }
            },
            "required": [
                "scopes",
                "tokenUrl"
            ],
            "type": "object"
        },
        "PushNotificationAuthenticationInfo": {
            "description": "Defines authentication details for a push notification endpoint.",
            "properties": {
                "credentials": {
                    "description": "Optional credentials required by the push notification endpoint.",
                    "type": "string"
                },
                "schemes": {
                    "description": "A list of supported authentication schemes (e.g., 'Basic', 'Bearer').",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "required": [
                "schemes"
            ],
            "type": "object"
        },
        "PushNotificationConfig": {
            "description": "Defines the configuration for setting up push notifications for task updates.",
            "properties": {
                "authentication": {
                    "$ref": "#/definitions/PushNotificationAuthenticationInfo",
                    "description": "Optional authentication details for the agent to use when calling the notification URL."
                },
                "id": {
                    "description": "A unique identifier (e.g. UUID) for the push notification configuration, set by the client\nto support multiple notification callbacks.",
                    "type": "string"
                },
                "token": {
                    "description": "A unique token for this task or session to validate incoming push notifications.",
                    "type": "string"
                },
                "url": {
                    "description": "The callback URL where the agent should send push notifications.",
                    "type": "string"
                }
            },
            "required": [
                "url"
            ],
            "type": "object"
        },
        "PushNotificationNotSupportedError": {
            "description": "An A2A-specific error indicating that the agent does not support push notifications.",
            "properties": {
                "code": {
                    "const": -32003,
                    "description": "The error code for when push notifications are not supported.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Push Notification is not supported",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "SecurityScheme": {
            "anyOf": [
                {
                    "$ref": "#/definitions/APIKeySecurityScheme"
                },
                {
                    "$ref": "#/definitions/HTTPAuthSecurityScheme"
                },
                {
                    "$ref": "#/definitions/OAuth2SecurityScheme"
                },
                {
                    "$ref": "#/definitions/OpenIdConnectSecurityScheme"
                },
                {
                    "$ref": "#/definitions/MutualTLSSecurityScheme"
                }
            ],
            "description": "Defines a security scheme that can be used to secure an agent's endpoints.\nThis is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object."
        },
        "SecuritySchemeBase": {
            "description": "Defines base properties shared by all security scheme objects.",
            "properties": {
                "description": {
                    "description": "An optional description for the security scheme.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "SendMessageRequest": {
            "description": "Represents a JSON-RPC request for the `message/send` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "message/send",
                    "description": "The method name. Must be 'message/send'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/MessageSendParams",
                    "description": "The parameters for sending a message."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "SendMessageResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/SendMessageSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `message/send` method."
        },
        "SendMessageSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `message/send` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Task"
                        },
                        {
                            "$ref": "#/definitions/Message"
                        }
                    ],
                    "description": "The result, which can be a direct reply Message or the initial Task object."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "SendStreamingMessageRequest": {
            "description": "Represents a JSON-RPC request for the `message/stream` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "message/stream",
                    "description": "The method name. Must be 'message/stream'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/MessageSendParams",
                    "description": "The parameters for sending a message."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "SendStreamingMessageResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/SendStreamingMessageSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `message/stream` method."
        },
        "SendStreamingMessageSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `message/stream` method.\nThe server may send multiple response objects for a single request.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Task"
                        },
                        {
                            "$ref": "#/definitions/Message"
                        },
                        {
                            "$ref": "#/definitions/TaskStatusUpdateEvent"
                        },
                        {
                            "$ref": "#/definitions/TaskArtifactUpdateEvent"
                        }
                    ],
                    "description": "The result, which can be a Message, Task, or a streaming update event."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "SetTaskPushNotificationConfigRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/pushNotificationConfig/set",
                    "description": "The method name. Must be 'tasks/pushNotificationConfig/set'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/TaskPushNotificationConfig",
                    "description": "The parameters for setting the push notification configuration."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "SetTaskPushNotificationConfigResponse": {
            "anyOf": [
                {
                    "$ref": "#/definitions/JSONRPCErrorResponse"
                },
                {
                    "$ref": "#/definitions/SetTaskPushNotificationConfigSuccessResponse"
                }
            ],
            "description": "Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method."
        },
        "SetTaskPushNotificationConfigSuccessResponse": {
            "description": "Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.",
            "properties": {
                "id": {
                    "description": "The identifier established by the client.",
                    "type": [
                        "string",
                        "integer",
                        "null"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/TaskPushNotificationConfig",
                    "description": "The result, containing the configured push notification settings."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "result"
            ],
            "type": "object"
        },
        "Task": {
            "description": "Represents a single, stateful operation or conversation between a client and an agent.",
            "properties": {
                "artifacts": {
                    "description": "A collection of artifacts generated by the agent during the execution of the task.",
                    "items": {
                        "$ref": "#/definitions/Artifact"
                    },
                    "type": "array"
                },
                "contextId": {
                    "description": "A server-generated unique identifier (e.g. UUID) for maintaining context across multiple related tasks or interactions.",
                    "type": "string"
                },
                "history": {
                    "description": "An array of messages exchanged during the task, representing the conversation history.",
                    "items": {
                        "$ref": "#/definitions/Message"
                    },
                    "type": "array"
                },
                "id": {
                    "description": "A unique identifier (e.g. UUID) for the task, generated by the server for a new task.",
                    "type": "string"
                },
                "kind": {
                    "const": "task",
                    "description": "The type of this object, used as a discriminator. Always 'task' for a Task.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata for extensions. The key is an extension-specific identifier.",
                    "type": "object"
                },
                "status": {
                    "$ref": "#/definitions/TaskStatus",
                    "description": "The current status of the task, including its state and a descriptive message."
                }
            },
            "required": [
                "contextId",
                "id",
                "kind",
                "status"
            ],
            "type": "object"
        },
        "TaskArtifactUpdateEvent": {
            "description": "An event sent by the agent to notify the client that an artifact has been\ngenerated or updated. This is typically used in streaming models.",
            "properties": {
                "append": {
                    "description": "If true, the content of this artifact should be appended to a previously sent artifact with the same ID.",
                    "type": "boolean"
                },
                "artifact": {
                    "$ref": "#/definitions/Artifact",
                    "description": "The artifact that was generated or updated."
                },
                "contextId": {
                    "description": "The context ID associated with the task.",
                    "type": "string"
                },
                "kind": {
                    "const": "artifact-update",
                    "description": "The type of this event, used as a discriminator. Always 'artifact-update'.",
                    "type": "string"
                },
                "lastChunk": {
                    "description": "If true, this is the final chunk of the artifact.",
                    "type": "boolean"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata for extensions.",
                    "type": "object"
                },
                "taskId": {
                    "description": "The ID of the task this artifact belongs to.",
                    "type": "string"
                }
            },
            "required": [
                "artifact",
                "contextId",
                "kind",
                "taskId"
            ],
            "type": "object"
        },
        "TaskIdParams": {
            "description": "Defines parameters containing a task ID, used for simple task operations.",
            "properties": {
                "id": {
                    "description": "The unique identifier (e.g. UUID) of the task.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with the request.",
                    "type": "object"
                }
            },
            "required": [
                "id"
            ],
            "type": "object"
        },
        "TaskNotCancelableError": {
            "description": "An A2A-specific error indicating that the task is in a state where it cannot be canceled.",
            "properties": {
                "code": {
                    "const": -32002,
                    "description": "The error code for a task that cannot be canceled.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Task cannot be canceled",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "TaskNotFoundError": {
            "description": "An A2A-specific error indicating that the requested task ID was not found.",
            "properties": {
                "code": {
                    "const": -32001,
                    "description": "The error code for a task not found error.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "Task not found",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        },
        "TaskPushNotificationConfig": {
            "description": "A container associating a push notification configuration with a specific task.",
            "properties": {
                "pushNotificationConfig": {
                    "$ref": "#/definitions/PushNotificationConfig",
                    "description": "The push notification configuration for this task."
                },
                "taskId": {
                    "description": "The unique identifier (e.g. UUID) of the task.",
                    "type": "string"
                }
            },
            "required": [
                "pushNotificationConfig",
                "taskId"
            ],
            "type": "object"
        },
        "TaskQueryParams": {
            "description": "Defines parameters for querying a task, with an option to limit history length.",
            "properties": {
                "historyLength": {
                    "description": "The number of most recent messages from the task's history to retrieve.",
                    "type": "integer"
                },
                "id": {
                    "description": "The unique identifier (e.g. UUID) of the task.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with the request.",
                    "type": "object"
                }
            },
            "required": [
                "id"
            ],
            "type": "object"
        },
        "TaskResubscriptionRequest": {
            "description": "Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.",
            "properties": {
                "id": {
                    "description": "The identifier for this request.",
                    "type": [
                        "string",
                        "integer"
                    ]
                },
                "jsonrpc": {
                    "const": "2.0",
                    "description": "The version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
                    "type": "string"
                },
                "method": {
                    "const": "tasks/resubscribe",
                    "description": "The method name. Must be 'tasks/resubscribe'.",
                    "type": "string"
                },
                "params": {
                    "$ref": "#/definitions/TaskIdParams",
                    "description": "The parameters identifying the task to resubscribe to."
                }
            },
            "required": [
                "id",
                "jsonrpc",
                "method",
                "params"
            ],
            "type": "object"
        },
        "TaskState": {
            "description": "Defines the lifecycle states of a Task.",
            "enum": [
                "submitted",
                "working",
                "input-required",
                "completed",
                "canceled",
                "failed",
                "rejected",
                "auth-required",
                "unknown"
            ],
            "type": "string"
        },
        "TaskStatus": {
            "description": "Represents the status of a task at a specific point in time.",
            "properties": {
                "message": {
                    "$ref": "#/definitions/Message",
                    "description": "An optional, human-readable message providing more details about the current status."
                },
                "state": {
                    "$ref": "#/definitions/TaskState",
                    "description": "The current state of the task's lifecycle."
                },
                "timestamp": {
                    "description": "An ISO 8601 datetime string indicating when this status was recorded.",
                    "examples": [
                        "2023-10-27T10:00:00Z"
                    ],
                    "type": "string"
                }
            },
            "required": [
                "state"
            ],
            "type": "object"
        },
        "TaskStatusUpdateEvent": {
            "description": "An event sent by the agent to notify the client of a change in a task's status.\nThis is typically used in streaming or subscription models.",
            "properties": {
                "contextId": {
                    "description": "The context ID associated with the task.",
                    "type": "string"
                },
                "final": {
                    "description": "If true, this is the final event in the stream for this interaction.",
                    "type": "boolean"
                },
                "kind": {
                    "const": "status-update",
                    "description": "The type of this event, used as a discriminator. Always 'status-update'.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata for extensions.",
                    "type": "object"
                },
                "status": {
                    "$ref": "#/definitions/TaskStatus",
                    "description": "The new status of the task."
                },
                "taskId": {
                    "description": "The ID of the task that was updated.",
                    "type": "string"
                }
            },
            "required": [
                "contextId",
                "final",
                "kind",
                "status",
                "taskId"
            ],
            "type": "object"
        },
        "TextPart": {
            "description": "Represents a text segment within a message or artifact.",
            "properties": {
                "kind": {
                    "const": "text",
                    "description": "The type of this part, used as a discriminator. Always 'text'.",
                    "type": "string"
                },
                "metadata": {
                    "additionalProperties": {},
                    "description": "Optional metadata associated with this part.",
                    "type": "object"
                },
                "text": {
                    "description": "The string content of the text part.",
                    "type": "string"
                }
            },
            "required": [
                "kind",
                "text"
            ],
            "type": "object"
        },
        "TransportProtocol": {
            "description": "Supported A2A transport protocols.",
            "enum": [
                "JSONRPC",
                "GRPC",
                "HTTP+JSON"
            ],
            "type": "string"
        },
        "UnsupportedOperationError": {
            "description": "An A2A-specific error indicating that the requested operation is not supported by the agent.",
            "properties": {
                "code": {
                    "const": -32004,
                    "description": "The error code for an unsupported operation.",
                    "type": "integer"
                },
                "data": {
                    "description": "A primitive or structured value containing additional information about the error.\nThis may be omitted."
                },
                "message": {
                    "default": "This operation is not supported",
                    "description": "The error message.",
                    "type": "string"
                }
            },
            "required": [
                "code",
                "message"
            ],
            "type": "object"
        }
    }
}


=================================================

--- START OF FILE types/src/types.ts ---

/**
 * @title A2A (Agent2Agent) Protocol
 * @description This file defines the interfaces and types for the Agent2Agent (A2A) specification.
 * The A2A specification facilitates interoperability between AI agents and clients.
 */

// --8<-- [start:AgentProvider]
/**
 * Represents the service provider of an agent.
 *
 * @TJS-examples [{ "organization": "Google", "url": "https://ai.google.dev" }]
 */
export interface AgentProvider {
  /** The name of the agent provider's organization. */
  organization: string;
  /** A URL for the agent provider's website or relevant documentation. */
  url: string;
}
// --8<-- [end:AgentProvider]

// --8<-- [start:AgentCapabilities]
/**
 * Defines optional capabilities supported by an agent.
 */
export interface AgentCapabilities {
  /** Indicates if the agent supports Server-Sent Events (SSE) for streaming responses. */
  streaming?: boolean;
  /** Indicates if the agent supports sending push notifications for asynchronous task updates. */
  pushNotifications?: boolean;
  /** Indicates if the agent provides a history of state transitions for a task. */
  stateTransitionHistory?: boolean;
  /** A list of protocol extensions supported by the agent. */
  extensions?: AgentExtension[];
}
// --8<-- [end:AgentCapabilities]

// --8<-- [start:AgentExtension]
/**
 * A declaration of a protocol extension supported by an Agent.
 *
 * @TJS-examples [{"uri": "https://developers.google.com/identity/protocols/oauth2", "description": "Google OAuth 2.0 authentication", "required": false}]
 */
export interface AgentExtension {
  /** The unique URI identifying the extension. */
  uri: string;
  /** A human-readable description of how this agent uses the extension. */
  description?: string;
  /**
   * If true, the client must understand and comply with the extension's requirements
   * to interact with the agent.
   */
  required?: boolean;
  /** Optional, extension-specific configuration parameters. */
  params?: { [key: string]: any };
}
// --8<-- [end:AgentExtension]

// --8<-- [start:SecurityScheme]
/**
 * Defines a security scheme that can be used to secure an agent's endpoints.
 * This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.
 *
 * @see {@link https://swagger.io/specification/#security-scheme-object}
 */
export type SecurityScheme =
  | APIKeySecurityScheme
  | HTTPAuthSecurityScheme
  | OAuth2SecurityScheme
  | OpenIdConnectSecurityScheme
  | MutualTLSSecurityScheme;
// --8<-- [end:SecurityScheme]

// --8<-- [start:SecuritySchemeBase]
/**
 * Defines base properties shared by all security scheme objects.
 */
export interface SecuritySchemeBase {
  /** An optional description for the security scheme. */
  description?: string;
}
// --8<-- [end:SecuritySchemeBase]

// --8<-- [start:APIKeySecurityScheme]
/**
 * Defines a security scheme using an API key.
 */
export interface APIKeySecurityScheme extends SecuritySchemeBase {
  /** The type of the security scheme. Must be 'apiKey'. */
  readonly type: "apiKey";
  /** The location of the API key. */
  readonly in: "query" | "header" | "cookie";
  /** The name of the header, query, or cookie parameter to be used. */
  name: string;
}
// --8<-- [end:APIKeySecurityScheme]

// --8<-- [start:HTTPAuthSecurityScheme]
/**
 * Defines a security scheme using HTTP authentication.
 */
export interface HTTPAuthSecurityScheme extends SecuritySchemeBase {
  /** The type of the security scheme. Must be 'http'. */
  readonly type: "http";
  /**
   * The name of the HTTP Authentication scheme to be used in the Authorization header,
   * as defined in RFC7235 (e.g., "Bearer").
   * This value should be registered in the IANA Authentication Scheme registry.
   */
  scheme: string;
  /**
   * A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
   * This is primarily for documentation purposes.
   */
  bearerFormat?: string;
}
// --8<-- [end:HTTPAuthSecurityScheme]

// --8<-- [start:MutualTLSSecurityScheme]
/**
 * Defines a security scheme using mTLS authentication.
 */
export interface MutualTLSSecurityScheme extends SecuritySchemeBase {
  /** The type of the security scheme. Must be 'mutualTLS'. */
  readonly type: "mutualTLS";
}
// --8<-- [end:MutualTLSSecurityScheme]

// --8<-- [start:OAuth2SecurityScheme]
/**
 * Defines a security scheme using OAuth 2.0.
 */
export interface OAuth2SecurityScheme extends SecuritySchemeBase {
  /** The type of the security scheme. Must be 'oauth2'. */
  readonly type: "oauth2";
  /** An object containing configuration information for the supported OAuth 2.0 flows. */
  flows: OAuthFlows;
  /**
   * URL to the oauth2 authorization server metadata
   * [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
   */
  oauth2MetadataUrl?: string;
}
// --8<-- [end:OAuth2SecurityScheme]

// --8<-- [start:OpenIdConnectSecurityScheme]
/**
 * Defines a security scheme using OpenID Connect.
 */
export interface OpenIdConnectSecurityScheme extends SecuritySchemeBase {
  /** The type of the security scheme. Must be 'openIdConnect'. */
  readonly type: "openIdConnect";
  /**
   * The OpenID Connect Discovery URL for the OIDC provider's metadata.
   * @see {@link https://openid.net/specs/openid-connect-discovery-1_0.html}
   */
  openIdConnectUrl: string;
}
// --8<-- [end:OpenIdConnectSecurityScheme]

// --8<-- [start:OAuthFlows]
/**
 * Defines the configuration for the supported OAuth 2.0 flows.
 */
export interface OAuthFlows {
  /** Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0. */
  authorizationCode?: AuthorizationCodeOAuthFlow;
  /** Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0. */
  clientCredentials?: ClientCredentialsOAuthFlow;
  /** Configuration for the OAuth Implicit flow. */
  implicit?: ImplicitOAuthFlow;
  /** Configuration for the OAuth Resource Owner Password flow. */
  password?: PasswordOAuthFlow;
}
// --8<-- [end:OAuthFlows]

// --8<-- [start:AuthorizationCodeOAuthFlow]
/**
 * Defines configuration details for the OAuth 2.0 Authorization Code flow.
 */
export interface AuthorizationCodeOAuthFlow {
  /**
   * The authorization URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
  authorizationUrl: string;
  /**
   * The token URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
  tokenUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens.
   * This MUST be a URL and use TLS.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: { [name: string]: string };
}
// --8<-- [end:AuthorizationCodeOAuthFlow]

// --8<-- [start:ClientCredentialsOAuthFlow]
/**
 * Defines configuration details for the OAuth 2.0 Client Credentials flow.
 */
export interface ClientCredentialsOAuthFlow {
  /**
   * The token URL to be used for this flow. This MUST be a URL.
   */
  tokenUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: { [name: string]: string };
}
// --8<-- [end:ClientCredentialsOAuthFlow]

// --8<-- [start:ImplicitOAuthFlow]
/**
 * Defines configuration details for the OAuth 2.0 Implicit flow.
 */
export interface ImplicitOAuthFlow {
  /**
   * The authorization URL to be used for this flow. This MUST be a URL.
   */
  authorizationUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: { [name: string]: string };
}
// --8<-- [end:ImplicitOAuthFlow]

// --8<-- [start:PasswordOAuthFlow]
/**
 * Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
 */
export interface PasswordOAuthFlow {
  /**
   * The token URL to be used for this flow. This MUST be a URL.
   */
  tokenUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: { [name: string]: string };
}
// --8<-- [end:PasswordOAuthFlow]

// --8<-- [start:AgentSkill]
/**
 * Represents a distinct capability or function that an agent can perform.
 */
export interface AgentSkill {
  /** A unique identifier for the agent's skill. */
  id: string;
  /** A human-readable name for the skill. */
  name: string;
  /**
   * A detailed description of the skill, intended to help clients or users
   * understand its purpose and functionality.
   */
  description: string;
  /**
   * A set of keywords describing the skill's capabilities.
   *
   * @TJS-examples [["cooking", "customer support", "billing"]]
   */
  tags: string[];
  /**
   * Example prompts or scenarios that this skill can handle. Provides a hint to
   * the client on how to use the skill.
   *
   * @TJS-examples [["I need a recipe for bread"]]
   */
  examples?: string[];
  /**
   * The set of supported input MIME types for this skill, overriding the agent's defaults.
   */
  inputModes?: string[];
  /**
   * The set of supported output MIME types for this skill, overriding the agent's defaults.
   */
  outputModes?: string[];
  /**
   * Security schemes necessary for the agent to leverage this skill.
   * As in the overall AgentCard.security, this list represents a logical OR of security
   * requirement objects. Each object is a set of security schemes that must be used together
   * (a logical AND).
   *
   * @TJS-examples [[{"google": ["oidc"]}]]
   */
  security?: { [scheme: string]: string[] }[];
}
// --8<-- [end:AgentSkill]

// --8<-- [start:TransportProtocol]
/**
 * Supported A2A transport protocols.
 */
export enum TransportProtocol {
  JSONRPC = "JSONRPC", // JSON-RPC 2.0 over HTTP (optional)
  GRPC = "GRPC", // gRPC over HTTP/2 (optional)
  HTTP_JSON = "HTTP+JSON", // REST-style HTTP with JSON (optional)
}
// --8<-- [end:TransportProtocol]

// --8<-- [start:AgentInterface]
/**
 * Declares a combination of a target URL and a transport protocol for interacting with the agent.
 * This allows agents to expose the same functionality over multiple transport mechanisms.
 */
export interface AgentInterface {
  /**
   * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
   * @TJS-examples ["https://api.example.com/a2a/v1", "https://grpc.example.com/a2a", "https://rest.example.com/v1"]
   */
  url: string;
  /**
   * The transport protocol supported at this URL.
   *
   * @TJS-examples ["JSONRPC", "GRPC", "HTTP+JSON"]
   */
  transport: TransportProtocol | string;
}
// --8<-- [end:AgentInterface]

// --8<-- [start:AgentCardSignature]
/**
 * AgentCardSignature represents a JWS signature of an AgentCard.
 * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
 */
export interface AgentCardSignature {
  /**
   * The protected JWS header for the signature. This is a Base64url-encoded
   * JSON object, as per RFC 7515.
   */
  protected: string;
  /** The computed signature, Base64url-encoded. */
  signature: string;
  /** The unprotected JWS header values. */
  header?: { [key: string]: any };
}
// --8<-- [end:AgentCardSignature]

// --8<-- [start:AgentCard]
/**
 * The AgentCard is a self-describing manifest for an agent. It provides essential
 * metadata including the agent's identity, capabilities, skills, supported
 * communication methods, and security requirements.
 */
export interface AgentCard {
  /**
   * The version of the A2A protocol this agent supports.
   * @default "0.3.0"
   */
  protocolVersion: string;
  /**
   * A human-readable name for the agent.
   *
   * @TJS-examples ["Recipe Agent"]
   */
  name: string;
  /**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   *
   * @TJS-examples ["Agent that helps users with recipes and cooking."]
   */
  description: string;
  /**
   * The preferred endpoint URL for interacting with the agent.
   * This URL MUST support the transport specified by 'preferredTransport'.
   *
   * @TJS-examples ["https://api.example.com/a2a/v1"]
   */
  url: string;
  /**
   * The transport protocol for the preferred endpoint (the main 'url' field).
   * If not specified, defaults to 'JSONRPC'.
   *
   * IMPORTANT: The transport specified here MUST be available at the main 'url'.
   * This creates a binding between the main URL and its supported transport protocol.
   * Clients should prefer this transport and URL combination when both are supported.
   *
   * @default "JSONRPC"
   * @TJS-examples ["JSONRPC", "GRPC", "HTTP+JSON"]
   */
  preferredTransport?: TransportProtocol | string;
  /**
   * A list of additional supported interfaces (transport and URL combinations).
   * This allows agents to expose multiple transports, potentially at different URLs.
   *
   * Best practices:
   * - SHOULD include all supported transports for completeness
   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'
   * - MAY reuse URLs if multiple transports are available at the same endpoint
   * - MUST accurately declare the transport available at each URL
   *
   * Clients can select any interface from this list based on their transport capabilities
   * and preferences. This enables transport negotiation and fallback scenarios.
   */
  additionalInterfaces?: AgentInterface[];
  /** An optional URL to an icon for the agent. */
  iconUrl?: string;
  /** Information about the agent's service provider. */
  provider?: AgentProvider;
  /**
   * The agent's own version number. The format is defined by the provider.
   *
   * @TJS-examples ["1.0.0"]
   */
  version: string;
  /** An optional URL to the agent's documentation. */
  documentationUrl?: string;
  /** A declaration of optional capabilities supported by the agent. */
  capabilities: AgentCapabilities;
  /**
   * A declaration of the security schemes available to authorize requests. The key is the
   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
   */
  securitySchemes?: { [scheme: string]: SecurityScheme };
  /**
   * A list of security requirement objects that apply to all agent interactions. Each object
   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
   * This list can be seen as an OR of ANDs. Each object in the list describes one possible
   * set of security requirements that must be present on a request. This allows specifying,
   * for example, "callers must either use OAuth OR an API Key AND mTLS."
   *
   * @TJS-examples [[{"oauth": ["read"]}, {"api-key": [], "mtls": []}]]
   */
  security?: { [scheme: string]: string[] }[];
  /**
   * Default set of supported input MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultInputModes: string[];
  /**
   * Default set of supported output MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultOutputModes: string[];
  /** The set of skills, or distinct capabilities, that the agent can perform. */
  skills: AgentSkill[];
  /**
   * If true, the agent can provide an extended agent card with additional details
   * to authenticated users. Defaults to false.
   */
  supportsAuthenticatedExtendedCard?: boolean;
  /** JSON Web Signatures computed for this AgentCard. */
  signatures?: AgentCardSignature[];
}
// --8<-- [end:AgentCard]

// --8<-- [start:Task]
/**
 * Represents a single, stateful operation or conversation between a client and an agent.
 */
export interface Task {
  /** A unique identifier (e.g. UUID) for the task, generated by the server for a new task. */
  id: string;
  /**
   * A server-generated unique identifier (e.g. UUID) for maintaining context across multiple related tasks or interactions.
   */
  contextId: string;
  /** The current status of the task, including its state and a descriptive message. */
  status: TaskStatus;
  /** An array of messages exchanged during the task, representing the conversation history. */
  history?: Message[];
  /** A collection of artifacts generated by the agent during the execution of the task. */
  artifacts?: Artifact[];
  /** Optional metadata for extensions. The key is an extension-specific identifier. */
  metadata?: {
    [key: string]: any;
  };
  /** The type of this object, used as a discriminator. Always 'task' for a Task. */
  readonly kind: "task";
}
// --8<-- [end:Task]

// --8<-- [start:TaskStatus]
/**
 * Represents the status of a task at a specific point in time.
 */
export interface TaskStatus {
  /** The current state of the task's lifecycle. */
  state: TaskState;
  /** An optional, human-readable message providing more details about the current status. */
  message?: Message;
  /**
   * An ISO 8601 datetime string indicating when this status was recorded.
   *
   * @TJS-examples ["2023-10-27T10:00:00Z"]
   */
  timestamp?: string;
}
// --8<-- [end:TaskStatus]

// --8<-- [start:TaskStatusUpdateEvent]
/**
 * An event sent by the agent to notify the client of a change in a task's status.
 * This is typically used in streaming or subscription models.
 */
export interface TaskStatusUpdateEvent {
  /**
   * The ID of the task that was updated.
   */
  taskId: string;
  /**
   * The context ID associated with the task.
   */
  contextId: string;
  /** The type of this event, used as a discriminator. Always 'status-update'. */
  readonly kind: "status-update";
  /** The new status of the task. */
  status: TaskStatus;
  /** If true, this is the final event in the stream for this interaction. */
  final: boolean;
  /** Optional metadata for extensions. */
  metadata?: {
    [key: string]: any;
  };
}
// --8<-- [end:TaskStatusUpdateEvent]

// --8<-- [start:TaskArtifactUpdateEvent]
/**
 * An event sent by the agent to notify the client that an artifact has been
 * generated or updated. This is typically used in streaming models.
 */
export interface TaskArtifactUpdateEvent {
  /**
   * The ID of the task this artifact belongs to.
   */
  taskId: string;
  /**
   * The context ID associated with the task.
   */
  contextId: string;
  /** The type of this event, used as a discriminator. Always 'artifact-update'. */
  readonly kind: "artifact-update";
  /** The artifact that was generated or updated. */
  artifact: Artifact;
  /** If true, the content of this artifact should be appended to a previously sent artifact with the same ID. */
  append?: boolean;
  /** If true, this is the final chunk of the artifact. */
  lastChunk?: boolean;
  /** Optional metadata for extensions. */
  metadata?: {
    [key: string]: any;
  };
}
// --8<-- [end:TaskArtifactUpdateEvent]

// --8<-- [start:TaskIdParams]
/**
 * Defines parameters containing a task ID, used for simple task operations.
 */
export interface TaskIdParams {
  /**
   * The unique identifier (e.g. UUID) of the task.
   */
  id: string;
  /** Optional metadata associated with the request. */
  metadata?: {
    [key: string]: any;
  };
}
// --8<-- [end:TaskIdParams]

// --8<-- [start:TaskQueryParams]
/**
 * Defines parameters for querying a task, with an option to limit history length.
 */
export interface TaskQueryParams extends TaskIdParams {
  /** The number of most recent messages from the task's history to retrieve. */
  historyLength?: number;
}
// --8<-- [end:TaskQueryParams]

// --8<-- [start:GetTaskPushNotificationConfigParams]
/**
 * Defines parameters for fetching a specific push notification configuration for a task.
 */
export interface GetTaskPushNotificationConfigParams extends TaskIdParams {
  /**
   * The ID of the push notification configuration to retrieve.
   */
  pushNotificationConfigId?: string;
}
// --8<-- [end:GetTaskPushNotificationConfigParams]

// --8<-- [start:ListTaskPushNotificationConfigParams]
/**
 * Defines parameters for listing all push notification configurations associated with a task.
 */
export interface ListTaskPushNotificationConfigParams extends TaskIdParams {}
// --8<-- [end:ListTaskPushNotificationConfigParams]

// --8<-- [start:DeleteTaskPushNotificationConfigParams]
/**
 * Defines parameters for deleting a specific push notification configuration for a task.
 */
export interface DeleteTaskPushNotificationConfigParams extends TaskIdParams {
  /**
   * The ID of the push notification configuration to delete.
   */
  pushNotificationConfigId: string;
}
// --8<-- [end:DeleteTaskPushNotificationConfigParams]

// --8<-- [start:ListTasksParams]
/** Parameters for listing tasks with optional filtering criteria. @since 0.4.0 */
export interface ListTasksParams {
  /** Filter tasks by context ID to get tasks from a specific conversation or session. */
  contextId?: string;
  /** Filter tasks by their current status state. */
  status?: TaskState;
  /** Maximum number of tasks to return. Must be between 1 and 100. Defaults to 50 if not specified. */
  pageSize?: number;
  /** Token for pagination. Use the nextPageToken from a previous ListTasksResult response. */
  pageToken?: string;
  /** Number of recent messages to include in each task's history. Must be non-negative. Defaults to 0 if not specified. */
  historyLength?: number;
  /** Filter tasks updated after this timestamp (milliseconds since epoch). Only tasks with a last updated time greater than or equal to this value will be returned. */
  lastUpdatedAfter?: number;
  /** Whether to include artifacts in the returned tasks. Defaults to false to reduce payload size. */
  includeArtifacts?: boolean;
  /** Request-specific metadata. */
  metadata?: {
    [key: string]: any;
  };
}
// --8<-- [end:ListTasksParams]

// --8<-- [start:ListTasksResult]
/** Result object for tasks/list method containing an array of tasks and pagination information. @since 0.4.0 */
export interface ListTasksResult {
  /** Array of tasks matching the specified criteria. */
  tasks: Task[];
  /** Total number of tasks available (before pagination). */
  totalSize: number;
  /** Maximum number of tasks returned in this response. */
  pageSize: number;
  /** Token for retrieving the next page. Empty string if no more results. */
  nextPageToken: string;
}
// --8<-- [end:ListTasksResult]

// --8<-- [start:MessageSendConfiguration]
/**
 * Defines configuration options for a `message/send` or `message/stream` request.
 */
export interface MessageSendConfiguration {
  /** A list of output MIME types the client is prepared to accept in the response. */
  acceptedOutputModes?: string[];
  /** The number of most recent messages from the task's history to retrieve in the response. */
  historyLength?: number;
  /** Configuration for the agent to send push notifications for updates after the initial response. */
  pushNotificationConfig?: PushNotificationConfig;
  /** If true, the client will wait for the task to complete. The server may reject this if the task is long-running. */
  blocking?: boolean;
}
// --8<-- [end:MessageSendConfiguration]

// --8<-- [start:MessageSendParams]
/**
 * Defines the parameters for a request to send a message to an agent. This can be used
 * to create a new task, continue an existing one, or restart a task.
 */
export interface MessageSendParams {
  /** The message object being sent to the agent. */
  message: Message;
  /** Optional configuration for the send request. */
  configuration?: MessageSendConfiguration;
  /** Optional metadata for extensions. */
  metadata?: {
    [key: string]: any;
  };
}
// --8<-- [end:MessageSendParams]

// --8<-- [start:TaskState]
/**
 * Defines the lifecycle states of a Task.
 */
export enum TaskState {
  /** The task has been submitted and is awaiting execution. */
  Submitted = "submitted",
  /** The agent is actively working on the task. */
  Working = "working",
  /** The task is paused and waiting for input from the user. */
  InputRequired = "input-required",
  /** The task has been successfully completed. */
  Completed = "completed",
  /** The task has been canceled by the user. */
  Canceled = "canceled",
  /** The task failed due to an error during execution. */
  Failed = "failed",
  /** The task was rejected by the agent and was not started. */
  Rejected = "rejected",
  /** The task requires authentication to proceed. */
  AuthRequired = "auth-required",
  /** The task is in an unknown or indeterminate state. */
  Unknown = "unknown",
}
// --8<-- [end:TaskState]

// --8<-- [start:Artifact]
/**
 * Represents a file, data structure, or other resource generated by an agent during a task.
 */
export interface Artifact {
  /**
   * A unique identifier (e.g. UUID) for the artifact within the scope of the task.
   */
  artifactId: string;
  /** An optional, human-readable name for the artifact. */
  name?: string;
  /** An optional, human-readable description of the artifact. */
  description?: string;
  /** An array of content parts that make up the artifact. */
  parts: Part[];
  /** Optional metadata for extensions. The key is an extension-specific identifier. */
  metadata?: {
    [key: string]: any;
  };
  /** The URIs of extensions that are relevant to this artifact. */
  extensions?: string[];
}
// --8<-- [end:Artifact]

// --8<-- [start:Message]
/**
 * Represents a single message in the conversation between a user and an agent.
 */
export interface Message {
  /** Identifies the sender of the message. `user` for the client, `agent` for the service. */
  readonly role: "user" | "agent";
  /**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
  parts: Part[];
  /** Optional metadata for extensions. The key is an extension-specific identifier. */
  metadata?: {
    [key: string]: any;
  };
  /** The URIs of extensions that are relevant to this message. */
  extensions?: string[];
  /**
   * A list of other task IDs that this message references for additional context.
   */
  referenceTaskIds?: string[];
  /**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
  messageId: string;
  /**
   * The ID of the task this message is part of. Can be omitted for the first message of a new task.
   */
  taskId?: string;
  /**
   * The context ID for this message, used to group related interactions.
   */
  contextId?: string;
  /** The type of this object, used as a discriminator. Always 'message' for a Message. */
  readonly kind: "message";
}
// --8<-- [end:Message]

// --8<-- [start:PartBase]
/**
 * Defines base properties common to all message or artifact parts.
 */
export interface PartBase {
  /** Optional metadata associated with this part. */
  metadata?: {
    [key: string]: any;
  };
}
// --8<-- [end:PartBase]

// --8<-- [start:TextPart]
/**
 * Represents a text segment within a message or artifact.
 */
export interface TextPart extends PartBase {
  /** The type of this part, used as a discriminator. Always 'text'. */
  readonly kind: "text";
  /** The string content of the text part. */
  text: string;
}
// --8<-- [end:TextPart]

// --8<-- [start:FileBase]
/**
 * Defines base properties for a file.
 */
export interface FileBase {
  /** An optional name for the file (e.g., "document.pdf"). */
  name?: string;
  /** The MIME type of the file (e.g., "application/pdf"). */
  mimeType?: string;
}
// --8<-- [end:FileBase]

// --8<-- [start:FileWithBytes]
/**
 * Represents a file with its content provided directly as a base64-encoded string.
 */
export interface FileWithBytes extends FileBase {
  /** The base64-encoded content of the file. */
  bytes: string;
  /** The `uri` property must be absent when `bytes` is present. */
  uri?: never;
}
// --8<-- [end:FileWithBytes]

// --8<-- [start:FileWithUri]
/**
 * Represents a file with its content located at a specific URI.
 */
export interface FileWithUri extends FileBase {
  /** A URL pointing to the file's content. */
  uri: string;
  /** The `bytes` property must be absent when `uri` is present. */
  bytes?: never;
}
// --8<-- [end:FileWithUri]

// --8<-- [start:FilePart]
/**
 * Represents a file segment within a message or artifact. The file content can be
 * provided either directly as bytes or as a URI.
 */
export interface FilePart extends PartBase {
  /** The type of this part, used as a discriminator. Always 'file'. */
  readonly kind: "file";
  /** The file content, represented as either a URI or as base64-encoded bytes. */
  file: FileWithBytes | FileWithUri;
}
// --8<-- [end:FilePart]

// --8<-- [start:DataPart]
/**
 * Represents a structured data segment (e.g., JSON) within a message or artifact.
 */
export interface DataPart extends PartBase {
  /** The type of this part, used as a discriminator. Always 'data'. */
  readonly kind: "data";
  /** The structured data content. */
  data: {
    [key: string]: any;
  };
}
// --8<-- [end:DataPart]

// --8<-- [start:Part]
/**
 * A discriminated union representing a part of a message or artifact, which can
 * be text, a file, or structured data.
 */
export type Part = TextPart | FilePart | DataPart;
// --8<-- [end:Part]

// --8<-- [start:PushNotificationAuthenticationInfo]
/**
 * Defines authentication details for a push notification endpoint.
 */
export interface PushNotificationAuthenticationInfo {
  /** A list of supported authentication schemes (e.g., 'Basic', 'Bearer'). */
  schemes: string[];
  /** Optional credentials required by the push notification endpoint. */
  credentials?: string;
}
// --8<-- [end:PushNotificationAuthenticationInfo]

// --8<-- [start:PushNotificationConfig]
/**
 * Defines the configuration for setting up push notifications for task updates.
 */
export interface PushNotificationConfig {
  /**
   * A unique identifier (e.g. UUID) for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
  id?: string;
  /** The callback URL where the agent should send push notifications. */
  url: string;
  /** A unique token for this task or session to validate incoming push notifications. */
  token?: string;
  /** Optional authentication details for the agent to use when calling the notification URL. */
  authentication?: PushNotificationAuthenticationInfo;
}
// --8<-- [end:PushNotificationConfig]

// --8<-- [start:TaskPushNotificationConfig]
/**
 * A container associating a push notification configuration with a specific task.
 */
export interface TaskPushNotificationConfig {
  /**
   * The unique identifier (e.g. UUID) of the task.
   */
  taskId: string;
  /** The push notification configuration for this task. */
  pushNotificationConfig: PushNotificationConfig;
}
// --8<-- [end:TaskPushNotificationConfig]

// --8<-- [start:JSONRPCMessage]
/**
 * Defines the base structure for any JSON-RPC 2.0 request, response, or notification.
 */
export interface JSONRPCMessage {
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  readonly jsonrpc: "2.0";
  /**
   * A unique identifier established by the client. It must be a String, a Number, or null.
   * The server must reply with the same value in the response. This property is omitted for notifications.
   *
   * @nullable
   */
  id?: number | string | null;
}
// --8<-- [end:JSONRPCMessage]

// --8<-- [start:JSONRPCRequest]
/**
 * Represents a JSON-RPC 2.0 Request object.
 */
export interface JSONRPCRequest extends JSONRPCMessage {
  /**
   * A string containing the name of the method to be invoked.
   */
  method: string;
  /**
   * A structured value holding the parameter values to be used during the method invocation.
   */
  params?: { [key: string]: any };
}
// --8<-- [end:JSONRPCRequest]

// --8<-- [start:JSONRPCError]
/**
 * Represents a JSON-RPC 2.0 Error object, included in an error response.
 */
export interface JSONRPCError {
  /**
   * A number that indicates the error type that occurred.
   */
  code: number;
  /**
   * A string providing a short description of the error.
   */
  message: string;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: any;
}
// --8<-- [end:JSONRPCError]

// --8<-- [start:JSONRPCResult]
/**
 * Represents a successful JSON-RPC 2.0 Response object.
 */
export interface JSONRPCSuccessResponse extends JSONRPCMessage {
  /**
   * The identifier established by the client.
   * @nullable
   */
  id: number | string | null;
  /**
   * The value of this member is determined by the method invoked on the Server.
   */
  result: any;
  /**
   * This field MUST NOT exist in a success response.
   */
  error?: never;
}
// --8<-- [end:JSONRPCResult]

// --8<-- [start:JSONRPCErrorResponse]
/**
 * Represents a JSON-RPC 2.0 Error Response object.
 */
export interface JSONRPCErrorResponse extends JSONRPCMessage {
  /**
   * The identifier established by the client.
   * @nullable
   */
  id: number | string | null;
  /**
   * This field MUST NOT exist in an error response.
   */
  result?: never;
  /**
   * An object describing the error that occurred.
   */
  error: JSONRPCError | A2AError;
}
// --8<-- [end:JSONRPCErrorResponse]

// --8<-- [start:JSONRPCResponse]
/**
 * A discriminated union representing all possible JSON-RPC 2.0 responses
 * for the A2A specification methods.
 */
export type JSONRPCResponse =
  | SendMessageResponse
  | SendStreamingMessageResponse
  | GetTaskResponse
  | CancelTaskResponse
  | ListTasksResponse
  | SetTaskPushNotificationConfigResponse
  | GetTaskPushNotificationConfigResponse
  | ListTaskPushNotificationConfigResponse
  | DeleteTaskPushNotificationConfigResponse
  | GetAuthenticatedExtendedCardResponse;
// --8<-- [end:JSONRPCResponse]

// --8<-- [start:SendMessageRequest]
/**
 * Represents a JSON-RPC request for the `message/send` method.
 */
export interface SendMessageRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'message/send'. */
  readonly method: "message/send";
  /** The parameters for sending a message. */
  params: MessageSendParams;
}
// --8<-- [end:SendMessageRequest]

// --8<-- [start:SendMessageSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `message/send` method.
 */
export interface SendMessageSuccessResponse extends JSONRPCSuccessResponse {
  /** The result, which can be a direct reply Message or the initial Task object. */
  result: Message | Task;
}
// --8<-- [end:SendMessageSuccessResponse]

// --8<-- [start:SendMessageResponse]
/**
 * Represents a JSON-RPC response for the `message/send` method.
 */
export type SendMessageResponse =
  | SendMessageSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:SendMessageResponse]

// --8<-- [start:SendStreamingMessageRequest]
/**
 * Represents a JSON-RPC request for the `message/stream` method.
 */
export interface SendStreamingMessageRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'message/stream'. */
  readonly method: "message/stream";
  /** The parameters for sending a message. */
  params: MessageSendParams;
}
// --8<-- [end:SendStreamingMessageRequest]

// --8<-- [start:SendStreamingMessageSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `message/stream` method.
 * The server may send multiple response objects for a single request.
 */
export interface SendStreamingMessageSuccessResponse
  extends JSONRPCSuccessResponse {
  /** The result, which can be a Message, Task, or a streaming update event. */
  result: Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;
}
// --8<-- [end:SendStreamingMessageSuccessResponse]

// --8<-- [start:SendStreamingMessageResponse]
/**
 * Represents a JSON-RPC response for the `message/stream` method.
 */
export type SendStreamingMessageResponse =
  | SendStreamingMessageSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:SendStreamingMessageResponse]

// --8<-- [start:GetTaskRequest]
/**
 * Represents a JSON-RPC request for the `tasks/get` method.
 */
export interface GetTaskRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/get'. */
  readonly method: "tasks/get";
  /** The parameters for querying a task. */
  params: TaskQueryParams;
}
// --8<-- [end:GetTaskRequest]

// --8<-- [start:GetTaskSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `tasks/get` method.
 */
export interface GetTaskSuccessResponse extends JSONRPCSuccessResponse {
  /** The result, containing the requested Task object. */
  result: Task;
}
// --8<-- [end:GetTaskSuccessResponse]

// --8<-- [start:GetTaskResponse]
/**
 * Represents a JSON-RPC response for the `tasks/get` method.
 */
export type GetTaskResponse = GetTaskSuccessResponse | JSONRPCErrorResponse;
// --8<-- [end:GetTaskResponse]

// --8<-- [start:ListTasksRequest]
/**
 * JSON-RPC request model for the 'tasks/list' method.
 * @since 0.4.0
 */
export interface ListTasksRequest extends JSONRPCRequest {
  id: number | string;
  /** A String containing the name of the method to be invoked. */
  method: "tasks/list";
  /** A Structured value that holds the parameter values to be used during the invocation of the method. */
  params?: ListTasksParams;
}
// --8<-- [end:ListTasksRequest]

// --8<-- [start:ListTasksSuccessResponse]
/**
 * JSON-RPC success response model for the 'tasks/list' method.
 * @since 0.4.0
 */
export interface ListTasksSuccessResponse extends JSONRPCSuccessResponse {
  /** The result object on success. */
  result: ListTasksResult;
}
// --8<-- [end:ListTasksSuccessResponse]

// --8<-- [start:ListTasksResponse]
/**
 * JSON-RPC response for the 'tasks/list' method.
 * @since 0.4.0
 */
export type ListTasksResponse = ListTasksSuccessResponse | JSONRPCErrorResponse;
// --8<-- [end:ListTasksResponse]

// --8<-- [start:CancelTaskRequest]
/**
 * Represents a JSON-RPC request for the `tasks/cancel` method.
 */
export interface CancelTaskRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/cancel'. */
  readonly method: "tasks/cancel";
  /** The parameters identifying the task to cancel. */
  params: TaskIdParams;
}
// --8<-- [end:CancelTaskRequest]

// --8<-- [start:CancelTaskSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `tasks/cancel` method.
 */
export interface CancelTaskSuccessResponse extends JSONRPCSuccessResponse {
  /** The result, containing the final state of the canceled Task object. */
  result: Task;
}
// --8<-- [end:CancelTaskSuccessResponse]

// --8<-- [start:CancelTaskResponse]
/**
 * Represents a JSON-RPC response for the `tasks/cancel` method.
 */
export type CancelTaskResponse =
  | CancelTaskSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:CancelTaskResponse]

// --8<-- [start:SetTaskPushNotificationConfigRequest]
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
 */
export interface SetTaskPushNotificationConfigRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/pushNotificationConfig/set'. */
  readonly method: "tasks/pushNotificationConfig/set";
  /** The parameters for setting the push notification configuration. */
  params: TaskPushNotificationConfig;
}
// --8<-- [end:SetTaskPushNotificationConfigRequest]

// --8<-- [start:SetTaskPushNotificationConfigSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
 */
export interface SetTaskPushNotificationConfigSuccessResponse
  extends JSONRPCSuccessResponse {
  /** The result, containing the configured push notification settings. */
  result: TaskPushNotificationConfig;
}
// --8<-- [end:SetTaskPushNotificationConfigSuccessResponse]

// --8<-- [start:SetTaskPushNotificationConfigResponse]
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
 */
export type SetTaskPushNotificationConfigResponse =
  | SetTaskPushNotificationConfigSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:SetTaskPushNotificationConfigResponse]

// --8<-- [start:GetTaskPushNotificationConfigRequest]
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
 */
export interface GetTaskPushNotificationConfigRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/pushNotificationConfig/get'. */
  readonly method: "tasks/pushNotificationConfig/get";
  /**
   * The parameters for getting a push notification configuration.
   *
   * @deprecated The `TaskIdParams` type is deprecated for this method. Use `GetTaskPushNotificationConfigParams` instead.
   */
  params: GetTaskPushNotificationConfigParams | TaskIdParams;
}
// --8<-- [end:GetTaskPushNotificationConfigRequest]

// --8<-- [start:GetTaskPushNotificationConfigSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
 */
export interface GetTaskPushNotificationConfigSuccessResponse
  extends JSONRPCSuccessResponse {
  /** The result, containing the requested push notification configuration. */
  result: TaskPushNotificationConfig;
}
// --8<-- [end:GetTaskPushNotificationConfigSuccessResponse]

// --8<-- [start:GetTaskPushNotificationConfigResponse]
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
 */
export type GetTaskPushNotificationConfigResponse =
  | GetTaskPushNotificationConfigSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:GetTaskPushNotificationConfigResponse]

// --8<-- [start:TaskResubscriptionRequest]
/**
 * Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.
 */
export interface TaskResubscriptionRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/resubscribe'. */
  readonly method: "tasks/resubscribe";
  /** The parameters identifying the task to resubscribe to. */
  params: TaskIdParams;
}
// --8<-- [end:TaskResubscriptionRequest]

// --8<-- [start:ListTaskPushNotificationConfigRequest]
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.
 */
export interface ListTaskPushNotificationConfigRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/pushNotificationConfig/list'. */
  readonly method: "tasks/pushNotificationConfig/list";
  /** The parameters identifying the task whose configurations are to be listed. */
  params: ListTaskPushNotificationConfigParams;
}
// --8<-- [end:ListTaskPushNotificationConfigRequest]

// --8<-- [start:ListTaskPushNotificationConfigSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
 */
export interface ListTaskPushNotificationConfigSuccessResponse
  extends JSONRPCSuccessResponse {
  /** The result, containing an array of all push notification configurations for the task. */
  result: TaskPushNotificationConfig[];
}
// --8<-- [end:ListTaskPushNotificationConfigSuccessResponse]

// --8<-- [start:ListTaskPushNotificationConfigResponse]
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
 */
export type ListTaskPushNotificationConfigResponse =
  | ListTaskPushNotificationConfigSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:ListTaskPushNotificationConfigResponse]

// --8<-- [start:DeleteTaskPushNotificationConfigRequest]
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.
 */
export interface DeleteTaskPushNotificationConfigRequest
  extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'tasks/pushNotificationConfig/delete'. */
  readonly method: "tasks/pushNotificationConfig/delete";
  /** The parameters identifying the push notification configuration to delete. */
  params: DeleteTaskPushNotificationConfigParams;
}
// --8<-- [end:DeleteTaskPushNotificationConfigRequest]

// --8<-- [start:DeleteTaskPushNotificationConfigSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
 */
export interface DeleteTaskPushNotificationConfigSuccessResponse
  extends JSONRPCSuccessResponse {
  /** The result is null on successful deletion. */
  result: null;
}
// --8<-- [end:DeleteTaskPushNotificationConfigSuccessResponse]

// --8<-- [start:DeleteTaskPushNotificationConfigResponse]
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
 */
export type DeleteTaskPushNotificationConfigResponse =
  | DeleteTaskPushNotificationConfigSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:DeleteTaskPushNotificationConfigResponse]

// --8<-- [start:GetAuthenticatedExtendedCardRequest]
/**
 * Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.
 */
export interface GetAuthenticatedExtendedCardRequest extends JSONRPCRequest {
  /** The identifier for this request. */
  id: number | string;
  /** The method name. Must be 'agent/getAuthenticatedExtendedCard'. */
  readonly method: "agent/getAuthenticatedExtendedCard";
  /** This method does not accept parameters. */
  params?: never;
}
// --8<-- [end:GetAuthenticatedExtendedCardRequest]

// --8<-- [start:GetAuthenticatedExtendedCardSuccessResponse]
/**
 * Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
 */
export interface GetAuthenticatedExtendedCardSuccessResponse
  extends JSONRPCSuccessResponse {
  /** The result is an Agent Card object. */
  result: AgentCard;
}
// --8<-- [end:GetAuthenticatedExtendedCardSuccessResponse]

// --8<-- [start:GetAuthenticatedExtendedCardResponse]
/**
 * Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
 */
export type GetAuthenticatedExtendedCardResponse =
  | GetAuthenticatedExtendedCardSuccessResponse
  | JSONRPCErrorResponse;
// --8<-- [end:GetAuthenticatedExtendedCardResponse]

// --8<-- [start:A2ARequest]
/**
 * A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.
 */
export type A2ARequest =
  | SendMessageRequest
  | SendStreamingMessageRequest
  | GetTaskRequest
  | CancelTaskRequest
  | ListTasksRequest
  | SetTaskPushNotificationConfigRequest
  | GetTaskPushNotificationConfigRequest
  | TaskResubscriptionRequest
  | ListTaskPushNotificationConfigRequest
  | DeleteTaskPushNotificationConfigRequest
  | GetAuthenticatedExtendedCardRequest;
// --8<-- [end:A2ARequest]

// --8<-- [start:JSONParseError]
/**
 * An error indicating that the server received invalid JSON.
 */
export interface JSONParseError extends JSONRPCError {
  /** The error code for a JSON parse error. */
  readonly code: -32700;
  /**
   * The error message.
   * @default "Invalid JSON payload"
   */
  message: string;
}
// --8<-- [end:JSONParseError]

// --8<-- [start:InvalidRequestError]
/**
 * An error indicating that the JSON sent is not a valid Request object.
 */
export interface InvalidRequestError extends JSONRPCError {
  /** The error code for an invalid request. */
  readonly code: -32600;
  /**
   * The error message.
   * @default "Request payload validation error"
   */
  message: string;
}
// --8<-- [end:InvalidRequestError]

// --8<-- [start:MethodNotFoundError]
/**
 * An error indicating that the requested method does not exist or is not available.
 */
export interface MethodNotFoundError extends JSONRPCError {
  /** The error code for a method not found error. */
  readonly code: -32601;
  /**
   * The error message.
   * @default "Method not found"
   */
  message: string;
}
// --8<-- [end:MethodNotFoundError]

// --8<-- [start:InvalidParamsError]
/**
 * An error indicating that the method parameters are invalid.
 */
export interface InvalidParamsError extends JSONRPCError {
  /** The error code for an invalid parameters error. */
  readonly code: -32602;
  /**
   * The error message.
   * @default "Invalid parameters"
   */
  message: string;
}
// --8<-- [end:InvalidParamsError]

// --8<-- [start:InternalError]
/**
 * An error indicating an internal error on the server.
 */
export interface InternalError extends JSONRPCError {
  /** The error code for an internal server error. */
  readonly code: -32603;
  /**
   * The error message.
   * @default "Internal error"
   */
  message: string;
}
// --8<-- [end:InternalError]

// --8<-- [start:TaskNotFoundError]
/**
 * An A2A-specific error indicating that the requested task ID was not found.
 */
export interface TaskNotFoundError extends JSONRPCError {
  /** The error code for a task not found error. */
  readonly code: -32001;
  /**
   * The error message.
   * @default "Task not found"
   */
  message: string;
}
// --8<-- [end:TaskNotFoundError]

// --8<-- [start:TaskNotCancelableError]
/**
 * An A2A-specific error indicating that the task is in a state where it cannot be canceled.
 */
export interface TaskNotCancelableError extends JSONRPCError {
  /** The error code for a task that cannot be canceled. */
  readonly code: -32002;
  /**
   * The error message.
   * @default "Task cannot be canceled"
   */
  message: string;
}
// --8<-- [end:TaskNotCancelableError]

// --8<-- [start:PushNotificationNotSupportedError]
/**
 * An A2A-specific error indicating that the agent does not support push notifications.
 */
export interface PushNotificationNotSupportedError extends JSONRPCError {
  /** The error code for when push notifications are not supported. */
  readonly code: -32003;
  /**
   * The error message.
   * @default "Push Notification is not supported"
   */
  message: string;
}
// --8<-- [end:PushNotificationNotSupportedError]

// --8<-- [start:UnsupportedOperationError]
/**
 * An A2A-specific error indicating that the requested operation is not supported by the agent.
 */
export interface UnsupportedOperationError extends JSONRPCError {
  /** The error code for an unsupported operation. */
  readonly code: -32004;
  /**
   * The error message.
   * @default "This operation is not supported"
   */
  message: string;
}
// --8<-- [end:UnsupportedOperationError]

// --8<-- [start:ContentTypeNotSupportedError]
/**
 * An A2A-specific error indicating an incompatibility between the requested
 * content types and the agent's capabilities.
 */
export interface ContentTypeNotSupportedError extends JSONRPCError {
  /** The error code for an unsupported content type. */
  readonly code: -32005;
  /**
   * The error message.
   * @default "Incompatible content types"
   */
  message: string;
}
// --8<-- [end:ContentTypeNotSupportedError]

// --8<-- [start:InvalidAgentResponseError]
/**
 * An A2A-specific error indicating that the agent returned a response that
 * does not conform to the specification for the current method.
 */
export interface InvalidAgentResponseError extends JSONRPCError {
  /** The error code for an invalid agent response. */
  readonly code: -32006;
  /**
   * The error message.
   * @default "Invalid agent response"
   */
  message: string;
}
// --8<-- [end:InvalidAgentResponseError]

// --8<-- [start:AuthenticatedExtendedCardNotConfiguredError]
/**
 * An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured
 */
export interface AuthenticatedExtendedCardNotConfiguredError
  extends JSONRPCError {
  /** The error code for when an authenticated extended card is not configured. */
  readonly code: -32007;
  /**
   * The error message.
   * @default "Authenticated Extended Card is not configured"
   */
  message: string;
}
// --8<-- [end:AuthenticatedExtendedCardNotConfiguredError]

// --8<-- [start:A2AError]
/**
 * A discriminated union of all standard JSON-RPC and A2A-specific error types.
 */
export type A2AError =
  | JSONParseError
  | InvalidRequestError
  | MethodNotFoundError
  | InvalidParamsError
  | InternalError
  | TaskNotFoundError
  | TaskNotCancelableError
  | PushNotificationNotSupportedError
  | UnsupportedOperationError
  | ContentTypeNotSupportedError
  | InvalidAgentResponseError
  | AuthenticatedExtendedCardNotConfiguredError;
// --8<-- [end:A2AError]

=================================================

